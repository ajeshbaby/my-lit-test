// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
}

type DirectiveRoot struct {
	Authorized func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	ActionPayload struct {
		ExternalData func(childComplexity int) int
		K8sManifest  func(childComplexity int) int
		Namespace    func(childComplexity int) int
		RequestType  func(childComplexity int) int
		Username     func(childComplexity int) int
	}

	AgentStat struct {
		Active  func(childComplexity int) int
		Cluster func(childComplexity int) int
		Ns      func(childComplexity int) int
		Total   func(childComplexity int) int
	}

	Annotation struct {
		Categories       func(childComplexity int) int
		ChartDescription func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		Repository       func(childComplexity int) int
		Support          func(childComplexity int) int
		Vendor           func(childComplexity int) int
	}

	AnnotationsPromResponse struct {
		Legends      func(childComplexity int) int
		QueryID      func(childComplexity int) int
		SubDataArray func(childComplexity int) int
		Tsvs         func(childComplexity int) int
	}

	AnnotationsTimeStampValue struct {
		Date  func(childComplexity int) int
		Value func(childComplexity int) int
	}

	ApplicationMetadataResponse struct {
		Applications func(childComplexity int) int
		Namespace    func(childComplexity int) int
	}

	ChaosHub struct {
		AuthType      func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		HubName       func(childComplexity int) int
		HubType       func(childComplexity int) int
		ID            func(childComplexity int) int
		IsPrivate     func(childComplexity int) int
		IsRemoved     func(childComplexity int) int
		LastSyncedAt  func(childComplexity int) int
		Password      func(childComplexity int) int
		ProjectID     func(childComplexity int) int
		RepoBranch    func(childComplexity int) int
		RepoURL       func(childComplexity int) int
		SSHPrivateKey func(childComplexity int) int
		Token         func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		UserName      func(childComplexity int) int
	}

	ChaosHubStatus struct {
		AuthType      func(childComplexity int) int
		HubName       func(childComplexity int) int
		HubType       func(childComplexity int) int
		ID            func(childComplexity int) int
		IsAvailable   func(childComplexity int) int
		IsPrivate     func(childComplexity int) int
		IsRemoved     func(childComplexity int) int
		LastSyncedAt  func(childComplexity int) int
		Password      func(childComplexity int) int
		RepoBranch    func(childComplexity int) int
		RepoURL       func(childComplexity int) int
		SSHPrivateKey func(childComplexity int) int
		SSHPublicKey  func(childComplexity int) int
		Token         func(childComplexity int) int
		TotalExp      func(childComplexity int) int
		UserName      func(childComplexity int) int
	}

	ChaosWorkFlowResponse struct {
		CronSyntax          func(childComplexity int) int
		IsCustomWorkflow    func(childComplexity int) int
		WorkflowDescription func(childComplexity int) int
		WorkflowID          func(childComplexity int) int
		WorkflowName        func(childComplexity int) int
	}

	Chart struct {
		APIVersion  func(childComplexity int) int
		Kind        func(childComplexity int) int
		Metadata    func(childComplexity int) int
		PackageInfo func(childComplexity int) int
		Spec        func(childComplexity int) int
	}

	Cluster struct {
		AccessKey             func(childComplexity int) int
		AgentNamespace        func(childComplexity int) int
		AgentNsExists         func(childComplexity int) int
		AgentSaExists         func(childComplexity int) int
		AgentScope            func(childComplexity int) int
		ClusterID             func(childComplexity int) int
		ClusterName           func(childComplexity int) int
		ClusterType           func(childComplexity int) int
		CreatedAt             func(childComplexity int) int
		Description           func(childComplexity int) int
		IsActive              func(childComplexity int) int
		IsClusterConfirmed    func(childComplexity int) int
		IsRegistered          func(childComplexity int) int
		LastWorkflowTimestamp func(childComplexity int) int
		NoOfSchedules         func(childComplexity int) int
		NoOfWorkflows         func(childComplexity int) int
		PlatformName          func(childComplexity int) int
		ProjectID             func(childComplexity int) int
		ServiceAccount        func(childComplexity int) int
		StartTime             func(childComplexity int) int
		Token                 func(childComplexity int) int
		UpdatedAt             func(childComplexity int) int
		Version               func(childComplexity int) int
	}

	ClusterActionResponse struct {
		Action    func(childComplexity int) int
		ProjectID func(childComplexity int) int
	}

	ClusterEventResponse struct {
		Cluster     func(childComplexity int) int
		Description func(childComplexity int) int
		EventID     func(childComplexity int) int
		EventName   func(childComplexity int) int
		EventType   func(childComplexity int) int
	}

	ConfirmClusterRegistrationResponse struct {
		ClusterID          func(childComplexity int) int
		IsClusterConfirmed func(childComplexity int) int
		NewAccessKey       func(childComplexity int) int
	}

	DSResponse struct {
		AccessType        func(childComplexity int) int
		AuthType          func(childComplexity int) int
		BasicAuthPassword func(childComplexity int) int
		BasicAuthUsername func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		DsID              func(childComplexity int) int
		DsName            func(childComplexity int) int
		DsType            func(childComplexity int) int
		DsURL             func(childComplexity int) int
		HTTPMethod        func(childComplexity int) int
		HealthStatus      func(childComplexity int) int
		ProjectID         func(childComplexity int) int
		QueryTimeout      func(childComplexity int) int
		ScrapeInterval    func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
	}

	DashboardPromResponse struct {
		AnnotationsResponse      func(childComplexity int) int
		DashboardMetricsResponse func(childComplexity int) int
	}

	ExperimentDetails struct {
		EngineDetails     func(childComplexity int) int
		ExperimentDetails func(childComplexity int) int
	}

	Experiments struct {
		Csv  func(childComplexity int) int
		Desc func(childComplexity int) int
		Name func(childComplexity int) int
	}

	GitConfigResponse struct {
		AuthType      func(childComplexity int) int
		Branch        func(childComplexity int) int
		Enabled       func(childComplexity int) int
		Password      func(childComplexity int) int
		ProjectID     func(childComplexity int) int
		RepoURL       func(childComplexity int) int
		SSHPrivateKey func(childComplexity int) int
		Token         func(childComplexity int) int
		UserName      func(childComplexity int) int
	}

	HeatmapDataResponse struct {
		Bins func(childComplexity int) int
	}

	ImageRegistry struct {
		EnableRegistry    func(childComplexity int) int
		ImageRegistryName func(childComplexity int) int
		ImageRegistryType func(childComplexity int) int
		ImageRepoName     func(childComplexity int) int
		IsDefault         func(childComplexity int) int
		SecretName        func(childComplexity int) int
		SecretNamespace   func(childComplexity int) int
	}

	ImageRegistryResponse struct {
		CreatedAt         func(childComplexity int) int
		ImageRegistryID   func(childComplexity int) int
		ImageRegistryInfo func(childComplexity int) int
		IsDefault         func(childComplexity int) int
		IsRemoved         func(childComplexity int) int
		ProjectID         func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
	}

	KubeObjectResponse struct {
		ClusterID func(childComplexity int) int
		KubeObj   func(childComplexity int) int
	}

	LabelValue struct {
		Label  func(childComplexity int) int
		Values func(childComplexity int) int
	}

	Link struct {
		Name func(childComplexity int) int
		URL  func(childComplexity int) int
	}

	ListDashboardResponse struct {
		ApplicationMetadataMap    func(childComplexity int) int
		ChaosEventQueryTemplate   func(childComplexity int) int
		ChaosVerdictQueryTemplate func(childComplexity int) int
		ClusterID                 func(childComplexity int) int
		ClusterName               func(childComplexity int) int
		CreatedAt                 func(childComplexity int) int
		DbID                      func(childComplexity int) int
		DbInformation             func(childComplexity int) int
		DbName                    func(childComplexity int) int
		DbTypeID                  func(childComplexity int) int
		DbTypeName                func(childComplexity int) int
		DsHealthStatus            func(childComplexity int) int
		DsID                      func(childComplexity int) int
		DsName                    func(childComplexity int) int
		DsType                    func(childComplexity int) int
		DsURL                     func(childComplexity int) int
		EndTime                   func(childComplexity int) int
		PanelGroups               func(childComplexity int) int
		ProjectID                 func(childComplexity int) int
		RefreshRate               func(childComplexity int) int
		StartTime                 func(childComplexity int) int
		UpdatedAt                 func(childComplexity int) int
		ViewedAt                  func(childComplexity int) int
	}

	ListWorkflowRunsResponse struct {
		TotalNoOfWorkflowRuns func(childComplexity int) int
		WorkflowRuns          func(childComplexity int) int
	}

	ListWorkflowsResponse struct {
		TotalNoOfWorkflows func(childComplexity int) int
		Workflows          func(childComplexity int) int
	}

	Maintainer struct {
		Email func(childComplexity int) int
		Name  func(childComplexity int) int
	}

	Metadata struct {
		Annotations func(childComplexity int) int
		Name        func(childComplexity int) int
		Version     func(childComplexity int) int
	}

	MetricDataForPanel struct {
		PanelID              func(childComplexity int) int
		PanelMetricsResponse func(childComplexity int) int
	}

	MetricDataForPanelGroup struct {
		PanelGroupID              func(childComplexity int) int
		PanelGroupMetricsResponse func(childComplexity int) int
	}

	MetricsPromResponse struct {
		Legends func(childComplexity int) int
		QueryID func(childComplexity int) int
		Tsvs    func(childComplexity int) int
	}

	MetricsTimeStampValue struct {
		Date  func(childComplexity int) int
		Value func(childComplexity int) int
	}

	Mutation struct {
		AddChaosHub                func(childComplexity int, request model.CreateChaosHubRequest) int
		AddRemoteChaosHub          func(childComplexity int, request model.CreateRemoteMyHub) int
		ChaosWorkflowRun           func(childComplexity int, request model.WorkflowRunRequest) int
		ConfirmClusterRegistration func(childComplexity int, request model.ClusterIdentity) int
		CreateChaosWorkFlow        func(childComplexity int, request model.ChaosWorkFlowRequest) int
		CreateDashBoard            func(childComplexity int, dashboard *model.CreateDBInput) int
		CreateDataSource           func(childComplexity int, datasource *model.DSInput) int
		CreateImageRegistry        func(childComplexity int, projectID string, imageRegistryInfo model.ImageRegistryInput) int
		CreateWorkflowTemplate     func(childComplexity int, request *model.TemplateInput) int
		DeleteChaosHub             func(childComplexity int, projectID string, hubID string) int
		DeleteChaosWorkflow        func(childComplexity int, projectID string, workflowID *string, workflowRunID *string) int
		DeleteClusters             func(childComplexity int, projectID string, clusterIDs []*string) int
		DeleteDashboard            func(childComplexity int, projectID string, dbID *string) int
		DeleteDataSource           func(childComplexity int, projectID string, input model.DeleteDSInput) int
		DeleteImageRegistry        func(childComplexity int, imageRegistryID string, projectID string) int
		DeleteWorkflowTemplate     func(childComplexity int, projectID string, templateID string) int
		DisableGitOps              func(childComplexity int, projectID string) int
		EnableGitOps               func(childComplexity int, config model.GitConfig) int
		GenerateSSHKey             func(childComplexity int) int
		GitopsNotifier             func(childComplexity int, clusterInfo model.ClusterIdentity, workflowID string) int
		KubeObj                    func(childComplexity int, request model.KubeObjectData) int
		NewClusterEvent            func(childComplexity int, request model.NewClusterEventRequest) int
		PodLog                     func(childComplexity int, request model.PodLog) int
		ReRunChaosWorkFlow         func(childComplexity int, projectID string, workflowID string) int
		RegisterCluster            func(childComplexity int, request model.RegisterClusterRequest) int
		SaveChaosHub               func(childComplexity int, request model.CreateChaosHubRequest) int
		SyncChaosHub               func(childComplexity int, id string, projectID string) int
		SyncWorkflowRun            func(childComplexity int, projectID string, workflowID string, workflowRunID string) int
		TerminateChaosWorkflow     func(childComplexity int, projectID string, workflowID *string, workflowRunID *string) int
		UpdateChaosHub             func(childComplexity int, request model.UpdateChaosHubRequest) int
		UpdateChaosWorkflow        func(childComplexity int, request *model.ChaosWorkFlowRequest) int
		UpdateDashboard            func(childComplexity int, projectID string, dashboard model.UpdateDBInput, chaosQueryUpdate bool) int
		UpdateDataSource           func(childComplexity int, datasource model.DSInput) int
		UpdateGitOps               func(childComplexity int, config model.GitConfig) int
		UpdateImageRegistry        func(childComplexity int, imageRegistryID string, projectID string, imageRegistryInfo model.ImageRegistryInput) int
		UpdatePanel                func(childComplexity int, panelInput []*model.Panel) int
	}

	Option struct {
		Name func(childComplexity int) int
	}

	PackageInformation struct {
		Experiments func(childComplexity int) int
		PackageName func(childComplexity int) int
	}

	PanelGroupResponse struct {
		PanelGroupID   func(childComplexity int) int
		PanelGroupName func(childComplexity int) int
		Panels         func(childComplexity int) int
	}

	PanelOptionResponse struct {
		GrIDs    func(childComplexity int) int
		LeftAxis func(childComplexity int) int
		Points   func(childComplexity int) int
	}

	PanelResponse struct {
		CreatedAt    func(childComplexity int) int
		PanelID      func(childComplexity int) int
		PanelName    func(childComplexity int) int
		PanelOptions func(childComplexity int) int
		PromQueries  func(childComplexity int) int
		Unit         func(childComplexity int) int
		XAxisDown    func(childComplexity int) int
		YAxisLeft    func(childComplexity int) int
		YAxisRight   func(childComplexity int) int
	}

	PodLogResponse struct {
		Log           func(childComplexity int) int
		PodName       func(childComplexity int) int
		PodType       func(childComplexity int) int
		WorkflowRunID func(childComplexity int) int
	}

	PortalDashboardDataResponse struct {
		DashboardData func(childComplexity int) int
		Name          func(childComplexity int) int
	}

	PredefinedWorkflowList struct {
		WorkflowCsv      func(childComplexity int) int
		WorkflowManifest func(childComplexity int) int
		WorkflowName     func(childComplexity int) int
	}

	ProjectData struct {
		Agents    func(childComplexity int) int
		ProjectID func(childComplexity int) int
		Workflows func(childComplexity int) int
	}

	PromQueryResponse struct {
		CloseArea     func(childComplexity int) int
		Legend        func(childComplexity int) int
		Line          func(childComplexity int) int
		Minstep       func(childComplexity int) int
		PromQueryName func(childComplexity int) int
		QueryID       func(childComplexity int) int
		Resolution    func(childComplexity int) int
	}

	PromSeriesListResponse struct {
		SeriesList func(childComplexity int) int
	}

	PromSeriesResponse struct {
		LabelValues func(childComplexity int) int
		Series      func(childComplexity int) int
	}

	PrometheusDataResponse struct {
		AnnotationsResponse func(childComplexity int) int
		MetricsResponse     func(childComplexity int) int
	}

	Provider struct {
		Name func(childComplexity int) int
	}

	Query struct {
		GetAgentDetails             func(childComplexity int, clusterID string, projectID string) int
		GetExperimentDetails        func(childComplexity int, request model.ExperimentRequest) int
		GetGitOpsDetails            func(childComplexity int, projectID string) int
		GetHubExperiment            func(childComplexity int, request model.ExperimentRequest) int
		GetImageRegistry            func(childComplexity int, imageRegistryID string, projectID string) int
		GetManifest                 func(childComplexity int, projectID string, clusterID string, accessKey string) int
		GetPredefinedExperimentYaml func(childComplexity int, request model.ExperimentRequest) int
		GetPromLabelNamesAndValues  func(childComplexity int, request *model.PromSeriesInput) int
		GetPromSeriesList           func(childComplexity int, request *model.DsDetails) int
		GetPrometheusData           func(childComplexity int, request *model.PrometheusDataRequest) int
		GetServerVersion            func(childComplexity int) int
		GetUsageData                func(childComplexity int, request model.UsageDataRequest) int
		GetWorkflowManifestByID     func(childComplexity int, projectID string, templateID string) int
		GetWorkflowRunStats         func(childComplexity int, workflowRunStatsRequest model.WorkflowRunStatsRequest) int
		GetYAMLData                 func(childComplexity int, request model.ExperimentRequest) int
		ListCharts                  func(childComplexity int, hubName string, projectID string) int
		ListClusters                func(childComplexity int, projectID string, clusterType *string) int
		ListDashboard               func(childComplexity int, projectID string, clusterID *string, dbID *string) int
		ListDataSource              func(childComplexity int, projectID string) int
		ListHeatmapData             func(childComplexity int, projectID string, workflowID string, year int) int
		ListHubStatus               func(childComplexity int, projectID string) int
		ListImageRegistry           func(childComplexity int, projectID string) int
		ListPortalDashboardData     func(childComplexity int, projectID string, hubName string) int
		ListPredefinedWorkflows     func(childComplexity int, hubName string, projectID string) int
		ListWorkflowManifests       func(childComplexity int, projectID string) int
		ListWorkflowRuns            func(childComplexity int, request model.ListWorkflowRunsRequest) int
		ListWorkflowStats           func(childComplexity int, projectID string, filter model.TimeFrequency, showWorkflowRuns bool) int
		ListWorkflows               func(childComplexity int, request model.ListWorkflowsRequest) int
	}

	RegisterClusterResponse struct {
		ClusterID   func(childComplexity int) int
		ClusterName func(childComplexity int) int
		Token       func(childComplexity int) int
	}

	ResourceResponse struct {
		Kind  func(childComplexity int) int
		Names func(childComplexity int) int
	}

	SSHKey struct {
		PrivateKey func(childComplexity int) int
		PublicKey  func(childComplexity int) int
	}

	ServerVersionResponse struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	Spec struct {
		CategoryDescription func(childComplexity int) int
		ChaosExpCRDLink     func(childComplexity int) int
		ChaosType           func(childComplexity int) int
		DisplayName         func(childComplexity int) int
		Experiments         func(childComplexity int) int
		Keywords            func(childComplexity int) int
		Links               func(childComplexity int) int
		Maintainers         func(childComplexity int) int
		Maturity            func(childComplexity int) int
		MinKubeVersion      func(childComplexity int) int
		Platforms           func(childComplexity int) int
		Provider            func(childComplexity int) int
	}

	SubData struct {
		Date        func(childComplexity int) int
		SubDataName func(childComplexity int) int
		Value       func(childComplexity int) int
	}

	Subscription struct {
		ClusterConnect    func(childComplexity int, clusterInfo model.ClusterIdentity) int
		GetClusterEvents  func(childComplexity int, projectID string) int
		GetKubeObject     func(childComplexity int, request model.KubeObjectRequest) int
		GetPodLog         func(childComplexity int, request model.PodLogRequest) int
		GetWorkflowEvents func(childComplexity int, projectID string) int
		ViewDashboard     func(childComplexity int, dashboardID *string, promQueries []*model.PromQueryInput, dashboardQueryMap []*model.QueryMapForPanelGroup, dataVariables model.DataVars) int
	}

	TotalCount struct {
		Agents    func(childComplexity int) int
		Projects  func(childComplexity int) int
		Users     func(childComplexity int) int
		Workflows func(childComplexity int) int
	}

	UsageDataResponse struct {
		Projects     func(childComplexity int) int
		TotalCount   func(childComplexity int) int
		TotalEntries func(childComplexity int) int
	}

	Weightages struct {
		ExperimentName func(childComplexity int) int
		Weightage      func(childComplexity int) int
	}

	Workflow struct {
		ClusterID           func(childComplexity int) int
		ClusterName         func(childComplexity int) int
		ClusterType         func(childComplexity int) int
		CreatedAt           func(childComplexity int) int
		CronSyntax          func(childComplexity int) int
		IsCustomWorkflow    func(childComplexity int) int
		IsRemoved           func(childComplexity int) int
		LastUpdatedBy       func(childComplexity int) int
		ProjectID           func(childComplexity int) int
		UpdatedAt           func(childComplexity int) int
		Weightages          func(childComplexity int) int
		WorkflowDescription func(childComplexity int) int
		WorkflowID          func(childComplexity int) int
		WorkflowManifest    func(childComplexity int) int
		WorkflowName        func(childComplexity int) int
	}

	WorkflowRun struct {
		ClusterID          func(childComplexity int) int
		ClusterName        func(childComplexity int) int
		ClusterType        func(childComplexity int) int
		ExecutedBy         func(childComplexity int) int
		ExecutionData      func(childComplexity int) int
		ExperimentsAwaited func(childComplexity int) int
		ExperimentsFailed  func(childComplexity int) int
		ExperimentsNa      func(childComplexity int) int
		ExperimentsPassed  func(childComplexity int) int
		ExperimentsStopped func(childComplexity int) int
		IsRemoved          func(childComplexity int) int
		LastUpdated        func(childComplexity int) int
		Phase              func(childComplexity int) int
		ProjectID          func(childComplexity int) int
		ResiliencyScore    func(childComplexity int) int
		TotalExperiments   func(childComplexity int) int
		Weightages         func(childComplexity int) int
		WorkflowID         func(childComplexity int) int
		WorkflowName       func(childComplexity int) int
		WorkflowRunID      func(childComplexity int) int
	}

	WorkflowRunDetails struct {
		DateStamp func(childComplexity int) int
		NoOfRuns  func(childComplexity int) int
	}

	WorkflowRunStatsResponse struct {
		AverageResiliencyScore         func(childComplexity int) int
		ExperimentsAwaited             func(childComplexity int) int
		ExperimentsFailed              func(childComplexity int) int
		ExperimentsNa                  func(childComplexity int) int
		ExperimentsPassed              func(childComplexity int) int
		ExperimentsStopped             func(childComplexity int) int
		FailedPercentage               func(childComplexity int) int
		FailedWorkflowRuns             func(childComplexity int) int
		PassedPercentage               func(childComplexity int) int
		RunningWorkflowRuns            func(childComplexity int) int
		SucceededWorkflowRuns          func(childComplexity int) int
		TotalExperiments               func(childComplexity int) int
		TotalWorkflowRuns              func(childComplexity int) int
		WorkflowRunFailedPercentage    func(childComplexity int) int
		WorkflowRunSucceededPercentage func(childComplexity int) int
	}

	WorkflowRunsData struct {
		Value             func(childComplexity int) int
		WorkflowRunDetail func(childComplexity int) int
	}

	WorkflowStat struct {
		ExpRuns   func(childComplexity int) int
		Runs      func(childComplexity int) int
		Schedules func(childComplexity int) int
	}

	WorkflowStatsResponse struct {
		Date  func(childComplexity int) int
		Value func(childComplexity int) int
	}

	WorkflowTemplate struct {
		CreatedAt           func(childComplexity int) int
		IsCustomWorkflow    func(childComplexity int) int
		IsRemoved           func(childComplexity int) int
		Manifest            func(childComplexity int) int
		ProjectID           func(childComplexity int) int
		ProjectName         func(childComplexity int) int
		TemplateDescription func(childComplexity int) int
		TemplateID          func(childComplexity int) int
		TemplateName        func(childComplexity int) int
	}
}

type MutationResolver interface {
	CreateChaosWorkFlow(ctx context.Context, request model.ChaosWorkFlowRequest) (*model.ChaosWorkFlowResponse, error)
	ReRunChaosWorkFlow(ctx context.Context, projectID string, workflowID string) (string, error)
	UpdateChaosWorkflow(ctx context.Context, request *model.ChaosWorkFlowRequest) (*model.ChaosWorkFlowResponse, error)
	DeleteChaosWorkflow(ctx context.Context, projectID string, workflowID *string, workflowRunID *string) (bool, error)
	TerminateChaosWorkflow(ctx context.Context, projectID string, workflowID *string, workflowRunID *string) (bool, error)
	ChaosWorkflowRun(ctx context.Context, request model.WorkflowRunRequest) (string, error)
	SyncWorkflowRun(ctx context.Context, projectID string, workflowID string, workflowRunID string) (bool, error)
	CreateDataSource(ctx context.Context, datasource *model.DSInput) (*model.DSResponse, error)
	CreateDashBoard(ctx context.Context, dashboard *model.CreateDBInput) (*model.ListDashboardResponse, error)
	UpdateDataSource(ctx context.Context, datasource model.DSInput) (*model.DSResponse, error)
	UpdateDashboard(ctx context.Context, projectID string, dashboard model.UpdateDBInput, chaosQueryUpdate bool) (string, error)
	UpdatePanel(ctx context.Context, panelInput []*model.Panel) (string, error)
	DeleteDashboard(ctx context.Context, projectID string, dbID *string) (bool, error)
	DeleteDataSource(ctx context.Context, projectID string, input model.DeleteDSInput) (bool, error)
	RegisterCluster(ctx context.Context, request model.RegisterClusterRequest) (*model.RegisterClusterResponse, error)
	ConfirmClusterRegistration(ctx context.Context, request model.ClusterIdentity) (*model.ConfirmClusterRegistrationResponse, error)
	NewClusterEvent(ctx context.Context, request model.NewClusterEventRequest) (string, error)
	DeleteClusters(ctx context.Context, projectID string, clusterIDs []*string) (string, error)
	PodLog(ctx context.Context, request model.PodLog) (string, error)
	KubeObj(ctx context.Context, request model.KubeObjectData) (string, error)
	GitopsNotifier(ctx context.Context, clusterInfo model.ClusterIdentity, workflowID string) (string, error)
	EnableGitOps(ctx context.Context, config model.GitConfig) (bool, error)
	DisableGitOps(ctx context.Context, projectID string) (bool, error)
	UpdateGitOps(ctx context.Context, config model.GitConfig) (bool, error)
	CreateImageRegistry(ctx context.Context, projectID string, imageRegistryInfo model.ImageRegistryInput) (*model.ImageRegistryResponse, error)
	UpdateImageRegistry(ctx context.Context, imageRegistryID string, projectID string, imageRegistryInfo model.ImageRegistryInput) (*model.ImageRegistryResponse, error)
	DeleteImageRegistry(ctx context.Context, imageRegistryID string, projectID string) (string, error)
	AddChaosHub(ctx context.Context, request model.CreateChaosHubRequest) (*model.ChaosHub, error)
	AddRemoteChaosHub(ctx context.Context, request model.CreateRemoteMyHub) (*model.ChaosHub, error)
	SaveChaosHub(ctx context.Context, request model.CreateChaosHubRequest) (*model.ChaosHub, error)
	SyncChaosHub(ctx context.Context, id string, projectID string) (string, error)
	GenerateSSHKey(ctx context.Context) (*model.SSHKey, error)
	UpdateChaosHub(ctx context.Context, request model.UpdateChaosHubRequest) (*model.ChaosHub, error)
	DeleteChaosHub(ctx context.Context, projectID string, hubID string) (bool, error)
	CreateWorkflowTemplate(ctx context.Context, request *model.TemplateInput) (*model.WorkflowTemplate, error)
	DeleteWorkflowTemplate(ctx context.Context, projectID string, templateID string) (bool, error)
}
type QueryResolver interface {
	ListWorkflows(ctx context.Context, request model.ListWorkflowsRequest) (*model.ListWorkflowsResponse, error)
	ListWorkflowRuns(ctx context.Context, request model.ListWorkflowRunsRequest) (*model.ListWorkflowRunsResponse, error)
	ListHeatmapData(ctx context.Context, projectID string, workflowID string, year int) ([]*model.HeatmapDataResponse, error)
	ListWorkflowStats(ctx context.Context, projectID string, filter model.TimeFrequency, showWorkflowRuns bool) ([]*model.WorkflowStatsResponse, error)
	GetWorkflowRunStats(ctx context.Context, workflowRunStatsRequest model.WorkflowRunStatsRequest) (*model.WorkflowRunStatsResponse, error)
	ListDataSource(ctx context.Context, projectID string) ([]*model.DSResponse, error)
	GetPrometheusData(ctx context.Context, request *model.PrometheusDataRequest) (*model.PrometheusDataResponse, error)
	GetPromLabelNamesAndValues(ctx context.Context, request *model.PromSeriesInput) (*model.PromSeriesResponse, error)
	GetPromSeriesList(ctx context.Context, request *model.DsDetails) (*model.PromSeriesListResponse, error)
	ListDashboard(ctx context.Context, projectID string, clusterID *string, dbID *string) ([]*model.ListDashboardResponse, error)
	ListPortalDashboardData(ctx context.Context, projectID string, hubName string) ([]*model.PortalDashboardDataResponse, error)
	GetServerVersion(ctx context.Context) (*model.ServerVersionResponse, error)
	ListClusters(ctx context.Context, projectID string, clusterType *string) ([]*model.Cluster, error)
	GetAgentDetails(ctx context.Context, clusterID string, projectID string) (*model.Cluster, error)
	GetManifest(ctx context.Context, projectID string, clusterID string, accessKey string) (string, error)
	GetGitOpsDetails(ctx context.Context, projectID string) (*model.GitConfigResponse, error)
	ListImageRegistry(ctx context.Context, projectID string) ([]*model.ImageRegistryResponse, error)
	GetImageRegistry(ctx context.Context, imageRegistryID string, projectID string) (*model.ImageRegistryResponse, error)
	ListCharts(ctx context.Context, hubName string, projectID string) ([]*model.Chart, error)
	GetHubExperiment(ctx context.Context, request model.ExperimentRequest) (*model.Chart, error)
	ListHubStatus(ctx context.Context, projectID string) ([]*model.ChaosHubStatus, error)
	GetYAMLData(ctx context.Context, request model.ExperimentRequest) (string, error)
	GetExperimentDetails(ctx context.Context, request model.ExperimentRequest) (*model.ExperimentDetails, error)
	ListPredefinedWorkflows(ctx context.Context, hubName string, projectID string) ([]*model.PredefinedWorkflowList, error)
	GetPredefinedExperimentYaml(ctx context.Context, request model.ExperimentRequest) (string, error)
	GetUsageData(ctx context.Context, request model.UsageDataRequest) (*model.UsageDataResponse, error)
	ListWorkflowManifests(ctx context.Context, projectID string) ([]*model.WorkflowTemplate, error)
	GetWorkflowManifestByID(ctx context.Context, projectID string, templateID string) (*model.WorkflowTemplate, error)
}
type SubscriptionResolver interface {
	GetWorkflowEvents(ctx context.Context, projectID string) (<-chan *model.WorkflowRun, error)
	ViewDashboard(ctx context.Context, dashboardID *string, promQueries []*model.PromQueryInput, dashboardQueryMap []*model.QueryMapForPanelGroup, dataVariables model.DataVars) (<-chan *model.DashboardPromResponse, error)
	GetClusterEvents(ctx context.Context, projectID string) (<-chan *model.ClusterEventResponse, error)
	ClusterConnect(ctx context.Context, clusterInfo model.ClusterIdentity) (<-chan *model.ClusterActionResponse, error)
	GetPodLog(ctx context.Context, request model.PodLogRequest) (<-chan *model.PodLogResponse, error)
	GetKubeObject(ctx context.Context, request model.KubeObjectRequest) (<-chan *model.KubeObjectResponse, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "ActionPayload.externalData":
		if e.complexity.ActionPayload.ExternalData == nil {
			break
		}

		return e.complexity.ActionPayload.ExternalData(childComplexity), true

	case "ActionPayload.k8sManifest":
		if e.complexity.ActionPayload.K8sManifest == nil {
			break
		}

		return e.complexity.ActionPayload.K8sManifest(childComplexity), true

	case "ActionPayload.namespace":
		if e.complexity.ActionPayload.Namespace == nil {
			break
		}

		return e.complexity.ActionPayload.Namespace(childComplexity), true

	case "ActionPayload.requestType":
		if e.complexity.ActionPayload.RequestType == nil {
			break
		}

		return e.complexity.ActionPayload.RequestType(childComplexity), true

	case "ActionPayload.username":
		if e.complexity.ActionPayload.Username == nil {
			break
		}

		return e.complexity.ActionPayload.Username(childComplexity), true

	case "AgentStat.active":
		if e.complexity.AgentStat.Active == nil {
			break
		}

		return e.complexity.AgentStat.Active(childComplexity), true

	case "AgentStat.cluster":
		if e.complexity.AgentStat.Cluster == nil {
			break
		}

		return e.complexity.AgentStat.Cluster(childComplexity), true

	case "AgentStat.ns":
		if e.complexity.AgentStat.Ns == nil {
			break
		}

		return e.complexity.AgentStat.Ns(childComplexity), true

	case "AgentStat.total":
		if e.complexity.AgentStat.Total == nil {
			break
		}

		return e.complexity.AgentStat.Total(childComplexity), true

	case "Annotation.categories":
		if e.complexity.Annotation.Categories == nil {
			break
		}

		return e.complexity.Annotation.Categories(childComplexity), true

	case "Annotation.chartDescription":
		if e.complexity.Annotation.ChartDescription == nil {
			break
		}

		return e.complexity.Annotation.ChartDescription(childComplexity), true

	case "Annotation.createdAt":
		if e.complexity.Annotation.CreatedAt == nil {
			break
		}

		return e.complexity.Annotation.CreatedAt(childComplexity), true

	case "Annotation.repository":
		if e.complexity.Annotation.Repository == nil {
			break
		}

		return e.complexity.Annotation.Repository(childComplexity), true

	case "Annotation.support":
		if e.complexity.Annotation.Support == nil {
			break
		}

		return e.complexity.Annotation.Support(childComplexity), true

	case "Annotation.vendor":
		if e.complexity.Annotation.Vendor == nil {
			break
		}

		return e.complexity.Annotation.Vendor(childComplexity), true

	case "AnnotationsPromResponse.legends":
		if e.complexity.AnnotationsPromResponse.Legends == nil {
			break
		}

		return e.complexity.AnnotationsPromResponse.Legends(childComplexity), true

	case "AnnotationsPromResponse.queryID":
		if e.complexity.AnnotationsPromResponse.QueryID == nil {
			break
		}

		return e.complexity.AnnotationsPromResponse.QueryID(childComplexity), true

	case "AnnotationsPromResponse.subDataArray":
		if e.complexity.AnnotationsPromResponse.SubDataArray == nil {
			break
		}

		return e.complexity.AnnotationsPromResponse.SubDataArray(childComplexity), true

	case "AnnotationsPromResponse.tsvs":
		if e.complexity.AnnotationsPromResponse.Tsvs == nil {
			break
		}

		return e.complexity.AnnotationsPromResponse.Tsvs(childComplexity), true

	case "AnnotationsTimeStampValue.date":
		if e.complexity.AnnotationsTimeStampValue.Date == nil {
			break
		}

		return e.complexity.AnnotationsTimeStampValue.Date(childComplexity), true

	case "AnnotationsTimeStampValue.value":
		if e.complexity.AnnotationsTimeStampValue.Value == nil {
			break
		}

		return e.complexity.AnnotationsTimeStampValue.Value(childComplexity), true

	case "ApplicationMetadataResponse.applications":
		if e.complexity.ApplicationMetadataResponse.Applications == nil {
			break
		}

		return e.complexity.ApplicationMetadataResponse.Applications(childComplexity), true

	case "ApplicationMetadataResponse.namespace":
		if e.complexity.ApplicationMetadataResponse.Namespace == nil {
			break
		}

		return e.complexity.ApplicationMetadataResponse.Namespace(childComplexity), true

	case "ChaosHub.authType":
		if e.complexity.ChaosHub.AuthType == nil {
			break
		}

		return e.complexity.ChaosHub.AuthType(childComplexity), true

	case "ChaosHub.createdAt":
		if e.complexity.ChaosHub.CreatedAt == nil {
			break
		}

		return e.complexity.ChaosHub.CreatedAt(childComplexity), true

	case "ChaosHub.hubName":
		if e.complexity.ChaosHub.HubName == nil {
			break
		}

		return e.complexity.ChaosHub.HubName(childComplexity), true

	case "ChaosHub.hubType":
		if e.complexity.ChaosHub.HubType == nil {
			break
		}

		return e.complexity.ChaosHub.HubType(childComplexity), true

	case "ChaosHub.id":
		if e.complexity.ChaosHub.ID == nil {
			break
		}

		return e.complexity.ChaosHub.ID(childComplexity), true

	case "ChaosHub.isPrivate":
		if e.complexity.ChaosHub.IsPrivate == nil {
			break
		}

		return e.complexity.ChaosHub.IsPrivate(childComplexity), true

	case "ChaosHub.isRemoved":
		if e.complexity.ChaosHub.IsRemoved == nil {
			break
		}

		return e.complexity.ChaosHub.IsRemoved(childComplexity), true

	case "ChaosHub.lastSyncedAt":
		if e.complexity.ChaosHub.LastSyncedAt == nil {
			break
		}

		return e.complexity.ChaosHub.LastSyncedAt(childComplexity), true

	case "ChaosHub.password":
		if e.complexity.ChaosHub.Password == nil {
			break
		}

		return e.complexity.ChaosHub.Password(childComplexity), true

	case "ChaosHub.projectID":
		if e.complexity.ChaosHub.ProjectID == nil {
			break
		}

		return e.complexity.ChaosHub.ProjectID(childComplexity), true

	case "ChaosHub.repoBranch":
		if e.complexity.ChaosHub.RepoBranch == nil {
			break
		}

		return e.complexity.ChaosHub.RepoBranch(childComplexity), true

	case "ChaosHub.repoURL":
		if e.complexity.ChaosHub.RepoURL == nil {
			break
		}

		return e.complexity.ChaosHub.RepoURL(childComplexity), true

	case "ChaosHub.sshPrivateKey":
		if e.complexity.ChaosHub.SSHPrivateKey == nil {
			break
		}

		return e.complexity.ChaosHub.SSHPrivateKey(childComplexity), true

	case "ChaosHub.token":
		if e.complexity.ChaosHub.Token == nil {
			break
		}

		return e.complexity.ChaosHub.Token(childComplexity), true

	case "ChaosHub.updatedAt":
		if e.complexity.ChaosHub.UpdatedAt == nil {
			break
		}

		return e.complexity.ChaosHub.UpdatedAt(childComplexity), true

	case "ChaosHub.userName":
		if e.complexity.ChaosHub.UserName == nil {
			break
		}

		return e.complexity.ChaosHub.UserName(childComplexity), true

	case "ChaosHubStatus.authType":
		if e.complexity.ChaosHubStatus.AuthType == nil {
			break
		}

		return e.complexity.ChaosHubStatus.AuthType(childComplexity), true

	case "ChaosHubStatus.hubName":
		if e.complexity.ChaosHubStatus.HubName == nil {
			break
		}

		return e.complexity.ChaosHubStatus.HubName(childComplexity), true

	case "ChaosHubStatus.hubType":
		if e.complexity.ChaosHubStatus.HubType == nil {
			break
		}

		return e.complexity.ChaosHubStatus.HubType(childComplexity), true

	case "ChaosHubStatus.id":
		if e.complexity.ChaosHubStatus.ID == nil {
			break
		}

		return e.complexity.ChaosHubStatus.ID(childComplexity), true

	case "ChaosHubStatus.isAvailable":
		if e.complexity.ChaosHubStatus.IsAvailable == nil {
			break
		}

		return e.complexity.ChaosHubStatus.IsAvailable(childComplexity), true

	case "ChaosHubStatus.isPrivate":
		if e.complexity.ChaosHubStatus.IsPrivate == nil {
			break
		}

		return e.complexity.ChaosHubStatus.IsPrivate(childComplexity), true

	case "ChaosHubStatus.isRemoved":
		if e.complexity.ChaosHubStatus.IsRemoved == nil {
			break
		}

		return e.complexity.ChaosHubStatus.IsRemoved(childComplexity), true

	case "ChaosHubStatus.lastSyncedAt":
		if e.complexity.ChaosHubStatus.LastSyncedAt == nil {
			break
		}

		return e.complexity.ChaosHubStatus.LastSyncedAt(childComplexity), true

	case "ChaosHubStatus.password":
		if e.complexity.ChaosHubStatus.Password == nil {
			break
		}

		return e.complexity.ChaosHubStatus.Password(childComplexity), true

	case "ChaosHubStatus.repoBranch":
		if e.complexity.ChaosHubStatus.RepoBranch == nil {
			break
		}

		return e.complexity.ChaosHubStatus.RepoBranch(childComplexity), true

	case "ChaosHubStatus.repoURL":
		if e.complexity.ChaosHubStatus.RepoURL == nil {
			break
		}

		return e.complexity.ChaosHubStatus.RepoURL(childComplexity), true

	case "ChaosHubStatus.sshPrivateKey":
		if e.complexity.ChaosHubStatus.SSHPrivateKey == nil {
			break
		}

		return e.complexity.ChaosHubStatus.SSHPrivateKey(childComplexity), true

	case "ChaosHubStatus.sshPublicKey":
		if e.complexity.ChaosHubStatus.SSHPublicKey == nil {
			break
		}

		return e.complexity.ChaosHubStatus.SSHPublicKey(childComplexity), true

	case "ChaosHubStatus.token":
		if e.complexity.ChaosHubStatus.Token == nil {
			break
		}

		return e.complexity.ChaosHubStatus.Token(childComplexity), true

	case "ChaosHubStatus.totalExp":
		if e.complexity.ChaosHubStatus.TotalExp == nil {
			break
		}

		return e.complexity.ChaosHubStatus.TotalExp(childComplexity), true

	case "ChaosHubStatus.userName":
		if e.complexity.ChaosHubStatus.UserName == nil {
			break
		}

		return e.complexity.ChaosHubStatus.UserName(childComplexity), true

	case "ChaosWorkFlowResponse.cronSyntax":
		if e.complexity.ChaosWorkFlowResponse.CronSyntax == nil {
			break
		}

		return e.complexity.ChaosWorkFlowResponse.CronSyntax(childComplexity), true

	case "ChaosWorkFlowResponse.isCustomWorkflow":
		if e.complexity.ChaosWorkFlowResponse.IsCustomWorkflow == nil {
			break
		}

		return e.complexity.ChaosWorkFlowResponse.IsCustomWorkflow(childComplexity), true

	case "ChaosWorkFlowResponse.workflowDescription":
		if e.complexity.ChaosWorkFlowResponse.WorkflowDescription == nil {
			break
		}

		return e.complexity.ChaosWorkFlowResponse.WorkflowDescription(childComplexity), true

	case "ChaosWorkFlowResponse.workflowID":
		if e.complexity.ChaosWorkFlowResponse.WorkflowID == nil {
			break
		}

		return e.complexity.ChaosWorkFlowResponse.WorkflowID(childComplexity), true

	case "ChaosWorkFlowResponse.workflowName":
		if e.complexity.ChaosWorkFlowResponse.WorkflowName == nil {
			break
		}

		return e.complexity.ChaosWorkFlowResponse.WorkflowName(childComplexity), true

	case "Chart.apiVersion":
		if e.complexity.Chart.APIVersion == nil {
			break
		}

		return e.complexity.Chart.APIVersion(childComplexity), true

	case "Chart.kind":
		if e.complexity.Chart.Kind == nil {
			break
		}

		return e.complexity.Chart.Kind(childComplexity), true

	case "Chart.metadata":
		if e.complexity.Chart.Metadata == nil {
			break
		}

		return e.complexity.Chart.Metadata(childComplexity), true

	case "Chart.packageInfo":
		if e.complexity.Chart.PackageInfo == nil {
			break
		}

		return e.complexity.Chart.PackageInfo(childComplexity), true

	case "Chart.spec":
		if e.complexity.Chart.Spec == nil {
			break
		}

		return e.complexity.Chart.Spec(childComplexity), true

	case "Cluster.accessKey":
		if e.complexity.Cluster.AccessKey == nil {
			break
		}

		return e.complexity.Cluster.AccessKey(childComplexity), true

	case "Cluster.agentNamespace":
		if e.complexity.Cluster.AgentNamespace == nil {
			break
		}

		return e.complexity.Cluster.AgentNamespace(childComplexity), true

	case "Cluster.agentNsExists":
		if e.complexity.Cluster.AgentNsExists == nil {
			break
		}

		return e.complexity.Cluster.AgentNsExists(childComplexity), true

	case "Cluster.agentSaExists":
		if e.complexity.Cluster.AgentSaExists == nil {
			break
		}

		return e.complexity.Cluster.AgentSaExists(childComplexity), true

	case "Cluster.agentScope":
		if e.complexity.Cluster.AgentScope == nil {
			break
		}

		return e.complexity.Cluster.AgentScope(childComplexity), true

	case "Cluster.clusterID":
		if e.complexity.Cluster.ClusterID == nil {
			break
		}

		return e.complexity.Cluster.ClusterID(childComplexity), true

	case "Cluster.clusterName":
		if e.complexity.Cluster.ClusterName == nil {
			break
		}

		return e.complexity.Cluster.ClusterName(childComplexity), true

	case "Cluster.clusterType":
		if e.complexity.Cluster.ClusterType == nil {
			break
		}

		return e.complexity.Cluster.ClusterType(childComplexity), true

	case "Cluster.createdAt":
		if e.complexity.Cluster.CreatedAt == nil {
			break
		}

		return e.complexity.Cluster.CreatedAt(childComplexity), true

	case "Cluster.description":
		if e.complexity.Cluster.Description == nil {
			break
		}

		return e.complexity.Cluster.Description(childComplexity), true

	case "Cluster.isActive":
		if e.complexity.Cluster.IsActive == nil {
			break
		}

		return e.complexity.Cluster.IsActive(childComplexity), true

	case "Cluster.isClusterConfirmed":
		if e.complexity.Cluster.IsClusterConfirmed == nil {
			break
		}

		return e.complexity.Cluster.IsClusterConfirmed(childComplexity), true

	case "Cluster.isRegistered":
		if e.complexity.Cluster.IsRegistered == nil {
			break
		}

		return e.complexity.Cluster.IsRegistered(childComplexity), true

	case "Cluster.lastWorkflowTimestamp":
		if e.complexity.Cluster.LastWorkflowTimestamp == nil {
			break
		}

		return e.complexity.Cluster.LastWorkflowTimestamp(childComplexity), true

	case "Cluster.noOfSchedules":
		if e.complexity.Cluster.NoOfSchedules == nil {
			break
		}

		return e.complexity.Cluster.NoOfSchedules(childComplexity), true

	case "Cluster.noOfWorkflows":
		if e.complexity.Cluster.NoOfWorkflows == nil {
			break
		}

		return e.complexity.Cluster.NoOfWorkflows(childComplexity), true

	case "Cluster.platformName":
		if e.complexity.Cluster.PlatformName == nil {
			break
		}

		return e.complexity.Cluster.PlatformName(childComplexity), true

	case "Cluster.projectID":
		if e.complexity.Cluster.ProjectID == nil {
			break
		}

		return e.complexity.Cluster.ProjectID(childComplexity), true

	case "Cluster.serviceAccount":
		if e.complexity.Cluster.ServiceAccount == nil {
			break
		}

		return e.complexity.Cluster.ServiceAccount(childComplexity), true

	case "Cluster.startTime":
		if e.complexity.Cluster.StartTime == nil {
			break
		}

		return e.complexity.Cluster.StartTime(childComplexity), true

	case "Cluster.token":
		if e.complexity.Cluster.Token == nil {
			break
		}

		return e.complexity.Cluster.Token(childComplexity), true

	case "Cluster.updatedAt":
		if e.complexity.Cluster.UpdatedAt == nil {
			break
		}

		return e.complexity.Cluster.UpdatedAt(childComplexity), true

	case "Cluster.version":
		if e.complexity.Cluster.Version == nil {
			break
		}

		return e.complexity.Cluster.Version(childComplexity), true

	case "ClusterActionResponse.action":
		if e.complexity.ClusterActionResponse.Action == nil {
			break
		}

		return e.complexity.ClusterActionResponse.Action(childComplexity), true

	case "ClusterActionResponse.projectID":
		if e.complexity.ClusterActionResponse.ProjectID == nil {
			break
		}

		return e.complexity.ClusterActionResponse.ProjectID(childComplexity), true

	case "ClusterEventResponse.cluster":
		if e.complexity.ClusterEventResponse.Cluster == nil {
			break
		}

		return e.complexity.ClusterEventResponse.Cluster(childComplexity), true

	case "ClusterEventResponse.description":
		if e.complexity.ClusterEventResponse.Description == nil {
			break
		}

		return e.complexity.ClusterEventResponse.Description(childComplexity), true

	case "ClusterEventResponse.eventID":
		if e.complexity.ClusterEventResponse.EventID == nil {
			break
		}

		return e.complexity.ClusterEventResponse.EventID(childComplexity), true

	case "ClusterEventResponse.eventName":
		if e.complexity.ClusterEventResponse.EventName == nil {
			break
		}

		return e.complexity.ClusterEventResponse.EventName(childComplexity), true

	case "ClusterEventResponse.eventType":
		if e.complexity.ClusterEventResponse.EventType == nil {
			break
		}

		return e.complexity.ClusterEventResponse.EventType(childComplexity), true

	case "ConfirmClusterRegistrationResponse.clusterID":
		if e.complexity.ConfirmClusterRegistrationResponse.ClusterID == nil {
			break
		}

		return e.complexity.ConfirmClusterRegistrationResponse.ClusterID(childComplexity), true

	case "ConfirmClusterRegistrationResponse.isClusterConfirmed":
		if e.complexity.ConfirmClusterRegistrationResponse.IsClusterConfirmed == nil {
			break
		}

		return e.complexity.ConfirmClusterRegistrationResponse.IsClusterConfirmed(childComplexity), true

	case "ConfirmClusterRegistrationResponse.newAccessKey":
		if e.complexity.ConfirmClusterRegistrationResponse.NewAccessKey == nil {
			break
		}

		return e.complexity.ConfirmClusterRegistrationResponse.NewAccessKey(childComplexity), true

	case "DSResponse.accessType":
		if e.complexity.DSResponse.AccessType == nil {
			break
		}

		return e.complexity.DSResponse.AccessType(childComplexity), true

	case "DSResponse.authType":
		if e.complexity.DSResponse.AuthType == nil {
			break
		}

		return e.complexity.DSResponse.AuthType(childComplexity), true

	case "DSResponse.basicAuthPassword":
		if e.complexity.DSResponse.BasicAuthPassword == nil {
			break
		}

		return e.complexity.DSResponse.BasicAuthPassword(childComplexity), true

	case "DSResponse.basicAuthUsername":
		if e.complexity.DSResponse.BasicAuthUsername == nil {
			break
		}

		return e.complexity.DSResponse.BasicAuthUsername(childComplexity), true

	case "DSResponse.createdAt":
		if e.complexity.DSResponse.CreatedAt == nil {
			break
		}

		return e.complexity.DSResponse.CreatedAt(childComplexity), true

	case "DSResponse.dsID":
		if e.complexity.DSResponse.DsID == nil {
			break
		}

		return e.complexity.DSResponse.DsID(childComplexity), true

	case "DSResponse.dsName":
		if e.complexity.DSResponse.DsName == nil {
			break
		}

		return e.complexity.DSResponse.DsName(childComplexity), true

	case "DSResponse.dsType":
		if e.complexity.DSResponse.DsType == nil {
			break
		}

		return e.complexity.DSResponse.DsType(childComplexity), true

	case "DSResponse.dsURL":
		if e.complexity.DSResponse.DsURL == nil {
			break
		}

		return e.complexity.DSResponse.DsURL(childComplexity), true

	case "DSResponse.httpMethod":
		if e.complexity.DSResponse.HTTPMethod == nil {
			break
		}

		return e.complexity.DSResponse.HTTPMethod(childComplexity), true

	case "DSResponse.healthStatus":
		if e.complexity.DSResponse.HealthStatus == nil {
			break
		}

		return e.complexity.DSResponse.HealthStatus(childComplexity), true

	case "DSResponse.projectID":
		if e.complexity.DSResponse.ProjectID == nil {
			break
		}

		return e.complexity.DSResponse.ProjectID(childComplexity), true

	case "DSResponse.queryTimeout":
		if e.complexity.DSResponse.QueryTimeout == nil {
			break
		}

		return e.complexity.DSResponse.QueryTimeout(childComplexity), true

	case "DSResponse.scrapeInterval":
		if e.complexity.DSResponse.ScrapeInterval == nil {
			break
		}

		return e.complexity.DSResponse.ScrapeInterval(childComplexity), true

	case "DSResponse.updatedAt":
		if e.complexity.DSResponse.UpdatedAt == nil {
			break
		}

		return e.complexity.DSResponse.UpdatedAt(childComplexity), true

	case "DashboardPromResponse.annotationsResponse":
		if e.complexity.DashboardPromResponse.AnnotationsResponse == nil {
			break
		}

		return e.complexity.DashboardPromResponse.AnnotationsResponse(childComplexity), true

	case "DashboardPromResponse.dashboardMetricsResponse":
		if e.complexity.DashboardPromResponse.DashboardMetricsResponse == nil {
			break
		}

		return e.complexity.DashboardPromResponse.DashboardMetricsResponse(childComplexity), true

	case "ExperimentDetails.engineDetails":
		if e.complexity.ExperimentDetails.EngineDetails == nil {
			break
		}

		return e.complexity.ExperimentDetails.EngineDetails(childComplexity), true

	case "ExperimentDetails.experimentDetails":
		if e.complexity.ExperimentDetails.ExperimentDetails == nil {
			break
		}

		return e.complexity.ExperimentDetails.ExperimentDetails(childComplexity), true

	case "Experiments.CSV":
		if e.complexity.Experiments.Csv == nil {
			break
		}

		return e.complexity.Experiments.Csv(childComplexity), true

	case "Experiments.desc":
		if e.complexity.Experiments.Desc == nil {
			break
		}

		return e.complexity.Experiments.Desc(childComplexity), true

	case "Experiments.name":
		if e.complexity.Experiments.Name == nil {
			break
		}

		return e.complexity.Experiments.Name(childComplexity), true

	case "GitConfigResponse.authType":
		if e.complexity.GitConfigResponse.AuthType == nil {
			break
		}

		return e.complexity.GitConfigResponse.AuthType(childComplexity), true

	case "GitConfigResponse.branch":
		if e.complexity.GitConfigResponse.Branch == nil {
			break
		}

		return e.complexity.GitConfigResponse.Branch(childComplexity), true

	case "GitConfigResponse.enabled":
		if e.complexity.GitConfigResponse.Enabled == nil {
			break
		}

		return e.complexity.GitConfigResponse.Enabled(childComplexity), true

	case "GitConfigResponse.password":
		if e.complexity.GitConfigResponse.Password == nil {
			break
		}

		return e.complexity.GitConfigResponse.Password(childComplexity), true

	case "GitConfigResponse.projectID":
		if e.complexity.GitConfigResponse.ProjectID == nil {
			break
		}

		return e.complexity.GitConfigResponse.ProjectID(childComplexity), true

	case "GitConfigResponse.repoURL":
		if e.complexity.GitConfigResponse.RepoURL == nil {
			break
		}

		return e.complexity.GitConfigResponse.RepoURL(childComplexity), true

	case "GitConfigResponse.sshPrivateKey":
		if e.complexity.GitConfigResponse.SSHPrivateKey == nil {
			break
		}

		return e.complexity.GitConfigResponse.SSHPrivateKey(childComplexity), true

	case "GitConfigResponse.token":
		if e.complexity.GitConfigResponse.Token == nil {
			break
		}

		return e.complexity.GitConfigResponse.Token(childComplexity), true

	case "GitConfigResponse.userName":
		if e.complexity.GitConfigResponse.UserName == nil {
			break
		}

		return e.complexity.GitConfigResponse.UserName(childComplexity), true

	case "HeatmapDataResponse.bins":
		if e.complexity.HeatmapDataResponse.Bins == nil {
			break
		}

		return e.complexity.HeatmapDataResponse.Bins(childComplexity), true

	case "ImageRegistry.enableRegistry":
		if e.complexity.ImageRegistry.EnableRegistry == nil {
			break
		}

		return e.complexity.ImageRegistry.EnableRegistry(childComplexity), true

	case "ImageRegistry.imageRegistryName":
		if e.complexity.ImageRegistry.ImageRegistryName == nil {
			break
		}

		return e.complexity.ImageRegistry.ImageRegistryName(childComplexity), true

	case "ImageRegistry.imageRegistryType":
		if e.complexity.ImageRegistry.ImageRegistryType == nil {
			break
		}

		return e.complexity.ImageRegistry.ImageRegistryType(childComplexity), true

	case "ImageRegistry.imageRepoName":
		if e.complexity.ImageRegistry.ImageRepoName == nil {
			break
		}

		return e.complexity.ImageRegistry.ImageRepoName(childComplexity), true

	case "ImageRegistry.isDefault":
		if e.complexity.ImageRegistry.IsDefault == nil {
			break
		}

		return e.complexity.ImageRegistry.IsDefault(childComplexity), true

	case "ImageRegistry.secretName":
		if e.complexity.ImageRegistry.SecretName == nil {
			break
		}

		return e.complexity.ImageRegistry.SecretName(childComplexity), true

	case "ImageRegistry.secretNamespace":
		if e.complexity.ImageRegistry.SecretNamespace == nil {
			break
		}

		return e.complexity.ImageRegistry.SecretNamespace(childComplexity), true

	case "ImageRegistryResponse.createdAt":
		if e.complexity.ImageRegistryResponse.CreatedAt == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.CreatedAt(childComplexity), true

	case "ImageRegistryResponse.imageRegistryID":
		if e.complexity.ImageRegistryResponse.ImageRegistryID == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.ImageRegistryID(childComplexity), true

	case "ImageRegistryResponse.imageRegistryInfo":
		if e.complexity.ImageRegistryResponse.ImageRegistryInfo == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.ImageRegistryInfo(childComplexity), true

	case "ImageRegistryResponse.isDefault":
		if e.complexity.ImageRegistryResponse.IsDefault == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.IsDefault(childComplexity), true

	case "ImageRegistryResponse.isRemoved":
		if e.complexity.ImageRegistryResponse.IsRemoved == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.IsRemoved(childComplexity), true

	case "ImageRegistryResponse.projectID":
		if e.complexity.ImageRegistryResponse.ProjectID == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.ProjectID(childComplexity), true

	case "ImageRegistryResponse.updatedAt":
		if e.complexity.ImageRegistryResponse.UpdatedAt == nil {
			break
		}

		return e.complexity.ImageRegistryResponse.UpdatedAt(childComplexity), true

	case "KubeObjectResponse.clusterID":
		if e.complexity.KubeObjectResponse.ClusterID == nil {
			break
		}

		return e.complexity.KubeObjectResponse.ClusterID(childComplexity), true

	case "KubeObjectResponse.kubeObj":
		if e.complexity.KubeObjectResponse.KubeObj == nil {
			break
		}

		return e.complexity.KubeObjectResponse.KubeObj(childComplexity), true

	case "LabelValue.label":
		if e.complexity.LabelValue.Label == nil {
			break
		}

		return e.complexity.LabelValue.Label(childComplexity), true

	case "LabelValue.values":
		if e.complexity.LabelValue.Values == nil {
			break
		}

		return e.complexity.LabelValue.Values(childComplexity), true

	case "Link.name":
		if e.complexity.Link.Name == nil {
			break
		}

		return e.complexity.Link.Name(childComplexity), true

	case "Link.url":
		if e.complexity.Link.URL == nil {
			break
		}

		return e.complexity.Link.URL(childComplexity), true

	case "ListDashboardResponse.applicationMetadataMap":
		if e.complexity.ListDashboardResponse.ApplicationMetadataMap == nil {
			break
		}

		return e.complexity.ListDashboardResponse.ApplicationMetadataMap(childComplexity), true

	case "ListDashboardResponse.chaosEventQueryTemplate":
		if e.complexity.ListDashboardResponse.ChaosEventQueryTemplate == nil {
			break
		}

		return e.complexity.ListDashboardResponse.ChaosEventQueryTemplate(childComplexity), true

	case "ListDashboardResponse.chaosVerdictQueryTemplate":
		if e.complexity.ListDashboardResponse.ChaosVerdictQueryTemplate == nil {
			break
		}

		return e.complexity.ListDashboardResponse.ChaosVerdictQueryTemplate(childComplexity), true

	case "ListDashboardResponse.clusterID":
		if e.complexity.ListDashboardResponse.ClusterID == nil {
			break
		}

		return e.complexity.ListDashboardResponse.ClusterID(childComplexity), true

	case "ListDashboardResponse.clusterName":
		if e.complexity.ListDashboardResponse.ClusterName == nil {
			break
		}

		return e.complexity.ListDashboardResponse.ClusterName(childComplexity), true

	case "ListDashboardResponse.createdAt":
		if e.complexity.ListDashboardResponse.CreatedAt == nil {
			break
		}

		return e.complexity.ListDashboardResponse.CreatedAt(childComplexity), true

	case "ListDashboardResponse.dbID":
		if e.complexity.ListDashboardResponse.DbID == nil {
			break
		}

		return e.complexity.ListDashboardResponse.DbID(childComplexity), true

	case "ListDashboardResponse.dbInformation":
		if e.complexity.ListDashboardResponse.DbInformation == nil {
			break
		}

		return e.complexity.ListDashboardResponse.DbInformation(childComplexity), true

	case "ListDashboardResponse.dbName":
		if e.complexity.ListDashboardResponse.DbName == nil {
			break
		}

		return e.complexity.ListDashboardResponse.DbName(childComplexity), true

	case "ListDashboardResponse.dbTypeID":
		if e.complexity.ListDashboardResponse.DbTypeID == nil {
			break
		}

		return e.complexity.ListDashboardResponse.DbTypeID(childComplexity), true

	case "ListDashboardResponse.dbTypeName":
		if e.complexity.ListDashboardResponse.DbTypeName == nil {
			break
		}

		return e.complexity.ListDashboardResponse.DbTypeName(childComplexity), true

	case "ListDashboardResponse.dsHealthStatus":
		if e.complexity.ListDashboardResponse.DsHealthStatus == nil {
			break
		}

		return e.complexity.ListDashboardResponse.DsHealthStatus(childComplexity), true

	case "ListDashboardResponse.dsID":
		if e.complexity.ListDashboardResponse.DsID == nil {
			break
		}

		return e.complexity.ListDashboardResponse.DsID(childComplexity), true

	case "ListDashboardResponse.dsName":
		if e.complexity.ListDashboardResponse.DsName == nil {
			break
		}

		return e.complexity.ListDashboardResponse.DsName(childComplexity), true

	case "ListDashboardResponse.dsType":
		if e.complexity.ListDashboardResponse.DsType == nil {
			break
		}

		return e.complexity.ListDashboardResponse.DsType(childComplexity), true

	case "ListDashboardResponse.dsURL":
		if e.complexity.ListDashboardResponse.DsURL == nil {
			break
		}

		return e.complexity.ListDashboardResponse.DsURL(childComplexity), true

	case "ListDashboardResponse.endTime":
		if e.complexity.ListDashboardResponse.EndTime == nil {
			break
		}

		return e.complexity.ListDashboardResponse.EndTime(childComplexity), true

	case "ListDashboardResponse.panelGroups":
		if e.complexity.ListDashboardResponse.PanelGroups == nil {
			break
		}

		return e.complexity.ListDashboardResponse.PanelGroups(childComplexity), true

	case "ListDashboardResponse.projectID":
		if e.complexity.ListDashboardResponse.ProjectID == nil {
			break
		}

		return e.complexity.ListDashboardResponse.ProjectID(childComplexity), true

	case "ListDashboardResponse.refreshRate":
		if e.complexity.ListDashboardResponse.RefreshRate == nil {
			break
		}

		return e.complexity.ListDashboardResponse.RefreshRate(childComplexity), true

	case "ListDashboardResponse.startTime":
		if e.complexity.ListDashboardResponse.StartTime == nil {
			break
		}

		return e.complexity.ListDashboardResponse.StartTime(childComplexity), true

	case "ListDashboardResponse.updatedAt":
		if e.complexity.ListDashboardResponse.UpdatedAt == nil {
			break
		}

		return e.complexity.ListDashboardResponse.UpdatedAt(childComplexity), true

	case "ListDashboardResponse.viewedAt":
		if e.complexity.ListDashboardResponse.ViewedAt == nil {
			break
		}

		return e.complexity.ListDashboardResponse.ViewedAt(childComplexity), true

	case "ListWorkflowRunsResponse.totalNoOfWorkflowRuns":
		if e.complexity.ListWorkflowRunsResponse.TotalNoOfWorkflowRuns == nil {
			break
		}

		return e.complexity.ListWorkflowRunsResponse.TotalNoOfWorkflowRuns(childComplexity), true

	case "ListWorkflowRunsResponse.workflowRuns":
		if e.complexity.ListWorkflowRunsResponse.WorkflowRuns == nil {
			break
		}

		return e.complexity.ListWorkflowRunsResponse.WorkflowRuns(childComplexity), true

	case "ListWorkflowsResponse.totalNoOfWorkflows":
		if e.complexity.ListWorkflowsResponse.TotalNoOfWorkflows == nil {
			break
		}

		return e.complexity.ListWorkflowsResponse.TotalNoOfWorkflows(childComplexity), true

	case "ListWorkflowsResponse.workflows":
		if e.complexity.ListWorkflowsResponse.Workflows == nil {
			break
		}

		return e.complexity.ListWorkflowsResponse.Workflows(childComplexity), true

	case "Maintainer.email":
		if e.complexity.Maintainer.Email == nil {
			break
		}

		return e.complexity.Maintainer.Email(childComplexity), true

	case "Maintainer.name":
		if e.complexity.Maintainer.Name == nil {
			break
		}

		return e.complexity.Maintainer.Name(childComplexity), true

	case "Metadata.annotations":
		if e.complexity.Metadata.Annotations == nil {
			break
		}

		return e.complexity.Metadata.Annotations(childComplexity), true

	case "Metadata.name":
		if e.complexity.Metadata.Name == nil {
			break
		}

		return e.complexity.Metadata.Name(childComplexity), true

	case "Metadata.version":
		if e.complexity.Metadata.Version == nil {
			break
		}

		return e.complexity.Metadata.Version(childComplexity), true

	case "MetricDataForPanel.panelID":
		if e.complexity.MetricDataForPanel.PanelID == nil {
			break
		}

		return e.complexity.MetricDataForPanel.PanelID(childComplexity), true

	case "MetricDataForPanel.panelMetricsResponse":
		if e.complexity.MetricDataForPanel.PanelMetricsResponse == nil {
			break
		}

		return e.complexity.MetricDataForPanel.PanelMetricsResponse(childComplexity), true

	case "MetricDataForPanelGroup.panelGroupID":
		if e.complexity.MetricDataForPanelGroup.PanelGroupID == nil {
			break
		}

		return e.complexity.MetricDataForPanelGroup.PanelGroupID(childComplexity), true

	case "MetricDataForPanelGroup.panelGroupMetricsResponse":
		if e.complexity.MetricDataForPanelGroup.PanelGroupMetricsResponse == nil {
			break
		}

		return e.complexity.MetricDataForPanelGroup.PanelGroupMetricsResponse(childComplexity), true

	case "MetricsPromResponse.legends":
		if e.complexity.MetricsPromResponse.Legends == nil {
			break
		}

		return e.complexity.MetricsPromResponse.Legends(childComplexity), true

	case "MetricsPromResponse.queryID":
		if e.complexity.MetricsPromResponse.QueryID == nil {
			break
		}

		return e.complexity.MetricsPromResponse.QueryID(childComplexity), true

	case "MetricsPromResponse.tsvs":
		if e.complexity.MetricsPromResponse.Tsvs == nil {
			break
		}

		return e.complexity.MetricsPromResponse.Tsvs(childComplexity), true

	case "MetricsTimeStampValue.date":
		if e.complexity.MetricsTimeStampValue.Date == nil {
			break
		}

		return e.complexity.MetricsTimeStampValue.Date(childComplexity), true

	case "MetricsTimeStampValue.value":
		if e.complexity.MetricsTimeStampValue.Value == nil {
			break
		}

		return e.complexity.MetricsTimeStampValue.Value(childComplexity), true

	case "Mutation.addChaosHub":
		if e.complexity.Mutation.AddChaosHub == nil {
			break
		}

		args, err := ec.field_Mutation_addChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddChaosHub(childComplexity, args["request"].(model.CreateChaosHubRequest)), true

	case "Mutation.addRemoteChaosHub":
		if e.complexity.Mutation.AddRemoteChaosHub == nil {
			break
		}

		args, err := ec.field_Mutation_addRemoteChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddRemoteChaosHub(childComplexity, args["request"].(model.CreateRemoteMyHub)), true

	case "Mutation.chaosWorkflowRun":
		if e.complexity.Mutation.ChaosWorkflowRun == nil {
			break
		}

		args, err := ec.field_Mutation_chaosWorkflowRun_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ChaosWorkflowRun(childComplexity, args["request"].(model.WorkflowRunRequest)), true

	case "Mutation.confirmClusterRegistration":
		if e.complexity.Mutation.ConfirmClusterRegistration == nil {
			break
		}

		args, err := ec.field_Mutation_confirmClusterRegistration_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfirmClusterRegistration(childComplexity, args["request"].(model.ClusterIdentity)), true

	case "Mutation.createChaosWorkFlow":
		if e.complexity.Mutation.CreateChaosWorkFlow == nil {
			break
		}

		args, err := ec.field_Mutation_createChaosWorkFlow_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateChaosWorkFlow(childComplexity, args["request"].(model.ChaosWorkFlowRequest)), true

	case "Mutation.createDashBoard":
		if e.complexity.Mutation.CreateDashBoard == nil {
			break
		}

		args, err := ec.field_Mutation_createDashBoard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateDashBoard(childComplexity, args["dashboard"].(*model.CreateDBInput)), true

	case "Mutation.createDataSource":
		if e.complexity.Mutation.CreateDataSource == nil {
			break
		}

		args, err := ec.field_Mutation_createDataSource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateDataSource(childComplexity, args["datasource"].(*model.DSInput)), true

	case "Mutation.createImageRegistry":
		if e.complexity.Mutation.CreateImageRegistry == nil {
			break
		}

		args, err := ec.field_Mutation_createImageRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateImageRegistry(childComplexity, args["projectID"].(string), args["imageRegistryInfo"].(model.ImageRegistryInput)), true

	case "Mutation.createWorkflowTemplate":
		if e.complexity.Mutation.CreateWorkflowTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_createWorkflowTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateWorkflowTemplate(childComplexity, args["request"].(*model.TemplateInput)), true

	case "Mutation.deleteChaosHub":
		if e.complexity.Mutation.DeleteChaosHub == nil {
			break
		}

		args, err := ec.field_Mutation_deleteChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteChaosHub(childComplexity, args["projectID"].(string), args["hubID"].(string)), true

	case "Mutation.deleteChaosWorkflow":
		if e.complexity.Mutation.DeleteChaosWorkflow == nil {
			break
		}

		args, err := ec.field_Mutation_deleteChaosWorkflow_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteChaosWorkflow(childComplexity, args["projectID"].(string), args["workflowID"].(*string), args["workflowRunID"].(*string)), true

	case "Mutation.deleteClusters":
		if e.complexity.Mutation.DeleteClusters == nil {
			break
		}

		args, err := ec.field_Mutation_deleteClusters_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteClusters(childComplexity, args["projectID"].(string), args["clusterIDs"].([]*string)), true

	case "Mutation.deleteDashboard":
		if e.complexity.Mutation.DeleteDashboard == nil {
			break
		}

		args, err := ec.field_Mutation_deleteDashboard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteDashboard(childComplexity, args["projectID"].(string), args["dbID"].(*string)), true

	case "Mutation.deleteDataSource":
		if e.complexity.Mutation.DeleteDataSource == nil {
			break
		}

		args, err := ec.field_Mutation_deleteDataSource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteDataSource(childComplexity, args["projectID"].(string), args["input"].(model.DeleteDSInput)), true

	case "Mutation.deleteImageRegistry":
		if e.complexity.Mutation.DeleteImageRegistry == nil {
			break
		}

		args, err := ec.field_Mutation_deleteImageRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteImageRegistry(childComplexity, args["imageRegistryID"].(string), args["projectID"].(string)), true

	case "Mutation.deleteWorkflowTemplate":
		if e.complexity.Mutation.DeleteWorkflowTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_deleteWorkflowTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteWorkflowTemplate(childComplexity, args["projectID"].(string), args["templateID"].(string)), true

	case "Mutation.disableGitOps":
		if e.complexity.Mutation.DisableGitOps == nil {
			break
		}

		args, err := ec.field_Mutation_disableGitOps_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DisableGitOps(childComplexity, args["projectID"].(string)), true

	case "Mutation.enableGitOps":
		if e.complexity.Mutation.EnableGitOps == nil {
			break
		}

		args, err := ec.field_Mutation_enableGitOps_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EnableGitOps(childComplexity, args["config"].(model.GitConfig)), true

	case "Mutation.generateSSHKey":
		if e.complexity.Mutation.GenerateSSHKey == nil {
			break
		}

		return e.complexity.Mutation.GenerateSSHKey(childComplexity), true

	case "Mutation.gitopsNotifier":
		if e.complexity.Mutation.GitopsNotifier == nil {
			break
		}

		args, err := ec.field_Mutation_gitopsNotifier_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.GitopsNotifier(childComplexity, args["clusterInfo"].(model.ClusterIdentity), args["workflowID"].(string)), true

	case "Mutation.kubeObj":
		if e.complexity.Mutation.KubeObj == nil {
			break
		}

		args, err := ec.field_Mutation_kubeObj_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.KubeObj(childComplexity, args["request"].(model.KubeObjectData)), true

	case "Mutation.newClusterEvent":
		if e.complexity.Mutation.NewClusterEvent == nil {
			break
		}

		args, err := ec.field_Mutation_newClusterEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.NewClusterEvent(childComplexity, args["request"].(model.NewClusterEventRequest)), true

	case "Mutation.podLog":
		if e.complexity.Mutation.PodLog == nil {
			break
		}

		args, err := ec.field_Mutation_podLog_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PodLog(childComplexity, args["request"].(model.PodLog)), true

	case "Mutation.reRunChaosWorkFlow":
		if e.complexity.Mutation.ReRunChaosWorkFlow == nil {
			break
		}

		args, err := ec.field_Mutation_reRunChaosWorkFlow_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ReRunChaosWorkFlow(childComplexity, args["projectID"].(string), args["workflowID"].(string)), true

	case "Mutation.registerCluster":
		if e.complexity.Mutation.RegisterCluster == nil {
			break
		}

		args, err := ec.field_Mutation_registerCluster_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterCluster(childComplexity, args["request"].(model.RegisterClusterRequest)), true

	case "Mutation.saveChaosHub":
		if e.complexity.Mutation.SaveChaosHub == nil {
			break
		}

		args, err := ec.field_Mutation_saveChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveChaosHub(childComplexity, args["request"].(model.CreateChaosHubRequest)), true

	case "Mutation.syncChaosHub":
		if e.complexity.Mutation.SyncChaosHub == nil {
			break
		}

		args, err := ec.field_Mutation_syncChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SyncChaosHub(childComplexity, args["id"].(string), args["projectID"].(string)), true

	case "Mutation.syncWorkflowRun":
		if e.complexity.Mutation.SyncWorkflowRun == nil {
			break
		}

		args, err := ec.field_Mutation_syncWorkflowRun_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SyncWorkflowRun(childComplexity, args["projectID"].(string), args["workflowID"].(string), args["workflowRunID"].(string)), true

	case "Mutation.terminateChaosWorkflow":
		if e.complexity.Mutation.TerminateChaosWorkflow == nil {
			break
		}

		args, err := ec.field_Mutation_terminateChaosWorkflow_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TerminateChaosWorkflow(childComplexity, args["projectID"].(string), args["workflowID"].(*string), args["workflowRunID"].(*string)), true

	case "Mutation.updateChaosHub":
		if e.complexity.Mutation.UpdateChaosHub == nil {
			break
		}

		args, err := ec.field_Mutation_updateChaosHub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateChaosHub(childComplexity, args["request"].(model.UpdateChaosHubRequest)), true

	case "Mutation.updateChaosWorkflow":
		if e.complexity.Mutation.UpdateChaosWorkflow == nil {
			break
		}

		args, err := ec.field_Mutation_updateChaosWorkflow_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateChaosWorkflow(childComplexity, args["request"].(*model.ChaosWorkFlowRequest)), true

	case "Mutation.updateDashboard":
		if e.complexity.Mutation.UpdateDashboard == nil {
			break
		}

		args, err := ec.field_Mutation_updateDashboard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateDashboard(childComplexity, args["projectID"].(string), args["dashboard"].(model.UpdateDBInput), args["chaosQueryUpdate"].(bool)), true

	case "Mutation.updateDataSource":
		if e.complexity.Mutation.UpdateDataSource == nil {
			break
		}

		args, err := ec.field_Mutation_updateDataSource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateDataSource(childComplexity, args["datasource"].(model.DSInput)), true

	case "Mutation.updateGitOps":
		if e.complexity.Mutation.UpdateGitOps == nil {
			break
		}

		args, err := ec.field_Mutation_updateGitOps_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateGitOps(childComplexity, args["config"].(model.GitConfig)), true

	case "Mutation.updateImageRegistry":
		if e.complexity.Mutation.UpdateImageRegistry == nil {
			break
		}

		args, err := ec.field_Mutation_updateImageRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateImageRegistry(childComplexity, args["imageRegistryID"].(string), args["projectID"].(string), args["imageRegistryInfo"].(model.ImageRegistryInput)), true

	case "Mutation.updatePanel":
		if e.complexity.Mutation.UpdatePanel == nil {
			break
		}

		args, err := ec.field_Mutation_updatePanel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePanel(childComplexity, args["panelInput"].([]*model.Panel)), true

	case "Option.name":
		if e.complexity.Option.Name == nil {
			break
		}

		return e.complexity.Option.Name(childComplexity), true

	case "PackageInformation.experiments":
		if e.complexity.PackageInformation.Experiments == nil {
			break
		}

		return e.complexity.PackageInformation.Experiments(childComplexity), true

	case "PackageInformation.packageName":
		if e.complexity.PackageInformation.PackageName == nil {
			break
		}

		return e.complexity.PackageInformation.PackageName(childComplexity), true

	case "PanelGroupResponse.panelGroupID":
		if e.complexity.PanelGroupResponse.PanelGroupID == nil {
			break
		}

		return e.complexity.PanelGroupResponse.PanelGroupID(childComplexity), true

	case "PanelGroupResponse.panelGroupName":
		if e.complexity.PanelGroupResponse.PanelGroupName == nil {
			break
		}

		return e.complexity.PanelGroupResponse.PanelGroupName(childComplexity), true

	case "PanelGroupResponse.panels":
		if e.complexity.PanelGroupResponse.Panels == nil {
			break
		}

		return e.complexity.PanelGroupResponse.Panels(childComplexity), true

	case "PanelOptionResponse.grIDs":
		if e.complexity.PanelOptionResponse.GrIDs == nil {
			break
		}

		return e.complexity.PanelOptionResponse.GrIDs(childComplexity), true

	case "PanelOptionResponse.leftAxis":
		if e.complexity.PanelOptionResponse.LeftAxis == nil {
			break
		}

		return e.complexity.PanelOptionResponse.LeftAxis(childComplexity), true

	case "PanelOptionResponse.points":
		if e.complexity.PanelOptionResponse.Points == nil {
			break
		}

		return e.complexity.PanelOptionResponse.Points(childComplexity), true

	case "PanelResponse.createdAt":
		if e.complexity.PanelResponse.CreatedAt == nil {
			break
		}

		return e.complexity.PanelResponse.CreatedAt(childComplexity), true

	case "PanelResponse.panelID":
		if e.complexity.PanelResponse.PanelID == nil {
			break
		}

		return e.complexity.PanelResponse.PanelID(childComplexity), true

	case "PanelResponse.panelName":
		if e.complexity.PanelResponse.PanelName == nil {
			break
		}

		return e.complexity.PanelResponse.PanelName(childComplexity), true

	case "PanelResponse.panelOptions":
		if e.complexity.PanelResponse.PanelOptions == nil {
			break
		}

		return e.complexity.PanelResponse.PanelOptions(childComplexity), true

	case "PanelResponse.promQueries":
		if e.complexity.PanelResponse.PromQueries == nil {
			break
		}

		return e.complexity.PanelResponse.PromQueries(childComplexity), true

	case "PanelResponse.unit":
		if e.complexity.PanelResponse.Unit == nil {
			break
		}

		return e.complexity.PanelResponse.Unit(childComplexity), true

	case "PanelResponse.xAxisDown":
		if e.complexity.PanelResponse.XAxisDown == nil {
			break
		}

		return e.complexity.PanelResponse.XAxisDown(childComplexity), true

	case "PanelResponse.yAxisLeft":
		if e.complexity.PanelResponse.YAxisLeft == nil {
			break
		}

		return e.complexity.PanelResponse.YAxisLeft(childComplexity), true

	case "PanelResponse.yAxisRight":
		if e.complexity.PanelResponse.YAxisRight == nil {
			break
		}

		return e.complexity.PanelResponse.YAxisRight(childComplexity), true

	case "PodLogResponse.log":
		if e.complexity.PodLogResponse.Log == nil {
			break
		}

		return e.complexity.PodLogResponse.Log(childComplexity), true

	case "PodLogResponse.podName":
		if e.complexity.PodLogResponse.PodName == nil {
			break
		}

		return e.complexity.PodLogResponse.PodName(childComplexity), true

	case "PodLogResponse.podType":
		if e.complexity.PodLogResponse.PodType == nil {
			break
		}

		return e.complexity.PodLogResponse.PodType(childComplexity), true

	case "PodLogResponse.workflowRunID":
		if e.complexity.PodLogResponse.WorkflowRunID == nil {
			break
		}

		return e.complexity.PodLogResponse.WorkflowRunID(childComplexity), true

	case "PortalDashboardDataResponse.dashboardData":
		if e.complexity.PortalDashboardDataResponse.DashboardData == nil {
			break
		}

		return e.complexity.PortalDashboardDataResponse.DashboardData(childComplexity), true

	case "PortalDashboardDataResponse.name":
		if e.complexity.PortalDashboardDataResponse.Name == nil {
			break
		}

		return e.complexity.PortalDashboardDataResponse.Name(childComplexity), true

	case "PredefinedWorkflowList.workflowCSV":
		if e.complexity.PredefinedWorkflowList.WorkflowCsv == nil {
			break
		}

		return e.complexity.PredefinedWorkflowList.WorkflowCsv(childComplexity), true

	case "PredefinedWorkflowList.workflowManifest":
		if e.complexity.PredefinedWorkflowList.WorkflowManifest == nil {
			break
		}

		return e.complexity.PredefinedWorkflowList.WorkflowManifest(childComplexity), true

	case "PredefinedWorkflowList.workflowName":
		if e.complexity.PredefinedWorkflowList.WorkflowName == nil {
			break
		}

		return e.complexity.PredefinedWorkflowList.WorkflowName(childComplexity), true

	case "ProjectData.agents":
		if e.complexity.ProjectData.Agents == nil {
			break
		}

		return e.complexity.ProjectData.Agents(childComplexity), true

	case "ProjectData.projectID":
		if e.complexity.ProjectData.ProjectID == nil {
			break
		}

		return e.complexity.ProjectData.ProjectID(childComplexity), true

	case "ProjectData.workflows":
		if e.complexity.ProjectData.Workflows == nil {
			break
		}

		return e.complexity.ProjectData.Workflows(childComplexity), true

	case "PromQueryResponse.closeArea":
		if e.complexity.PromQueryResponse.CloseArea == nil {
			break
		}

		return e.complexity.PromQueryResponse.CloseArea(childComplexity), true

	case "PromQueryResponse.legend":
		if e.complexity.PromQueryResponse.Legend == nil {
			break
		}

		return e.complexity.PromQueryResponse.Legend(childComplexity), true

	case "PromQueryResponse.line":
		if e.complexity.PromQueryResponse.Line == nil {
			break
		}

		return e.complexity.PromQueryResponse.Line(childComplexity), true

	case "PromQueryResponse.minstep":
		if e.complexity.PromQueryResponse.Minstep == nil {
			break
		}

		return e.complexity.PromQueryResponse.Minstep(childComplexity), true

	case "PromQueryResponse.promQueryName":
		if e.complexity.PromQueryResponse.PromQueryName == nil {
			break
		}

		return e.complexity.PromQueryResponse.PromQueryName(childComplexity), true

	case "PromQueryResponse.queryID":
		if e.complexity.PromQueryResponse.QueryID == nil {
			break
		}

		return e.complexity.PromQueryResponse.QueryID(childComplexity), true

	case "PromQueryResponse.resolution":
		if e.complexity.PromQueryResponse.Resolution == nil {
			break
		}

		return e.complexity.PromQueryResponse.Resolution(childComplexity), true

	case "PromSeriesListResponse.seriesList":
		if e.complexity.PromSeriesListResponse.SeriesList == nil {
			break
		}

		return e.complexity.PromSeriesListResponse.SeriesList(childComplexity), true

	case "PromSeriesResponse.labelValues":
		if e.complexity.PromSeriesResponse.LabelValues == nil {
			break
		}

		return e.complexity.PromSeriesResponse.LabelValues(childComplexity), true

	case "PromSeriesResponse.series":
		if e.complexity.PromSeriesResponse.Series == nil {
			break
		}

		return e.complexity.PromSeriesResponse.Series(childComplexity), true

	case "PrometheusDataResponse.annotationsResponse":
		if e.complexity.PrometheusDataResponse.AnnotationsResponse == nil {
			break
		}

		return e.complexity.PrometheusDataResponse.AnnotationsResponse(childComplexity), true

	case "PrometheusDataResponse.metricsResponse":
		if e.complexity.PrometheusDataResponse.MetricsResponse == nil {
			break
		}

		return e.complexity.PrometheusDataResponse.MetricsResponse(childComplexity), true

	case "Provider.name":
		if e.complexity.Provider.Name == nil {
			break
		}

		return e.complexity.Provider.Name(childComplexity), true

	case "Query.getAgentDetails":
		if e.complexity.Query.GetAgentDetails == nil {
			break
		}

		args, err := ec.field_Query_getAgentDetails_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetAgentDetails(childComplexity, args["clusterID"].(string), args["projectID"].(string)), true

	case "Query.getExperimentDetails":
		if e.complexity.Query.GetExperimentDetails == nil {
			break
		}

		args, err := ec.field_Query_getExperimentDetails_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetExperimentDetails(childComplexity, args["request"].(model.ExperimentRequest)), true

	case "Query.getGitOpsDetails":
		if e.complexity.Query.GetGitOpsDetails == nil {
			break
		}

		args, err := ec.field_Query_getGitOpsDetails_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetGitOpsDetails(childComplexity, args["projectID"].(string)), true

	case "Query.getHubExperiment":
		if e.complexity.Query.GetHubExperiment == nil {
			break
		}

		args, err := ec.field_Query_getHubExperiment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetHubExperiment(childComplexity, args["request"].(model.ExperimentRequest)), true

	case "Query.getImageRegistry":
		if e.complexity.Query.GetImageRegistry == nil {
			break
		}

		args, err := ec.field_Query_getImageRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetImageRegistry(childComplexity, args["imageRegistryID"].(string), args["projectID"].(string)), true

	case "Query.getManifest":
		if e.complexity.Query.GetManifest == nil {
			break
		}

		args, err := ec.field_Query_getManifest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetManifest(childComplexity, args["projectID"].(string), args["clusterID"].(string), args["accessKey"].(string)), true

	case "Query.getPredefinedExperimentYAML":
		if e.complexity.Query.GetPredefinedExperimentYaml == nil {
			break
		}

		args, err := ec.field_Query_getPredefinedExperimentYAML_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetPredefinedExperimentYaml(childComplexity, args["request"].(model.ExperimentRequest)), true

	case "Query.getPromLabelNamesAndValues":
		if e.complexity.Query.GetPromLabelNamesAndValues == nil {
			break
		}

		args, err := ec.field_Query_getPromLabelNamesAndValues_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetPromLabelNamesAndValues(childComplexity, args["request"].(*model.PromSeriesInput)), true

	case "Query.getPromSeriesList":
		if e.complexity.Query.GetPromSeriesList == nil {
			break
		}

		args, err := ec.field_Query_getPromSeriesList_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetPromSeriesList(childComplexity, args["request"].(*model.DsDetails)), true

	case "Query.getPrometheusData":
		if e.complexity.Query.GetPrometheusData == nil {
			break
		}

		args, err := ec.field_Query_getPrometheusData_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetPrometheusData(childComplexity, args["request"].(*model.PrometheusDataRequest)), true

	case "Query.getServerVersion":
		if e.complexity.Query.GetServerVersion == nil {
			break
		}

		return e.complexity.Query.GetServerVersion(childComplexity), true

	case "Query.getUsageData":
		if e.complexity.Query.GetUsageData == nil {
			break
		}

		args, err := ec.field_Query_getUsageData_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUsageData(childComplexity, args["request"].(model.UsageDataRequest)), true

	case "Query.getWorkflowManifestByID":
		if e.complexity.Query.GetWorkflowManifestByID == nil {
			break
		}

		args, err := ec.field_Query_getWorkflowManifestByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetWorkflowManifestByID(childComplexity, args["projectID"].(string), args["templateID"].(string)), true

	case "Query.getWorkflowRunStats":
		if e.complexity.Query.GetWorkflowRunStats == nil {
			break
		}

		args, err := ec.field_Query_getWorkflowRunStats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetWorkflowRunStats(childComplexity, args["workflowRunStatsRequest"].(model.WorkflowRunStatsRequest)), true

	case "Query.getYAMLData":
		if e.complexity.Query.GetYAMLData == nil {
			break
		}

		args, err := ec.field_Query_getYAMLData_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetYAMLData(childComplexity, args["request"].(model.ExperimentRequest)), true

	case "Query.listCharts":
		if e.complexity.Query.ListCharts == nil {
			break
		}

		args, err := ec.field_Query_listCharts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListCharts(childComplexity, args["hubName"].(string), args["projectID"].(string)), true

	case "Query.listClusters":
		if e.complexity.Query.ListClusters == nil {
			break
		}

		args, err := ec.field_Query_listClusters_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListClusters(childComplexity, args["projectID"].(string), args["clusterType"].(*string)), true

	case "Query.listDashboard":
		if e.complexity.Query.ListDashboard == nil {
			break
		}

		args, err := ec.field_Query_listDashboard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListDashboard(childComplexity, args["projectID"].(string), args["clusterID"].(*string), args["dbID"].(*string)), true

	case "Query.listDataSource":
		if e.complexity.Query.ListDataSource == nil {
			break
		}

		args, err := ec.field_Query_listDataSource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListDataSource(childComplexity, args["projectID"].(string)), true

	case "Query.listHeatmapData":
		if e.complexity.Query.ListHeatmapData == nil {
			break
		}

		args, err := ec.field_Query_listHeatmapData_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListHeatmapData(childComplexity, args["projectID"].(string), args["workflowID"].(string), args["year"].(int)), true

	case "Query.listHubStatus":
		if e.complexity.Query.ListHubStatus == nil {
			break
		}

		args, err := ec.field_Query_listHubStatus_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListHubStatus(childComplexity, args["projectID"].(string)), true

	case "Query.listImageRegistry":
		if e.complexity.Query.ListImageRegistry == nil {
			break
		}

		args, err := ec.field_Query_listImageRegistry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListImageRegistry(childComplexity, args["projectID"].(string)), true

	case "Query.listPortalDashboardData":
		if e.complexity.Query.ListPortalDashboardData == nil {
			break
		}

		args, err := ec.field_Query_listPortalDashboardData_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListPortalDashboardData(childComplexity, args["projectID"].(string), args["hubName"].(string)), true

	case "Query.listPredefinedWorkflows":
		if e.complexity.Query.ListPredefinedWorkflows == nil {
			break
		}

		args, err := ec.field_Query_listPredefinedWorkflows_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListPredefinedWorkflows(childComplexity, args["hubName"].(string), args["projectID"].(string)), true

	case "Query.listWorkflowManifests":
		if e.complexity.Query.ListWorkflowManifests == nil {
			break
		}

		args, err := ec.field_Query_listWorkflowManifests_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListWorkflowManifests(childComplexity, args["projectID"].(string)), true

	case "Query.listWorkflowRuns":
		if e.complexity.Query.ListWorkflowRuns == nil {
			break
		}

		args, err := ec.field_Query_listWorkflowRuns_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListWorkflowRuns(childComplexity, args["request"].(model.ListWorkflowRunsRequest)), true

	case "Query.listWorkflowStats":
		if e.complexity.Query.ListWorkflowStats == nil {
			break
		}

		args, err := ec.field_Query_listWorkflowStats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListWorkflowStats(childComplexity, args["projectID"].(string), args["filter"].(model.TimeFrequency), args["showWorkflowRuns"].(bool)), true

	case "Query.listWorkflows":
		if e.complexity.Query.ListWorkflows == nil {
			break
		}

		args, err := ec.field_Query_listWorkflows_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListWorkflows(childComplexity, args["request"].(model.ListWorkflowsRequest)), true

	case "RegisterClusterResponse.clusterID":
		if e.complexity.RegisterClusterResponse.ClusterID == nil {
			break
		}

		return e.complexity.RegisterClusterResponse.ClusterID(childComplexity), true

	case "RegisterClusterResponse.clusterName":
		if e.complexity.RegisterClusterResponse.ClusterName == nil {
			break
		}

		return e.complexity.RegisterClusterResponse.ClusterName(childComplexity), true

	case "RegisterClusterResponse.token":
		if e.complexity.RegisterClusterResponse.Token == nil {
			break
		}

		return e.complexity.RegisterClusterResponse.Token(childComplexity), true

	case "ResourceResponse.kind":
		if e.complexity.ResourceResponse.Kind == nil {
			break
		}

		return e.complexity.ResourceResponse.Kind(childComplexity), true

	case "ResourceResponse.names":
		if e.complexity.ResourceResponse.Names == nil {
			break
		}

		return e.complexity.ResourceResponse.Names(childComplexity), true

	case "SSHKey.privateKey":
		if e.complexity.SSHKey.PrivateKey == nil {
			break
		}

		return e.complexity.SSHKey.PrivateKey(childComplexity), true

	case "SSHKey.publicKey":
		if e.complexity.SSHKey.PublicKey == nil {
			break
		}

		return e.complexity.SSHKey.PublicKey(childComplexity), true

	case "ServerVersionResponse.key":
		if e.complexity.ServerVersionResponse.Key == nil {
			break
		}

		return e.complexity.ServerVersionResponse.Key(childComplexity), true

	case "ServerVersionResponse.value":
		if e.complexity.ServerVersionResponse.Value == nil {
			break
		}

		return e.complexity.ServerVersionResponse.Value(childComplexity), true

	case "Spec.categoryDescription":
		if e.complexity.Spec.CategoryDescription == nil {
			break
		}

		return e.complexity.Spec.CategoryDescription(childComplexity), true

	case "Spec.chaosExpCRDLink":
		if e.complexity.Spec.ChaosExpCRDLink == nil {
			break
		}

		return e.complexity.Spec.ChaosExpCRDLink(childComplexity), true

	case "Spec.chaosType":
		if e.complexity.Spec.ChaosType == nil {
			break
		}

		return e.complexity.Spec.ChaosType(childComplexity), true

	case "Spec.displayName":
		if e.complexity.Spec.DisplayName == nil {
			break
		}

		return e.complexity.Spec.DisplayName(childComplexity), true

	case "Spec.experiments":
		if e.complexity.Spec.Experiments == nil {
			break
		}

		return e.complexity.Spec.Experiments(childComplexity), true

	case "Spec.keywords":
		if e.complexity.Spec.Keywords == nil {
			break
		}

		return e.complexity.Spec.Keywords(childComplexity), true

	case "Spec.links":
		if e.complexity.Spec.Links == nil {
			break
		}

		return e.complexity.Spec.Links(childComplexity), true

	case "Spec.maintainers":
		if e.complexity.Spec.Maintainers == nil {
			break
		}

		return e.complexity.Spec.Maintainers(childComplexity), true

	case "Spec.maturity":
		if e.complexity.Spec.Maturity == nil {
			break
		}

		return e.complexity.Spec.Maturity(childComplexity), true

	case "Spec.minKubeVersion":
		if e.complexity.Spec.MinKubeVersion == nil {
			break
		}

		return e.complexity.Spec.MinKubeVersion(childComplexity), true

	case "Spec.platforms":
		if e.complexity.Spec.Platforms == nil {
			break
		}

		return e.complexity.Spec.Platforms(childComplexity), true

	case "Spec.provider":
		if e.complexity.Spec.Provider == nil {
			break
		}

		return e.complexity.Spec.Provider(childComplexity), true

	case "SubData.date":
		if e.complexity.SubData.Date == nil {
			break
		}

		return e.complexity.SubData.Date(childComplexity), true

	case "SubData.subDataName":
		if e.complexity.SubData.SubDataName == nil {
			break
		}

		return e.complexity.SubData.SubDataName(childComplexity), true

	case "SubData.value":
		if e.complexity.SubData.Value == nil {
			break
		}

		return e.complexity.SubData.Value(childComplexity), true

	case "Subscription.clusterConnect":
		if e.complexity.Subscription.ClusterConnect == nil {
			break
		}

		args, err := ec.field_Subscription_clusterConnect_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ClusterConnect(childComplexity, args["clusterInfo"].(model.ClusterIdentity)), true

	case "Subscription.getClusterEvents":
		if e.complexity.Subscription.GetClusterEvents == nil {
			break
		}

		args, err := ec.field_Subscription_getClusterEvents_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.GetClusterEvents(childComplexity, args["projectID"].(string)), true

	case "Subscription.getKubeObject":
		if e.complexity.Subscription.GetKubeObject == nil {
			break
		}

		args, err := ec.field_Subscription_getKubeObject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.GetKubeObject(childComplexity, args["request"].(model.KubeObjectRequest)), true

	case "Subscription.getPodLog":
		if e.complexity.Subscription.GetPodLog == nil {
			break
		}

		args, err := ec.field_Subscription_getPodLog_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.GetPodLog(childComplexity, args["request"].(model.PodLogRequest)), true

	case "Subscription.getWorkflowEvents":
		if e.complexity.Subscription.GetWorkflowEvents == nil {
			break
		}

		args, err := ec.field_Subscription_getWorkflowEvents_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.GetWorkflowEvents(childComplexity, args["projectID"].(string)), true

	case "Subscription.viewDashboard":
		if e.complexity.Subscription.ViewDashboard == nil {
			break
		}

		args, err := ec.field_Subscription_viewDashboard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ViewDashboard(childComplexity, args["dashboardID"].(*string), args["promQueries"].([]*model.PromQueryInput), args["dashboardQueryMap"].([]*model.QueryMapForPanelGroup), args["dataVariables"].(model.DataVars)), true

	case "TotalCount.agents":
		if e.complexity.TotalCount.Agents == nil {
			break
		}

		return e.complexity.TotalCount.Agents(childComplexity), true

	case "TotalCount.projects":
		if e.complexity.TotalCount.Projects == nil {
			break
		}

		return e.complexity.TotalCount.Projects(childComplexity), true

	case "TotalCount.users":
		if e.complexity.TotalCount.Users == nil {
			break
		}

		return e.complexity.TotalCount.Users(childComplexity), true

	case "TotalCount.workflows":
		if e.complexity.TotalCount.Workflows == nil {
			break
		}

		return e.complexity.TotalCount.Workflows(childComplexity), true

	case "UsageDataResponse.projects":
		if e.complexity.UsageDataResponse.Projects == nil {
			break
		}

		return e.complexity.UsageDataResponse.Projects(childComplexity), true

	case "UsageDataResponse.totalCount":
		if e.complexity.UsageDataResponse.TotalCount == nil {
			break
		}

		return e.complexity.UsageDataResponse.TotalCount(childComplexity), true

	case "UsageDataResponse.totalEntries":
		if e.complexity.UsageDataResponse.TotalEntries == nil {
			break
		}

		return e.complexity.UsageDataResponse.TotalEntries(childComplexity), true

	case "Weightages.experimentName":
		if e.complexity.Weightages.ExperimentName == nil {
			break
		}

		return e.complexity.Weightages.ExperimentName(childComplexity), true

	case "Weightages.weightage":
		if e.complexity.Weightages.Weightage == nil {
			break
		}

		return e.complexity.Weightages.Weightage(childComplexity), true

	case "Workflow.clusterID":
		if e.complexity.Workflow.ClusterID == nil {
			break
		}

		return e.complexity.Workflow.ClusterID(childComplexity), true

	case "Workflow.clusterName":
		if e.complexity.Workflow.ClusterName == nil {
			break
		}

		return e.complexity.Workflow.ClusterName(childComplexity), true

	case "Workflow.clusterType":
		if e.complexity.Workflow.ClusterType == nil {
			break
		}

		return e.complexity.Workflow.ClusterType(childComplexity), true

	case "Workflow.createdAt":
		if e.complexity.Workflow.CreatedAt == nil {
			break
		}

		return e.complexity.Workflow.CreatedAt(childComplexity), true

	case "Workflow.cronSyntax":
		if e.complexity.Workflow.CronSyntax == nil {
			break
		}

		return e.complexity.Workflow.CronSyntax(childComplexity), true

	case "Workflow.isCustomWorkflow":
		if e.complexity.Workflow.IsCustomWorkflow == nil {
			break
		}

		return e.complexity.Workflow.IsCustomWorkflow(childComplexity), true

	case "Workflow.isRemoved":
		if e.complexity.Workflow.IsRemoved == nil {
			break
		}

		return e.complexity.Workflow.IsRemoved(childComplexity), true

	case "Workflow.lastUpdatedBy":
		if e.complexity.Workflow.LastUpdatedBy == nil {
			break
		}

		return e.complexity.Workflow.LastUpdatedBy(childComplexity), true

	case "Workflow.projectID":
		if e.complexity.Workflow.ProjectID == nil {
			break
		}

		return e.complexity.Workflow.ProjectID(childComplexity), true

	case "Workflow.updatedAt":
		if e.complexity.Workflow.UpdatedAt == nil {
			break
		}

		return e.complexity.Workflow.UpdatedAt(childComplexity), true

	case "Workflow.weightages":
		if e.complexity.Workflow.Weightages == nil {
			break
		}

		return e.complexity.Workflow.Weightages(childComplexity), true

	case "Workflow.workflowDescription":
		if e.complexity.Workflow.WorkflowDescription == nil {
			break
		}

		return e.complexity.Workflow.WorkflowDescription(childComplexity), true

	case "Workflow.workflowID":
		if e.complexity.Workflow.WorkflowID == nil {
			break
		}

		return e.complexity.Workflow.WorkflowID(childComplexity), true

	case "Workflow.workflowManifest":
		if e.complexity.Workflow.WorkflowManifest == nil {
			break
		}

		return e.complexity.Workflow.WorkflowManifest(childComplexity), true

	case "Workflow.workflowName":
		if e.complexity.Workflow.WorkflowName == nil {
			break
		}

		return e.complexity.Workflow.WorkflowName(childComplexity), true

	case "WorkflowRun.clusterID":
		if e.complexity.WorkflowRun.ClusterID == nil {
			break
		}

		return e.complexity.WorkflowRun.ClusterID(childComplexity), true

	case "WorkflowRun.clusterName":
		if e.complexity.WorkflowRun.ClusterName == nil {
			break
		}

		return e.complexity.WorkflowRun.ClusterName(childComplexity), true

	case "WorkflowRun.clusterType":
		if e.complexity.WorkflowRun.ClusterType == nil {
			break
		}

		return e.complexity.WorkflowRun.ClusterType(childComplexity), true

	case "WorkflowRun.executedBy":
		if e.complexity.WorkflowRun.ExecutedBy == nil {
			break
		}

		return e.complexity.WorkflowRun.ExecutedBy(childComplexity), true

	case "WorkflowRun.executionData":
		if e.complexity.WorkflowRun.ExecutionData == nil {
			break
		}

		return e.complexity.WorkflowRun.ExecutionData(childComplexity), true

	case "WorkflowRun.experimentsAwaited":
		if e.complexity.WorkflowRun.ExperimentsAwaited == nil {
			break
		}

		return e.complexity.WorkflowRun.ExperimentsAwaited(childComplexity), true

	case "WorkflowRun.experimentsFailed":
		if e.complexity.WorkflowRun.ExperimentsFailed == nil {
			break
		}

		return e.complexity.WorkflowRun.ExperimentsFailed(childComplexity), true

	case "WorkflowRun.experimentsNa":
		if e.complexity.WorkflowRun.ExperimentsNa == nil {
			break
		}

		return e.complexity.WorkflowRun.ExperimentsNa(childComplexity), true

	case "WorkflowRun.experimentsPassed":
		if e.complexity.WorkflowRun.ExperimentsPassed == nil {
			break
		}

		return e.complexity.WorkflowRun.ExperimentsPassed(childComplexity), true

	case "WorkflowRun.experimentsStopped":
		if e.complexity.WorkflowRun.ExperimentsStopped == nil {
			break
		}

		return e.complexity.WorkflowRun.ExperimentsStopped(childComplexity), true

	case "WorkflowRun.isRemoved":
		if e.complexity.WorkflowRun.IsRemoved == nil {
			break
		}

		return e.complexity.WorkflowRun.IsRemoved(childComplexity), true

	case "WorkflowRun.lastUpdated":
		if e.complexity.WorkflowRun.LastUpdated == nil {
			break
		}

		return e.complexity.WorkflowRun.LastUpdated(childComplexity), true

	case "WorkflowRun.phase":
		if e.complexity.WorkflowRun.Phase == nil {
			break
		}

		return e.complexity.WorkflowRun.Phase(childComplexity), true

	case "WorkflowRun.projectID":
		if e.complexity.WorkflowRun.ProjectID == nil {
			break
		}

		return e.complexity.WorkflowRun.ProjectID(childComplexity), true

	case "WorkflowRun.resiliencyScore":
		if e.complexity.WorkflowRun.ResiliencyScore == nil {
			break
		}

		return e.complexity.WorkflowRun.ResiliencyScore(childComplexity), true

	case "WorkflowRun.totalExperiments":
		if e.complexity.WorkflowRun.TotalExperiments == nil {
			break
		}

		return e.complexity.WorkflowRun.TotalExperiments(childComplexity), true

	case "WorkflowRun.weightages":
		if e.complexity.WorkflowRun.Weightages == nil {
			break
		}

		return e.complexity.WorkflowRun.Weightages(childComplexity), true

	case "WorkflowRun.workflowID":
		if e.complexity.WorkflowRun.WorkflowID == nil {
			break
		}

		return e.complexity.WorkflowRun.WorkflowID(childComplexity), true

	case "WorkflowRun.workflowName":
		if e.complexity.WorkflowRun.WorkflowName == nil {
			break
		}

		return e.complexity.WorkflowRun.WorkflowName(childComplexity), true

	case "WorkflowRun.workflowRunID":
		if e.complexity.WorkflowRun.WorkflowRunID == nil {
			break
		}

		return e.complexity.WorkflowRun.WorkflowRunID(childComplexity), true

	case "WorkflowRunDetails.dateStamp":
		if e.complexity.WorkflowRunDetails.DateStamp == nil {
			break
		}

		return e.complexity.WorkflowRunDetails.DateStamp(childComplexity), true

	case "WorkflowRunDetails.noOfRuns":
		if e.complexity.WorkflowRunDetails.NoOfRuns == nil {
			break
		}

		return e.complexity.WorkflowRunDetails.NoOfRuns(childComplexity), true

	case "WorkflowRunStatsResponse.averageResiliencyScore":
		if e.complexity.WorkflowRunStatsResponse.AverageResiliencyScore == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.AverageResiliencyScore(childComplexity), true

	case "WorkflowRunStatsResponse.experimentsAwaited":
		if e.complexity.WorkflowRunStatsResponse.ExperimentsAwaited == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.ExperimentsAwaited(childComplexity), true

	case "WorkflowRunStatsResponse.experimentsFailed":
		if e.complexity.WorkflowRunStatsResponse.ExperimentsFailed == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.ExperimentsFailed(childComplexity), true

	case "WorkflowRunStatsResponse.experimentsNa":
		if e.complexity.WorkflowRunStatsResponse.ExperimentsNa == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.ExperimentsNa(childComplexity), true

	case "WorkflowRunStatsResponse.experimentsPassed":
		if e.complexity.WorkflowRunStatsResponse.ExperimentsPassed == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.ExperimentsPassed(childComplexity), true

	case "WorkflowRunStatsResponse.experimentsStopped":
		if e.complexity.WorkflowRunStatsResponse.ExperimentsStopped == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.ExperimentsStopped(childComplexity), true

	case "WorkflowRunStatsResponse.failedPercentage":
		if e.complexity.WorkflowRunStatsResponse.FailedPercentage == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.FailedPercentage(childComplexity), true

	case "WorkflowRunStatsResponse.failedWorkflowRuns":
		if e.complexity.WorkflowRunStatsResponse.FailedWorkflowRuns == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.FailedWorkflowRuns(childComplexity), true

	case "WorkflowRunStatsResponse.passedPercentage":
		if e.complexity.WorkflowRunStatsResponse.PassedPercentage == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.PassedPercentage(childComplexity), true

	case "WorkflowRunStatsResponse.runningWorkflowRuns":
		if e.complexity.WorkflowRunStatsResponse.RunningWorkflowRuns == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.RunningWorkflowRuns(childComplexity), true

	case "WorkflowRunStatsResponse.succeededWorkflowRuns":
		if e.complexity.WorkflowRunStatsResponse.SucceededWorkflowRuns == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.SucceededWorkflowRuns(childComplexity), true

	case "WorkflowRunStatsResponse.totalExperiments":
		if e.complexity.WorkflowRunStatsResponse.TotalExperiments == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.TotalExperiments(childComplexity), true

	case "WorkflowRunStatsResponse.totalWorkflowRuns":
		if e.complexity.WorkflowRunStatsResponse.TotalWorkflowRuns == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.TotalWorkflowRuns(childComplexity), true

	case "WorkflowRunStatsResponse.workflowRunFailedPercentage":
		if e.complexity.WorkflowRunStatsResponse.WorkflowRunFailedPercentage == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.WorkflowRunFailedPercentage(childComplexity), true

	case "WorkflowRunStatsResponse.workflowRunSucceededPercentage":
		if e.complexity.WorkflowRunStatsResponse.WorkflowRunSucceededPercentage == nil {
			break
		}

		return e.complexity.WorkflowRunStatsResponse.WorkflowRunSucceededPercentage(childComplexity), true

	case "WorkflowRunsData.value":
		if e.complexity.WorkflowRunsData.Value == nil {
			break
		}

		return e.complexity.WorkflowRunsData.Value(childComplexity), true

	case "WorkflowRunsData.workflowRunDetail":
		if e.complexity.WorkflowRunsData.WorkflowRunDetail == nil {
			break
		}

		return e.complexity.WorkflowRunsData.WorkflowRunDetail(childComplexity), true

	case "WorkflowStat.expRuns":
		if e.complexity.WorkflowStat.ExpRuns == nil {
			break
		}

		return e.complexity.WorkflowStat.ExpRuns(childComplexity), true

	case "WorkflowStat.runs":
		if e.complexity.WorkflowStat.Runs == nil {
			break
		}

		return e.complexity.WorkflowStat.Runs(childComplexity), true

	case "WorkflowStat.schedules":
		if e.complexity.WorkflowStat.Schedules == nil {
			break
		}

		return e.complexity.WorkflowStat.Schedules(childComplexity), true

	case "WorkflowStatsResponse.date":
		if e.complexity.WorkflowStatsResponse.Date == nil {
			break
		}

		return e.complexity.WorkflowStatsResponse.Date(childComplexity), true

	case "WorkflowStatsResponse.value":
		if e.complexity.WorkflowStatsResponse.Value == nil {
			break
		}

		return e.complexity.WorkflowStatsResponse.Value(childComplexity), true

	case "WorkflowTemplate.createdAt":
		if e.complexity.WorkflowTemplate.CreatedAt == nil {
			break
		}

		return e.complexity.WorkflowTemplate.CreatedAt(childComplexity), true

	case "WorkflowTemplate.isCustomWorkflow":
		if e.complexity.WorkflowTemplate.IsCustomWorkflow == nil {
			break
		}

		return e.complexity.WorkflowTemplate.IsCustomWorkflow(childComplexity), true

	case "WorkflowTemplate.isRemoved":
		if e.complexity.WorkflowTemplate.IsRemoved == nil {
			break
		}

		return e.complexity.WorkflowTemplate.IsRemoved(childComplexity), true

	case "WorkflowTemplate.manifest":
		if e.complexity.WorkflowTemplate.Manifest == nil {
			break
		}

		return e.complexity.WorkflowTemplate.Manifest(childComplexity), true

	case "WorkflowTemplate.projectID":
		if e.complexity.WorkflowTemplate.ProjectID == nil {
			break
		}

		return e.complexity.WorkflowTemplate.ProjectID(childComplexity), true

	case "WorkflowTemplate.projectName":
		if e.complexity.WorkflowTemplate.ProjectName == nil {
			break
		}

		return e.complexity.WorkflowTemplate.ProjectName(childComplexity), true

	case "WorkflowTemplate.templateDescription":
		if e.complexity.WorkflowTemplate.TemplateDescription == nil {
			break
		}

		return e.complexity.WorkflowTemplate.TemplateDescription(childComplexity), true

	case "WorkflowTemplate.templateID":
		if e.complexity.WorkflowTemplate.TemplateID == nil {
			break
		}

		return e.complexity.WorkflowTemplate.TemplateID(childComplexity), true

	case "WorkflowTemplate.templateName":
		if e.complexity.WorkflowTemplate.TemplateName == nil {
			break
		}

		return e.complexity.WorkflowTemplate.TemplateName(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next()

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	&ast.Source{Name: "graph/analytics.graphqls", Input: `input DSInput {
  dsID: String
  dsName: String!
  dsType: String!
  dsURL: String!
  accessType: String!
  authType: String!
  basicAuthUsername: String
  basicAuthPassword: String
  scrapeInterval: Int!
  queryTimeout: Int!
  httpMethod: String!
  projectID: String
}

type DSResponse {
  dsID: String
  dsName: String
  dsType: String
  dsURL: String
  accessType: String
  authType: String
  basicAuthUsername: String
  basicAuthPassword: String
  scrapeInterval: Int
  queryTimeout: Int
  httpMethod: String
  projectID: ID!
  healthStatus: String!
  createdAt: String
  updatedAt: String
}

input CreateDBInput {
  dsID: String!
  dbName: String!
  dbTypeName: String!
  dbTypeID: String!
  dbInformation: String
  chaosEventQueryTemplate: String!
  chaosVerdictQueryTemplate: String!
  applicationMetadataMap: [ApplicationMetadata]
  panelGroups: [PanelGroup]!
  endTime: String!
  startTime: String!
  projectID: ID!
  clusterID: ID!
  refreshRate: String!
}

input ApplicationMetadata {
  namespace: String!
  applications: [Resource]
}

input Resource {
  kind: String!
  names: [String]
}

input UpdateDBInput {
  dbID: String!
  dsID: String
  dbName: String
  dbTypeName: String
  dbTypeID: String
  dbInformation: String
  chaosEventQueryTemplate: String
  chaosVerdictQueryTemplate: String
  applicationMetadataMap: [ApplicationMetadata]
  panelGroups: [UpdatePanelGroupInput]
  endTime: String
  startTime: String
  clusterID: ID
  refreshRate: String
}

input UpdatePanelGroupInput {
  panelGroupName: String!
  panelGroupID: String!
  panels: [Panel]
}

input PanelGroup {
  panels: [Panel]
  panelGroupName: String!
}

input Panel {
  panelID: String
  dbID: String
  yAxisLeft: String
  yAxisRight: String
  xAxisDown: String
  unit: String
  panelGroupID: String
  createdAt: String
  promQueries: [PromQuery]
  panelOptions: PanelOption
  panelName: String!
}

input PanelOption {
  points: Boolean
  grIDs: Boolean
  leftAxis: Boolean
}

input PromQuery {
  queryID: String!
  promQueryName: String
  legend: String
  resolution: String
  minstep: String
  line: Boolean
  closeArea: Boolean
}

input PrometheusDataRequest {
  queries: [PromQueryInput]
  dsDetails: DsDetails!
}

input PromSeriesInput {
  series: String!
  dsDetails: DsDetails!
}

input DsDetails {
  url: String!
  start: String!
  end: String!
}

input PromQueryInput {
  queryID: String!
  query: String!
  legend: String
  resolution: String
  minstep: Int!
}

input QueryMapForPanel {
  panelID: String!
  queryIDs: [String!]!
}

input QueryMapForPanelGroup {
  panelGroupID: String!
  panelQueryMap: [QueryMapForPanel!]!
}

input DataVars {
  url: String!
  start: String!
  end: String!
  relativeTime: Int!
  refreshInterval: Int!
}

type MetricsPromResponse {
  queryID: String!
  legends: [String]
  tsvs: [[MetricsTimeStampValue]]
}

type MetricsTimeStampValue {
  date: Float
  value: Float
}

type SubData {
  date: Float
  value: String!
  subDataName: String!
}

type AnnotationsPromResponse {
  queryID: String!
  legends: [String]
  tsvs: [[AnnotationsTimeStampValue]]
  subDataArray: [[SubData]]
}

type AnnotationsTimeStampValue {
  date: Float
  value: Int
}

type PrometheusDataResponse {
  metricsResponse: [MetricsPromResponse]
  annotationsResponse: [AnnotationsPromResponse]
}

type MetricDataForPanel {
  panelID: String!
  panelMetricsResponse: [MetricsPromResponse]
}

type MetricDataForPanelGroup {
  panelGroupID: String!
  panelGroupMetricsResponse: [MetricDataForPanel]
}

type DashboardPromResponse {
  dashboardMetricsResponse: [MetricDataForPanelGroup]
  annotationsResponse: [AnnotationsPromResponse]
}

type PromSeriesResponse {
  series: String!
  labelValues: [LabelValue]
}

type PromSeriesListResponse {
  seriesList: [String]
}

type LabelValue {
  label: String!
  values: [Option]
}

type Option {
  name: String!
}

type ListDashboardResponse {
  dsID: String!
  dbID: String!
  dbName: String!
  dbTypeID: String!
  dbTypeName: String!
  dbInformation: String
  chaosEventQueryTemplate: String!
  chaosVerdictQueryTemplate: String!
  applicationMetadataMap: [ApplicationMetadataResponse]
  clusterName: String
  dsName: String
  dsType: String
  dsURL: String
  dsHealthStatus: String
  panelGroups: [PanelGroupResponse]!
  endTime: String!
  startTime: String!
  refreshRate: String!
  projectID: ID!
  clusterID: ID!
  createdAt: String
  updatedAt: String
  viewedAt: String
}

type ApplicationMetadataResponse {
  namespace: String!
  applications: [ResourceResponse]
}

type ResourceResponse {
  kind: String!
  names: [String]
}

type PanelGroupResponse {
  panels: [PanelResponse]
  panelGroupName: String!
  panelGroupID: String
}

type PanelResponse {
  panelID: String!
  yAxisLeft: String
  yAxisRight: String
  xAxisDown: String
  unit: String
  promQueries: [PromQueryResponse]
  panelOptions: PanelOptionResponse
  panelName: String
  createdAt: String
}

type PanelOptionResponse {
  points: Boolean
  grIDs: Boolean
  leftAxis: Boolean
}

type PromQueryResponse {
  queryID: ID!
  promQueryName: String
  legend: String
  resolution: String
  minstep: String
  line: Boolean
  closeArea: Boolean
}

input DeleteDSInput {
  forceDelete: Boolean!
  dsID: ID!
}

enum TimeFrequency {
  DAILY
  HOURLY
  MONTHLY
}

type WorkflowStatsResponse {
  date: Float!
  value: Int!
}

type WorkflowRunDetails {
  noOfRuns: Int!
  dateStamp: Float!
}

type WorkflowRunsData {
  value: Float
  workflowRunDetail: WorkflowRunDetails
}

type HeatmapDataResponse {
  bins: [WorkflowRunsData]!
}

input WorkflowRunStatsRequest {
  projectID: ID!
  workflowIDs: [ID]
}

type WorkflowRunStatsResponse {
  totalWorkflowRuns: Int!
  succeededWorkflowRuns: Int!
  failedWorkflowRuns: Int!
  runningWorkflowRuns: Int!
  averageResiliencyScore: Float!
  totalExperiments: Int!
  experimentsPassed: Int!
  experimentsFailed: Int!
  experimentsAwaited: Int!
  experimentsStopped: Int!
  experimentsNa: Int!
  passedPercentage: Float!
  failedPercentage: Float!
  workflowRunSucceededPercentage: Float!
  workflowRunFailedPercentage: Float!
}

type PortalDashboardDataResponse {
  name: String!
  dashboardData: String!
}


extend type Mutation {
  # ANALYTICS OPERATIONS
  """
  Creates a new datasource
  """
  createDataSource(datasource: DSInput): DSResponse @authorized

  """
  Creates a new analytics dashboard
  """
  createDashBoard(dashboard: CreateDBInput): ListDashboardResponse! @authorized

  """
  Updates a datasource
  """
  updateDataSource(datasource: DSInput!): DSResponse! @authorized

  """
  Updates a dashboard
  """
  updateDashboard(
    projectID: String!
    dashboard: UpdateDBInput!
    chaosQueryUpdate: Boolean!
  ): String! @authorized

  """
  Updates a dashboard panel
  """
  updatePanel(panelInput: [Panel]): String! @authorized

  """
  Deletes a dashboard
  """
  deleteDashboard(projectID: String!, dbID: String): Boolean! @authorized

  """
  Deletes a datasource
  """
  deleteDataSource(projectID: String!, input: DeleteDSInput!): Boolean!
  @authorized
}

extend type Query {
  # ANALYTICS OPERATIONS
  """
  Returns the workflow run data for a particular workflow in heatmap bins format
  """
  listHeatmapData(
    projectID: String!
    workflowID: String!
    year: Int!
  ): [HeatmapDataResponse]! @authorized

  """
  Returns the workflow and runs data divided in time frequency (hourly/daily/monthly)
  """
  listWorkflowStats(
    projectID: ID!
    filter: TimeFrequency!
    showWorkflowRuns: Boolean!
  ): [WorkflowStatsResponse]! @authorized

  """
  Returns metadata for multiple workflowIDs
  """
  getWorkflowRunStats(
    workflowRunStatsRequest: WorkflowRunStatsRequest!
  ): WorkflowRunStatsResponse! @authorized

  """
  Returns all the data sources for the projectID
  """
  listDataSource(projectID: String!): [DSResponse]! @authorized

  """
  Takes prometheus queries and returns response for annotations and metrics with a query map
  """
  getPrometheusData(request: PrometheusDataRequest): PrometheusDataResponse!
  @authorized

  """
  Return the prometheus labels and values for a given input
  """
  getPromLabelNamesAndValues(request: PromSeriesInput): PromSeriesResponse!
  @authorized

  """
  Return a list of all the prometheus series
  """
  getPromSeriesList(request: DsDetails): PromSeriesListResponse! @authorized

  """
  Returns a list of all the dashboards given an input
  """
  listDashboard(
    projectID: String!
    clusterID: String
    dbID: String
  ): [ListDashboardResponse] @authorized

  """
  Returns the portal dashboard data from the ChaosHub
  """
  listPortalDashboardData(
    projectID: String!
    hubName: String!
  ): [PortalDashboardDataResponse!]! @authorized
}

extend type Subscription {
  # ANALYTICS OPERATIONS
  """
  Takes a dashboard view id, prometheus queries, dashboard query map
  and data variables to query prometheus and send data periodically to the subscribed client
  """
  viewDashboard(
    dashboardID: String
    promQueries: [PromQueryInput!]!
    dashboardQueryMap: [QueryMapForPanelGroup!]!
    dataVariables: DataVars!
  ): DashboardPromResponse! @authorized
}
`, BuiltIn: false},
	&ast.Source{Name: "graph/cluster.graphqls", Input: `"""
Defines the details for a cluster
"""
type Cluster {
    """
    ID of the cluster
    """
    clusterID: ID!
    """
    Project ID the cluster is being connected to
    """
    projectID: ID!
    """
    Name of the cluster
    """
    clusterName: String!
    """
    Description of the cluster
    """
    description: String
    """
    Cluster Platform Name eg. GKE,AWS, Others
    """
    platformName: String!

    accessKey: String!
    """
    Bool value indicating if the cluster agent is registered or not
    """
    isRegistered: Boolean!
    """
    Bool value indicating if the cluster agent is confirmed or not
    """
    isClusterConfirmed: Boolean!
    """
    Bool value indicating if the cluster agent is active or not
    """
    isActive: Boolean!
    """
    Timestamp when the cluster agent was last updated
    """
    updatedAt: String!
    """
    Timestamp when the cluster agent was created
    """
    createdAt: String!
    """
    Cluster type : Internal or External
    """
    clusterType: String!
    """
    Number of schedules created in the cluster agent
    """
    noOfSchedules: Int
    """
    Number of workflows run in the cluster agent
    """
    noOfWorkflows: Int
    """
    Token used to verify and retrieve the cluster agent manifest
    """
    token: String!
    """
    Namespace where the cluster agent is being installed
    """
    agentNamespace: String
    """
    Name of service account used by cluster agent
    """
    serviceAccount: String
    """
    Scope of the cluster agent : ns or cluster
    """
    agentScope: String!
    """
    Bool value indicating whether agent ns used already exists on cluster or not
    """
    agentNsExists: Boolean
    """
    Bool value indicating whether service account used already exists on cluster or not
    """
    agentSaExists: Boolean
    """
    Timestamp of the last workflow run in the cluster agent
    """
    lastWorkflowTimestamp: String!
    """
    Timestamp when the cluster agent got connected
    """
    startTime: String!
    """
    Version of the cluster agent
    """
    version: String!
}

"""
Defines the details for the new cluster being connected
"""
input RegisterClusterRequest {
    """
    Name of the cluster
    """
    clusterName: String!
    """
    Description of the cluster
    """
    description: String
    """
    Cluster Platform Name eg. GKE,AWS, Others
    """
    platformName: String!
    """
    Project ID the cluster is being connected to
    """
    projectID: ID!
    """
    Cluster type : Internal or External
    """
    clusterType: String!
    """
    Namespace where the cluster agent is being installed
    """
    agentNamespace: String
    """
    Name of service account used by cluster agent
    """
    serviceAccount: String
    """
    Scope of the cluster agent : ns or cluster
    """
    agentScope: String!
    """
    Bool value indicating whether agent ns used already exists on cluster or not
    """
    agentNsExists: Boolean
    """
    Bool value indicating whether service account used already exists on cluster or not
    """
    agentSaExists: Boolean
    """
    Bool value indicating whether agent will skip ssl checks or not
    """
    skipSsl: Boolean
    """
    Node selectors used by cluster agent
    """
    nodeSelector: String
    """
    Node tolerations used by cluster agent
    """
    tolerations: [Toleration]
}

input Toleration {
    tolerationSeconds: Int
    key: String
    operator: String
    effect: String
    value: String
}

type ClusterEventResponse {
    eventID: ID!
    eventType: String!
    eventName: String!
    description: String!
    cluster: Cluster!
}

type ActionPayload {
    requestType: String!
    k8sManifest: String!
    namespace: String!
    externalData: String
    username: String
}

type ClusterActionResponse {
    projectID: ID!
    action: ActionPayload!
}

input NewClusterEventRequest {
    eventName: String!
    description: String!
    clusterID: String!
    accessKey: String!
}

input ClusterIdentity {
    clusterID: String!
    accessKey: String!
    version: String!
}

type ConfirmClusterRegistrationResponse {
    isClusterConfirmed: Boolean!
    newAccessKey: String
    clusterID: String
}

"""
Response received for registering a new cluster
"""
type RegisterClusterResponse {

    """
    Token used to verify and retrieve the cluster agent manifest
    """
    token: String!
    """
    Unique ID for the newly registered cluster
    """
    clusterID: String!
    """
    Cluster name as sent in request
    """
    clusterName: String!
}

type ServerVersionResponse {
    key: String!
    value: String!
}

extend type Query {
    """
    Returns version of gql server
    """
    getServerVersion: ServerVersionResponse!
    # CLUSTER OPERATIONS
    """
    Returns clusters with a particular cluster type in the project
    """
    listClusters(projectID: String!, clusterType: String): [Cluster!]! @authorized

    """
    Query to fetch agent details based on projectID and agentName
    """
    getAgentDetails(clusterID: String!, projectID: String!): Cluster! @authorized

    # MANIFEST OPERATIONS
    """
    Returns the manifest given projectID, clusterID and accessKey
    """
    getManifest(
        projectID: String!
        clusterID: String!
        accessKey: String!
    ): String! @authorized
}

extend type Mutation {
    # CLUSTER OPERATIONS
    """
    Registers a new cluster for a user in a specified project
    """
    registerCluster(request: RegisterClusterRequest!): RegisterClusterResponse!
    @authorized

    """
    Confirms the subscriber's registration with the control plane
    """
    # authorized directive not required
    confirmClusterRegistration(
        request: ClusterIdentity!
    ): ConfirmClusterRegistrationResponse!

    """
    Sends cluster related events to the subscriber
    """
    # authorized directive not required
    newClusterEvent(request: NewClusterEventRequest!): String!

    """
    Disconnects a cluster/agent and deletes its agent configuration from the control plane
    """
    deleteClusters(projectID: String!, clusterIDs: [String]!): String! @authorized

    """
    Receives pod logs for experiments from agent
    """
    # authorized directive not required
    podLog(request: PodLog!): String!

    """
    Receives kubernetes object data from subscriber
    """
    # authorized directive not required
    kubeObj(request: KubeObjectData!): String!
}

extend type Subscription {
    # CLUSTER OPERATIONS
    """
    Listens cluster events from the graphql server
    """
    getClusterEvents(projectID: String!): ClusterEventResponse! @authorized

    """
    Listens cluster operation request from the graphql server
    """
    # authorized directive not required
    clusterConnect(clusterInfo: ClusterIdentity!): ClusterActionResponse!

    """
    Returns experiment logs from the pods
    """
    getPodLog(request: PodLogRequest!): PodLogResponse! @authorized

    # K8S OPERATIONS
    """
    Returns a kubernetes object given an input
    """
    getKubeObject(request: KubeObjectRequest!): KubeObjectResponse!
    @authorized
}`, BuiltIn: false},
	&ast.Source{Name: "graph/gitops.graphqls", Input: `
"""
Defines the SSHKey details
"""
type SSHKey {
    """
    Public SSH key authenticating into git repository
    """
    publicKey: String!
    """
    Private SSH key authenticating into git repository
    """
    privateKey: String!
}

"""
Details of setting a Git repository
"""
input GitConfig {
    """
    ID of the project where GitOps is configured
    """
    projectID: String!
    """
    Git branch where the chaos charts will be pushed and synced
    """
    branch: String!
    """
    URL of the Git repository
    """
    repoURL: String!
    """
    Type of authentication used: 	BASIC, SSH,	TOKEN
    """
    authType: AuthType!
    """
    Token used for private repository
    """
    token: String
    """
    Git username
    """
    userName: String
    """
    Git password
    """
    password: String
    """
    Private SSH key authenticating into git repository
    """
    sshPrivateKey: String
}

"""
Response received after configuring GitOps
"""
type GitConfigResponse {
    """
    Bool value indicating whether GitOps is enabled or not
    """
    enabled: Boolean!
    """
    ID of the project where GitOps is configured
    """
    projectID: String!
    """
    Git branch where the chaos charts will be pushed and synced
    """
    branch: String
    """
    URL of the Git repository
    """
    repoURL: String
    """
    Type of authentication used: 	BASIC, SSH,	TOKEN
    """
    authType: AuthType
    """
    Token used for private repository
    """
    token: String
    """
    Git username
    """
    userName: String
    """
    Git password
    """
    password: String
    """
    Private SSH key authenticating into git repository
    """
    sshPrivateKey: String
}

extend type Query {
    # GIT-OPS OPERATIONS
    """
    Returns the git configuration for gitops
    """
    getGitOpsDetails(projectID: String!): GitConfigResponse! @authorized
}

extend type Mutation {
    # GIT-OPS OPERATIONS
    """
    Sends workflow run request(single run workflow only) to agent on gitops notification
    """
    # authorized directive not required
    gitopsNotifier(clusterInfo: ClusterIdentity!, workflowID: String!): String!

    """
    Enables gitops settings in the project
    """
    enableGitOps(config: GitConfig!): Boolean! @authorized

    """
    Disables gitops settings in the project
    """
    disableGitOps(projectID: String!): Boolean! @authorized

    """
    Updates gitops settings in the project
    """
    updateGitOps(config: GitConfig!): Boolean! @authorized
}`, BuiltIn: false},
	&ast.Source{Name: "graph/image_registry.graphqls", Input: `"""
Defines details for image registry
"""
type ImageRegistry {
  """
  Bool value indicating if the image registry is default or not; by default workflow uses LitmusChaos registry
  """
  isDefault: Boolean
  """
  Name of Image Registry
  """
  imageRegistryName: String!
  """
  Name of image repository
  """
  imageRepoName: String!
  """
  Type of the image registry: public/private
  """
  imageRegistryType: String!
  """
  Secret which is used for private registry
  """
  secretName: String
  """
  Namespace where the secret is available
  """
  secretNamespace: String
  """
  Bool value indicating if image registry is enabled or not
  """
  enableRegistry: Boolean
}

"""
Defines input data for querying the details of an image registry
"""
input ImageRegistryInput {
  """
  Bool value indicating if the image registry is default or not; by default workflow uses LitmusChaos registry
  """
  isDefault: Boolean!
  """
  Name of Image Registry
  """
  imageRegistryName: String!
  """
  Name of image repository
  """
  imageRepoName: String!
  """
  Type of the image registry: public/private
  """
  imageRegistryType: String!
  """
  Secret which is used for private registry
  """
  secretName: String
  """
  Namespace where the secret is available
  """
  secretNamespace: String
  """
  Bool value indicating if image registry is enabled or not
  """
  enableRegistry: Boolean
}

"""
Defines response data for image registry
"""
type ImageRegistryResponse {
  """
  Bool value indicating if the image registry is default or not; by default workflow uses LitmusChaos registry
  """
  isDefault: Boolean!
  """
  Information Image Registry
  """
  imageRegistryInfo: ImageRegistry
  """
  ID of the image registry
  """
  imageRegistryID: String!
  """
  ID of the project in which image registry is created
  """
  projectID: String!
  """
  Timestamp when the image registry was last updated
  """
  updatedAt: String
  """
  Timestamp when the image registry was created
  """
  createdAt: String
  """
  Bool value indicating if the image registry has been removed
  """
  isRemoved: Boolean
}

extend type Query {
  # IMAGE REGISTRY OPERATIONS
  listImageRegistry(projectID: String!): [ImageRegistryResponse!] @authorized

  getImageRegistry(
    imageRegistryID: String!
    projectID: String!
  ): ImageRegistryResponse! @authorized
}

extend type Mutation {
  # IMAGE REGISTRY OPERATIONS
  """
  Create an Image Registry configuration
  """
  createImageRegistry(
    projectID: String!
    imageRegistryInfo: ImageRegistryInput!
  ): ImageRegistryResponse! @authorized

  """
  Update the Image Registry configuration
  """
  updateImageRegistry(
    imageRegistryID: String!
    projectID: String!
    imageRegistryInfo: ImageRegistryInput!
  ): ImageRegistryResponse! @authorized

  """
  Delete the Image Registry
  """
  deleteImageRegistry(imageRegistryID: String!, projectID: String!): String!
  @authorized
}`, BuiltIn: false},
	&ast.Source{Name: "graph/k8s.graphqls", Input: `
"""
Response received for querying Kubernetes Object
"""
type KubeObjectResponse {
    """
    ID of the cluster in which the Kubernetes object is present
    """
    clusterID: ID!
    """
    Type of the Kubernetes object
    """
    kubeObj: String!
}

"""
Defines the details of Kubernetes object
"""
input KubeObjectData {
    """
    Unique request ID for fetching Kubernetes object details
    """
    requestID: ID!
    """
    ID of the cluster in which the Kubernetes object is present
    """
    clusterID: ClusterIdentity!
    """
    Type of the Kubernetes object
    """
    kubeObj: String!
}

"""
Defines details for fetching Kubernetes object data
"""
input KubeObjectRequest {
    """
    ID of the cluster in which the Kubernetes object is present
    """
    clusterID: ID!
    """
    Type of the Kubernetes object to be fetched
    """
    objectType: String!
    kubeObjRequest: KubeGVRRequest!
}

input KubeGVRRequest {
    group: String!
    version: String!
    resource: String!
}
`, BuiltIn: false},
	&ast.Source{Name: "graph/myhub.graphqls", Input: `enum AuthType {
  BASIC
  NONE
  SSH
  TOKEN
}

enum FileType {
  EXPERIMENT
  ENGINE
  WORKFLOW
  CSV
}

enum HubType {
  GIT
  REMOTE
}

type ChaosHub {
  """
  ID of the chaos hub
  """
  id: ID!
  """
  URL of the git repository
  """
  repoURL: String!
  """
  Branch of the git repository
  """
  repoBranch: String!
  """
  ID of the project in which the chaos hub is present
  """
  projectID: String!
  """
  Name of the chaos hub
  """
  hubName: String!
  """
  Type of ChaosHub
  """
  hubType: HubType!
  """
  Bool value indicating whether the hub is private or not.
  """
  isPrivate: Boolean!
  # Auth Types-
  #  token: Token based authentication
  #  basic: Username/Password based authentication
  #  ssh: SSH based authentication
  """
  Type of authentication used: 	BASIC, SSH,	TOKEN
  """
  authType: AuthType!
  """
  Token for authentication of private chaos hub
  """
  token: String
  """
  Git username
  """
  userName: String
  """
  Git password
  """
  password: String
  """
  Private SSH key for authenticating into private chaos hub
  """
  sshPrivateKey: String
  """
  Bool value indicating if the chaos hub is removed
  """
  isRemoved: Boolean!
  """
  Timestamp when the chaos hub was created
  """
  createdAt: String!
  """
  Timestamp when the chaos hub was last updated
  """
  updatedAt: String!
  """
  Timestamp when the chaos hub was last synced
  """
  lastSyncedAt: String!
}

#type Charts {
#	charts: [Chart!]!
#}

type Chart {
  apiVersion: String!
  kind: String!
  metadata: Metadata!
  spec: Spec!
  packageInfo: PackageInformation!
}

"""
Defines the details of the maintainer
"""
type Maintainer {
  """
  Name of the maintainer
  """
  name: String!
  """
  Email of the maintainer
  """
  email: String!
}

type Link {
  name: String!
  url: String!
}

type Metadata {
  name: String!
  version: String!
  annotations: Annotation!
}

type Annotation {
  categories: String!
  vendor: String!
  createdAt: String!
  repository: String!
  support: String!
  chartDescription: String!
}

type Spec {
  displayName: String!
  categoryDescription: String!
  keywords: [String!]!
  maturity: String!
  maintainers: [Maintainer!]!
  minKubeVersion: String!
  provider: Provider!
  links: [Link!]!
  experiments: [String!]!
  chaosExpCRDLink: String!
  platforms: [String!]!
  chaosType: String
}

type Provider {
	name: String!
}

type PackageInformation {
  packageName: String!
  experiments: [Experiments!]!
}

type Experiments {
  name: String!
  CSV: String!
  desc: String!
}

type ChaosHubStatus {
  """
  ID of the hub
  """
  id: ID!
  """
  URL of the git repository
  """
  repoURL: String!
  """
  Branch of the git repository
  """
  repoBranch: String!
  """
  Bool value indicating whether the hub is available or not.
  """
  isAvailable: Boolean!
  """
  Total number of experiments in the hub
  """
  totalExp: String!
  """
  Name of the chaos hub
  """
  hubName: String!
  """
  Type of ChaosHub
  """
  hubType: HubType!
  """
  Bool value indicating whether the hub is private or not.
  """
  isPrivate: Boolean!
  # Auth Types-
  #  token: Token based authentication
  #  basic: Username/Password based authentication
  #  ssh: SSH based authentication
  """
  Type of authentication used: 	BASIC, SSH,	TOKEN
  """
  authType: AuthType!
  """
  Token for authentication of private chaos hub
  """
  token: String
  """
  Git username
  """
  userName: String
  """
  Git password
  """
  password: String
  """
  Bool value indicating whether the hub is private or not.
  """
  isRemoved: Boolean!
  """
  Private SSH key for authenticating into private chaos hub
  """
  sshPrivateKey: String
  """
  Public SSH key for authenticating into private chaos hub
  """
  sshPublicKey: String
  """
  Timestamp when the chaos hub was last synced
  """
  lastSyncedAt: String!
}

"""
Defines the details required for creating a chaos hub
"""
input CreateChaosHubRequest {
  """
  Name of the chaos hub
  """
  hubName: String!
  """
  URL of the git repository
  """
  repoURL: String!
  """
  Branch of the git repository
  """
  repoBranch: String!
  """
  Bool value indicating whether the hub is private or not.
  """
  isPrivate: Boolean!
  # Auth Types-
  #  token: Token based authentication
  #  basic: Username/Password based authentication
  #  ssh: SSH based authentication
  """
  Type of authentication used: 	BASIC, SSH,	TOKEN
  """
  authType: AuthType!
  """
  Token for authentication of private chaos hub
  """
  token: String
  """
  Git username
  """
  userName: String
  """
  Git password
  """
  password: String
  """
  Private SSH key for authenticating into private chaos hub
  """
  sshPrivateKey: String
  """
  Public SSH key for authenticating into private chaos hub
  """
  sshPublicKey: String
  """
  Project ID associated with this chaos hub
  """
  projectID: String!
}

input ExperimentRequest {
  """
  ID of the project
  """
  projectID: String!
  """
  Name of the chart being used
  """
  chartName: String!
  """
  Name of the experiment
  """
  experimentName: String!
  """
  Name of the hub
  """
  hubName: String!
  """
  Type of thr file for workflow: chaosEngine/ experimentInput
  """
  fileType: String
}

input CloningInput {
  """
  Name of the chaos hub
  """
  hubName: String!
  """
  ID of the project
  """
  projectID: String!
  """
  Branch of the git repository
  """
  repoBranch: String!
  """
  URL of the git repository
  """
  repoURL: String!
  """
  Bool value indicating whether the hub is private or not.
  """
  isPrivate: Boolean!
  # Auth Types-
  #  token: Token based authentication
  #  basic: Username/Password based authentication
  #  ssh: SSH based authentication
  """
  Type of authentication used: 	BASIC, SSH,	TOKEN
  """
  authType: AuthType!
  """
  Token for authentication of private chaos hub
  """
  token: String
  """
  Git username
  """
  userName: String
  """
  Git password
  """
  password: String
  sshPrivateKey: String
}

input CreateRemoteMyHub {
  """
  Name of the chaos hub
  """
  hubName: String!
  """
  URL of the git repository
  """
  repoURL: String!
  """
  ProjectID of the ChaosHub
  """
  projectID: String!
}


input UpdateChaosHubRequest {
  """
  ID of the chaos hub
  """
  id: String!
  """
  Name of the chaos hub
  """
  hubName: String!
  """
  URL of the git repository
  """
  repoURL: String!
  """
  Branch of the git repository
  """
  repoBranch: String!
  """
  Bool value indicating whether the hub is private or not.
  """
  isPrivate: Boolean!
  """
  Type of authentication used: 	BASIC, SSH,	TOKEN
  """
  authType: AuthType!
  """
  Token for authentication of private chaos hub
  """
  token: String
  """
  Git username
  """
  userName: String
  """
  Git password
  """
  password: String
  """
  Private SSH key for authenticating into private chaos hub
  """
  sshPrivateKey: String
  """
  Public SSH key for authenticating into private chaos hub
  """
  sshPublicKey: String
  """
  Project ID associated with this chaos hub
  """
  projectID: String!
}

type ExperimentDetails{
  """
  Engine Manifest
  """
  engineDetails: String!

  """
  Experiment Manifest
  """
  experimentDetails: String!
}

type PredefinedWorkflowList {
  """
  Name of the workflow
  """
  workflowName: String!
  """
  Workflow CSV
  """
  workflowCSV: String!
  """
  Workflow Manifest
  """
  workflowManifest: String!
}

extend type Query {
  # CHAOS-HUB OPERATIONS
  """
  List the Charts details of a ChaosHub
  """
  listCharts(hubName: String!, projectID: String!): [Chart!]! @authorized

  """
  Get the Experiment list from a ChaosHub
  """
  getHubExperiment(request: ExperimentRequest!): Chart! @authorized

  """
  List the status of all the connected ChaosHub
  """
  listHubStatus(projectID: String!): [ChaosHubStatus]! @authorized

  """
  Get the YAML manifest of ChaosEngine/ChaosExperiment
  """
  getYAMLData(request: ExperimentRequest!): String! @authorized

  """
  Get Engine and Experiment YAML
  """
  getExperimentDetails(request: ExperimentRequest!): ExperimentDetails! @authorized

  """
  List the PredefinedWorkflows present in the hub
  """
  listPredefinedWorkflows(hubName: String!, projectID: String!): [PredefinedWorkflowList!]! @authorized

  """
  Get the predefined workflow YAML
  """
  getPredefinedExperimentYAML(request: ExperimentRequest!): String! @authorized
}

extend type Mutation {
  # CHAOS-HUB OPERATIONS
  """
  Add a ChaosHub (includes the git clone operation)
  """
  addChaosHub(request: CreateChaosHubRequest!): ChaosHub! @authorized

  """
  Add a ChaosHub (remote hub download)
  """
  addRemoteChaosHub(request: CreateRemoteMyHub!): ChaosHub! @authorized

  """
  Save a ChaosHub configuration without cloning it
  """
  saveChaosHub(request: CreateChaosHubRequest!): ChaosHub! @authorized

  """
  Sync changes from the Git repository of a ChaosHub
  """
  syncChaosHub(id: ID!, projectID: String!): String! @authorized

  """
  Generates Private and Public key for SSH authentication
  """
  generateSSHKey: SSHKey! @authorized

  """
  Update the configuration of a ChaosHub
  """
  updateChaosHub(request: UpdateChaosHubRequest!): ChaosHub! @authorized

  """
  Delete the ChaosHub
  """
  deleteChaosHub(projectID: String!, hubID: String!): Boolean! @authorized
}`, BuiltIn: false},
	&ast.Source{Name: "graph/project.graphqls", Input: `enum Invitation {
  Accepted
  Pending
}

enum MemberRole {
  Owner
  Editor
  Viewer
}
`, BuiltIn: false},
	&ast.Source{Name: "graph/usage.graphqls", Input: `"""
Defines details of workflow statistics
"""
type WorkflowStat {
  """
  Number of schedules
  """
  schedules: Int!
  """
  Number of workflow runs
  """
  runs: Int!
  """
  Number of experiment runs
  """
  expRuns: Int!
}

"""
Defines details of agent statistics
"""
type AgentStat {
  """
  Number of namespaces
  """
  ns: Int!
  """
  Number of clusters
  """
  cluster: Int!
  """
  Total number of agents
  """
  total: Int!
  """
  Number of active agents
  """
  active: Int!
}

"""
Defines all the stats under a project
"""
type ProjectData {
  """
  Workflow related statistics
  """
  workflows: WorkflowStat!
  """
  Agent related statistics
  """
  agents: AgentStat!
  """
  ID of the project
  """
  projectID: String!
}

"""
Defines total number of projects, users, agents and workflows
"""
type TotalCount {
  """
  Total number of projects
  """
  projects: Int!
  """
  Total number of users
  """
  users: Int!
  """
  Total number of agents
  """
  agents: AgentStat!
  """
  Total number of workflows
  """
  workflows: WorkflowStat!
}

"""
Defines total usage data
"""
type UsageDataResponse {
  """
  Project related data
  """
  projects: [ProjectData]!
  """
  Total number of entries
  """
  totalEntries: Int!
  """
  Total number of projects, users, agents and workflows
  """
  totalCount: TotalCount!
}

enum UsageSort {
  AGENTS
  EXPERIMENT_RUNS
  OWNER
  PROJECT
  SCHEDULES
  TEAM_MEMBERS
  WORKFLOW_RUNS
}

"""
Defines details required for sorting the data for a particular field
"""
input UsageSortInput {
  """
  Field for which sorting will be done
  """
  field: UsageSort!
  """
  Bool value indicating if sorting will be done in descending order or not
  """
  descending: Boolean!
}

"""
Defines input details for querying the total usage related details
"""
input UsageDataRequest {
  """
  Pagination detail to fetch only a required number of data at a time
  """
  pagination: Pagination
  """
  Rage of dates between which the data will be fetched
  """
  dateRange: DateRange!
  """
  Sorting details to fetch the data in a sorted manner
  """
  sort: UsageSortInput
  """
  Search field to search for a particular project and fetch it's data
  """
  searchProject: String
}

extend type Query {
  # USAGE OPERATIONS
  """
  Returns the portal's usage overview
  """
  getUsageData(request: UsageDataRequest!): UsageDataResponse! @authorized
}`, BuiltIn: false},
	&ast.Source{Name: "graph/workflow.graphqls", Input: `directive @authorized on FIELD_DEFINITION

"""
Defines the details of the weightages of each chaos experiment in the workflow
"""
input WeightagesInput {
  """
  Name of the experiment
  """
  experimentName: String!
  """
  Weightage of the experiment
  """
  weightage: Int!
}

"""
Defines the details for a chaos workflow
"""
input ChaosWorkFlowRequest {
  """
  ID of the workflow
  """
  workflowID: String
  """
  Manifest of the workflow
  """
  workflowManifest: String!
  """
  Cron syntax of the workflow schedule
  """
  cronSyntax: String!
  """
  Name of the workflow
  """
  workflowName: String!
  """
  Description of the workflow
  """
  workflowDescription: String!
  """
  Array containing weightage and name of each chaos experiment in the workflow
  """
  weightages: [WeightagesInput!]!
  """
  Bool value indicating whether the workflow is a custom workflow or not
  """
  isCustomWorkflow: Boolean!
  """
  ID of the project under which the workflow is scheduled
  """
  projectID: ID!
  """
  ID of the target cluster in which the workflow will run
  """
  clusterID: ID!
}

"""
Defines the response received for querying the details of chaos workflow
"""
type ChaosWorkFlowResponse {
  """
  ID of the workflow
  """
  workflowID: String!
  """
  Cron syntax of the workflow schedule
  """
  cronSyntax: String!
  """
  Name of the workflow
  """
  workflowName: String!
  """
  Description of the workflow
  """
  workflowDescription: String!
  """
  Bool value indicating whether the workflow is a custom workflow or not
  """
  isCustomWorkflow: Boolean!
}

"""
Defines the details for a workflow run
"""
input WorkflowRunRequest {
  """
  ID of the workflow
  """
  workflowID: ID!
  """
  ID of the workflow run which is to be queried
  """
  workflowRunID: ID!
  """
  Name of the workflow
  """
  workflowName: String!
  """
  Provides audit context to workflow run i.e who ran the workflow
  """
  executedBy: String!
  """
  Stores all the workflow run details related to the nodes of DAG graph and chaos results of the experiments
  """
  executionData: String!
  """
  ID of the cluster agent in which the workflow is running
  """
  clusterID: ClusterIdentity!
  """
  Bool value indicating if the workflow run has completed
  """
  completed: Boolean!
  """
  Bool value indicating if the workflow run has removed
  """
  isRemoved: Boolean
}

"""
Defines the response received for querying querying the pod logs
"""
type PodLogResponse {
  """
  ID of the workflow run which is to be queried
  """
  workflowRunID: ID!
  """
  Name of the pod for which logs are queried
  """
  podName: String!
  """
  Type of the pod: chaosengine
  """
  podType: String!
  """
  Logs for the pod
  """
  log: String!
}

"""
Response received for querying pod logs
"""
input PodLog {
  """
  ID of the cluster
  """
  clusterID: ClusterIdentity!
  """
  Unique request ID of a particular node which is being queried
  """
  requestID: ID!
  """
  ID of a workflow run
  """
  workflowRunID: ID!
  """
  Name of the pod for which logs are required
  """
  podName: String!
  """
  Type of the pod: chaosengine
  """
  podType: String!
  """
  Logs for the pod
  """
  log: String!
}

"""
Defines the details for fetching the pod logs
"""
input PodLogRequest {
  """
  ID of the cluster
  """
  clusterID: ID!
  """
  ID of a workflow run
  """
  workflowRunID: ID!
  """
  Name of the pod for which logs are required
  """
  podName: String!
  """
  Namespace where the pod is running
  """
  podNamespace: String!
  """
  Type of the pod: chaosEngine or not pod
  """
  podType: String!
  """
  Name of the experiment pod fetched from execution data
  """
  expPod: String
  """
  Name of the runner pod fetched from execution data
  """
  runnerPod: String
  """
  Namespace where the experiment is executing
  """
  chaosNamespace: String
}

enum WorkflowRunStatus {
  All
  Failed
  Running
  Succeeded
  Terminated
}

"""
Defines the start date and end date for the filtering the data
"""
input DateRange {
  """
  Start date
  """
  startDate: String!
  """
  End date
  """
  endDate: String
}

"""
Defines input type for workflow run filter
"""
input WorkflowRunFilterInput {
  """
  Name of the workflow
  """
  workflowName: String
  """
  Name of the cluster agent
  """
  clusterName: String
  """
  Status of the workflow run
  """
  workflowStatus: WorkflowRunStatus
  """
  Date range for filtering purpose
  """
  dateRange: DateRange
}

"""
Defines data required to fetch paginated data
"""
input Pagination {
  """
  Page number for which data will be fetched
  """
  page: Int!
  """
  Number of data to be fetched
  """
  limit: Int!
}

enum WorkflowSortingField {
  NAME
  TIME
}

"""
Defines sorting options for workflow runs
"""
input WorkflowRunSortInput {
  """
  Field in which sorting will be done
  """
  field: WorkflowSortingField!
  """
  Bool value indicating whether the sorting will be done in descending order
  """
  descending: Boolean
}

"""
Defines the details for workflow runs
"""
input ListWorkflowRunsRequest {
  """
  ID of the project
  """
  projectID: ID!
  """
  Array of workflow run IDs for which details will be fetched
  """
  workflowRunIDs: [ID]
  """
  Array of workflow IDs for which details will be fetched
  """
  workflowIDs: [ID]
  """
  Details for fetching paginated data
  """
  pagination: Pagination
  """
  Details for fetching sorted data
  """
  sort: WorkflowRunSortInput
  """
  Details for fetching filtered data
  """
  filter: WorkflowRunFilterInput
}

"""
Defines the details of the weightages of each chaos experiment in the workflow
"""
type Weightages {
  """
  Name of the experiment
  """
  experimentName: String!
  """
  Weightage of the experiment
  """
  weightage: Int!
}

"""
Defines the details of a workflow run
"""
type WorkflowRun {
  """
  ID of the workflow run which is to be queried
  """
  workflowRunID: ID!
  """
  ID of the workflow
  """
  workflowID: ID!
  """
  Name of the cluster agent in which the workflow is running
  """
  clusterName: String!
  """
  Array containing weightage and name of each chaos experiment in the workflow
  """
  weightages: [Weightages!]!
  """
  Timestamp at which workflow run was last updated
  """
  lastUpdated: String!
  """
  ID of the project
  """
  projectID: ID!
  """
  ID of the target cluster in which the workflow is running
  """
  clusterID: ID!
  """
  Name of the workflow
  """
  workflowName: String!
  """
  Cluster type : Internal or External
  """
  clusterType: String
  """
  Phase of the workflow run
  """
  phase: String!
  """
  Resiliency score of the workflow
  """
  resiliencyScore: Float
  """
  Number of experiments passed
  """
  experimentsPassed: Int
  """
  Number of experiments failed
  """
  experimentsFailed: Int
  """
  Number of experiments awaited
  """
  experimentsAwaited: Int
  """
  Number of experiments stopped
  """
  experimentsStopped: Int
  """
  Number of experiments which are not available
  """
  experimentsNa: Int
  """
  Total number of experiments
  """
  totalExperiments: Int
  """
  Stores all the workflow run details related to the nodes of DAG graph and chaos results of the experiments
  """
  executionData: String!
  """
  Bool value indicating if the workflow run has removed
  """
  isRemoved: Boolean
  """
  Provides audit context to workflow run i.e who ran the workflow
  """
  executedBy: String!
}

"""
Defines the details of a workflow to sent as response
"""
type ListWorkflowRunsResponse {
  """
  Total number of workflow runs
  """
  totalNoOfWorkflowRuns: Int!
  """
  Defines details of workflow runs
  """
  workflowRuns: [WorkflowRun]!
}

"""
Defines filter options for workflows
"""
input WorkflowFilterInput {
  """
  Name of the workflow
  """
  workflowName: String
  """
  Name of the cluster agent in which the workflow is running
  """
  clusterName: String
}

"""
Defines the details for a workflow
"""
input ListWorkflowsRequest {
  """
  ID of the project
  """
  projectID: ID!
  """
  Array of workflow IDs for which details will be fetched
  """
  workflowIDs: [ID]
  """
  Details for fetching paginated data
  """
  pagination: Pagination
  """
  Details for fetching sorted data
  """
  sort: WorkflowSortInput
  """
  Details for fetching filtered data
  """
  filter: WorkflowFilterInput
}

"""
Defines sorting options for workflow
"""
input WorkflowSortInput {
  """
  Field in which sorting will be done
  """
  field: WorkflowSortingField!
  """
  Bool value indicating whether the sorting will be done in descending order
  """
  descending: Boolean
}

"""
Defines the details for a workflow
"""
type Workflow {
  """
  ID of the workflow
  """
  workflowID: String!
  """
  Manifest of the workflow
  """
  workflowManifest: String!
  """
  Cron syntax of the workflow schedule
  """
  cronSyntax: String!
  """
  Name of the target cluster in which the workflow is running
  """
  clusterName: String!
  """
  Name of the workflow
  """
  workflowName: String!
  """
  Description of the workflow
  """
  workflowDescription: String!
  """
  Array containing weightage and name of each chaos experiment in the workflow
  """
  weightages: [Weightages!]!
  """
  Bool value indicating whether the workflow is a custom workflow or not
  """
  isCustomWorkflow: Boolean!
  """
  Timestamp when the workflow was last updated
  """
  updatedAt: String!
  """
  Timestamp when the workflow was created
  """
  createdAt: String!
  """
  ID of the project under which the workflow is scheduled
  """
  projectID: ID!
  """
  ID of the target cluster in which the workflow will run
  """
  clusterID: ID!
  """
  Cluster type : Internal or External
  """
  clusterType: String!
  """
  Bool value indicating if the workflow has removed
  """
  isRemoved: Boolean!
  """
  Provides audit context to workflow i.e who ran the workflow
  """
  lastUpdatedBy: String
}

"""
Defines the details for a workflow with total workflow count
"""
type ListWorkflowsResponse {
  """
  Total number of workflows
  """
  totalNoOfWorkflows: Int!
  """
  Details related to the workflows
  """
  workflows: [Workflow]!
}

type Query {
  # WORKFLOW OPERATIONS
  """
  Returns the list of workflows in a project based on various filter parameters
  """
  listWorkflows(request: ListWorkflowsRequest!): ListWorkflowsResponse!
  @authorized

  """
  Returns the list of workflow runs in a project based on various filter parameters
  """
  listWorkflowRuns(
    request: ListWorkflowRunsRequest!
  ): ListWorkflowRunsResponse! @authorized
}

type Mutation {
  # WORKFLOW OPERATIONS
  """
  Creates a new workflow and applies its manifest
  """
  createChaosWorkFlow(request: ChaosWorkFlowRequest!): ChaosWorkFlowResponse!
  @authorized

  """
  Reruns the workflow and applies its manifest
  """
  reRunChaosWorkFlow(projectID: String!, workflowID: String!): String!
  @authorized

  """
  Updates the workflow
  """
  updateChaosWorkflow(request: ChaosWorkFlowRequest): ChaosWorkFlowResponse!
  @authorized

  """
  Removes a workflow from cluster
  """
  deleteChaosWorkflow(
    projectID: String!
    workflowID: String
    workflowRunID: String
  ): Boolean! @authorized

  """
  Removes workflow run from the cluster only
  """
  terminateChaosWorkflow(
    projectID: String!
    workflowID: String
    workflowRunID: String
  ): Boolean! @authorized

  """
  Creates a new workflow run and sends it to subscriber
  """
  # authorized directive not required
  chaosWorkflowRun(request: WorkflowRunRequest!): String!

  """
  Manually sync the status of the workflow run
  """
  syncWorkflowRun(
    projectID: String!
    workflowID: String!
    workflowRunID: String!
  ): Boolean! @authorized
}

type Subscription {
  # WORKFLOW OPERATIONS
  """
  Sends workflow events to the subscriber
  """
  getWorkflowEvents(projectID: String!): WorkflowRun! @authorized
}`, BuiltIn: false},
	&ast.Source{Name: "graph/workflow_template.graphqls", Input: `"""
Details for a workflow template
"""
type WorkflowTemplate {
    """
    ID of the template
    """
    templateID: ID!
    """
    Workflow manifest in JSON escaped string
    """
    manifest: String!
    """
    Name of the template
    """
    templateName: String!
    """
    Description of the template
    """
    templateDescription: String!
    """
    ID of the project
    """
    projectID: String!
    """
    Name of the project
    """
    projectName: String!
    """
    Time at which the manifest template was created
    """
    createdAt: String!
    """
    Bool value indicating if the workflow template has removed
    """
    isRemoved: Boolean!
    """
    Bool value indicating whether the workflow template is a custom or not
    """
    isCustomWorkflow: Boolean!
}

"""
Details for saving the template
"""
input TemplateInput {
    """
    Workflow manifest in JSON escaped format
    """
    manifest: String!
    """
    Name of the template
    """
    templateName: String!
    """
    Description of the template
    """
    templateDescription: String!
    """
    Name of the project
    """
    projectID: String!
    """
    Bool value indicating whether the workflow is a custom workflow or not
    """
    isCustomWorkflow: Boolean!
}

extend type Query {
    # WORKFLOW TEMPLATE OPERATIONS
    """
    Returns all the workflow templates for the projectID
    """
    listWorkflowManifests(projectID: String!): [WorkflowTemplate]! @authorized

    """
    Returns a single workflow templates given a projectID and a templateID
    """
    getWorkflowManifestByID(
        projectID: String!
        templateID: String!
    ): WorkflowTemplate! @authorized
}

extend type Mutation {
    # WORKFLOW TEMPLATE OPERATIONS
    """
    Creates a workflow template manifest
    """
    createWorkflowTemplate(request: TemplateInput): WorkflowTemplate! @authorized

    """
    Removes a workflow template manifest
    """
    deleteWorkflowTemplate(projectID: String!, templateID: String!): Boolean!
    @authorized
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_addChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateChaosHubRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNCreateChaosHubRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐCreateChaosHubRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_addRemoteChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateRemoteMyHub
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNCreateRemoteMyHub2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐCreateRemoteMyHub(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_chaosWorkflowRun_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.WorkflowRunRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNWorkflowRunRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_confirmClusterRegistration_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ClusterIdentity
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNClusterIdentity2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐClusterIdentity(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createChaosWorkFlow_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ChaosWorkFlowRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNChaosWorkFlowRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChaosWorkFlowRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createDashBoard_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.CreateDBInput
	if tmp, ok := rawArgs["dashboard"]; ok {
		arg0, err = ec.unmarshalOCreateDBInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐCreateDBInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["dashboard"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createDataSource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.DSInput
	if tmp, ok := rawArgs["datasource"]; ok {
		arg0, err = ec.unmarshalODSInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDSInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["datasource"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createImageRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.ImageRegistryInput
	if tmp, ok := rawArgs["imageRegistryInfo"]; ok {
		arg1, err = ec.unmarshalNImageRegistryInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐImageRegistryInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["imageRegistryInfo"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createWorkflowTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.TemplateInput
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalOTemplateInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐTemplateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["hubID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hubID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteChaosWorkflow_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["workflowID"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["workflowID"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["workflowRunID"]; ok {
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["workflowRunID"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteClusters_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 []*string
	if tmp, ok := rawArgs["clusterIDs"]; ok {
		arg1, err = ec.unmarshalNString2ᚕᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clusterIDs"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteDashboard_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["dbID"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["dbID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteDataSource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.DeleteDSInput
	if tmp, ok := rawArgs["input"]; ok {
		arg1, err = ec.unmarshalNDeleteDSInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDeleteDSInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteImageRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["imageRegistryID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["imageRegistryID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteWorkflowTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["templateID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["templateID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_disableGitOps_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_enableGitOps_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.GitConfig
	if tmp, ok := rawArgs["config"]; ok {
		arg0, err = ec.unmarshalNGitConfig2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐGitConfig(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["config"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_gitopsNotifier_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ClusterIdentity
	if tmp, ok := rawArgs["clusterInfo"]; ok {
		arg0, err = ec.unmarshalNClusterIdentity2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐClusterIdentity(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clusterInfo"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["workflowID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["workflowID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_kubeObj_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.KubeObjectData
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNKubeObjectData2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐKubeObjectData(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_newClusterEvent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.NewClusterEventRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNNewClusterEventRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐNewClusterEventRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_podLog_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.PodLog
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNPodLog2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPodLog(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_reRunChaosWorkFlow_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["workflowID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["workflowID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_registerCluster_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.RegisterClusterRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNRegisterClusterRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐRegisterClusterRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_saveChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateChaosHubRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNCreateChaosHubRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐCreateChaosHubRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_syncChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_syncWorkflowRun_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["workflowID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["workflowID"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["workflowRunID"]; ok {
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["workflowRunID"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_terminateChaosWorkflow_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["workflowID"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["workflowID"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["workflowRunID"]; ok {
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["workflowRunID"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_updateChaosHub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateChaosHubRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNUpdateChaosHubRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐUpdateChaosHubRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateChaosWorkflow_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.ChaosWorkFlowRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalOChaosWorkFlowRequest2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChaosWorkFlowRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateDashboard_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.UpdateDBInput
	if tmp, ok := rawArgs["dashboard"]; ok {
		arg1, err = ec.unmarshalNUpdateDBInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐUpdateDBInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["dashboard"] = arg1
	var arg2 bool
	if tmp, ok := rawArgs["chaosQueryUpdate"]; ok {
		arg2, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["chaosQueryUpdate"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_updateDataSource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.DSInput
	if tmp, ok := rawArgs["datasource"]; ok {
		arg0, err = ec.unmarshalNDSInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDSInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["datasource"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateGitOps_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.GitConfig
	if tmp, ok := rawArgs["config"]; ok {
		arg0, err = ec.unmarshalNGitConfig2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐGitConfig(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["config"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateImageRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["imageRegistryID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["imageRegistryID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	var arg2 model.ImageRegistryInput
	if tmp, ok := rawArgs["imageRegistryInfo"]; ok {
		arg2, err = ec.unmarshalNImageRegistryInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐImageRegistryInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["imageRegistryInfo"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_updatePanel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*model.Panel
	if tmp, ok := rawArgs["panelInput"]; ok {
		arg0, err = ec.unmarshalOPanel2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanel(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["panelInput"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getAgentDetails_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["clusterID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clusterID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getExperimentDetails_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ExperimentRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNExperimentRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐExperimentRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getGitOpsDetails_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getHubExperiment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ExperimentRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNExperimentRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐExperimentRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getImageRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["imageRegistryID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["imageRegistryID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getManifest_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["clusterID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clusterID"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["accessKey"]; ok {
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["accessKey"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_getPredefinedExperimentYAML_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ExperimentRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNExperimentRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐExperimentRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getPromLabelNamesAndValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.PromSeriesInput
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalOPromSeriesInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromSeriesInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getPromSeriesList_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.DsDetails
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalODsDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDsDetails(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getPrometheusData_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.PrometheusDataRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalOPrometheusDataRequest2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPrometheusDataRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getUsageData_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UsageDataRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNUsageDataRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐUsageDataRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getWorkflowManifestByID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["templateID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["templateID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getWorkflowRunStats_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.WorkflowRunStatsRequest
	if tmp, ok := rawArgs["workflowRunStatsRequest"]; ok {
		arg0, err = ec.unmarshalNWorkflowRunStatsRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunStatsRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["workflowRunStatsRequest"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getYAMLData_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ExperimentRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNExperimentRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐExperimentRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_listCharts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["hubName"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hubName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_listClusters_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["clusterType"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clusterType"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_listDashboard_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["clusterID"]; ok {
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clusterID"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["dbID"]; ok {
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["dbID"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_listDataSource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_listHeatmapData_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["workflowID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["workflowID"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["year"]; ok {
		arg2, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["year"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_listHubStatus_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_listImageRegistry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_listPortalDashboardData_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["hubName"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hubName"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_listPredefinedWorkflows_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["hubName"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hubName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_listWorkflowManifests_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_listWorkflowRuns_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ListWorkflowRunsRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNListWorkflowRunsRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐListWorkflowRunsRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_listWorkflowStats_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	var arg1 model.TimeFrequency
	if tmp, ok := rawArgs["filter"]; ok {
		arg1, err = ec.unmarshalNTimeFrequency2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐTimeFrequency(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg1
	var arg2 bool
	if tmp, ok := rawArgs["showWorkflowRuns"]; ok {
		arg2, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["showWorkflowRuns"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_listWorkflows_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ListWorkflowsRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNListWorkflowsRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐListWorkflowsRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_clusterConnect_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ClusterIdentity
	if tmp, ok := rawArgs["clusterInfo"]; ok {
		arg0, err = ec.unmarshalNClusterIdentity2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐClusterIdentity(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clusterInfo"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_getClusterEvents_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_getKubeObject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.KubeObjectRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNKubeObjectRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐKubeObjectRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_getPodLog_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.PodLogRequest
	if tmp, ok := rawArgs["request"]; ok {
		arg0, err = ec.unmarshalNPodLogRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPodLogRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["request"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_getWorkflowEvents_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectID"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_viewDashboard_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["dashboardID"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["dashboardID"] = arg0
	var arg1 []*model.PromQueryInput
	if tmp, ok := rawArgs["promQueries"]; ok {
		arg1, err = ec.unmarshalNPromQueryInput2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromQueryInputᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["promQueries"] = arg1
	var arg2 []*model.QueryMapForPanelGroup
	if tmp, ok := rawArgs["dashboardQueryMap"]; ok {
		arg2, err = ec.unmarshalNQueryMapForPanelGroup2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐQueryMapForPanelGroupᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["dashboardQueryMap"] = arg2
	var arg3 model.DataVars
	if tmp, ok := rawArgs["dataVariables"]; ok {
		arg3, err = ec.unmarshalNDataVars2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDataVars(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["dataVariables"] = arg3
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _ActionPayload_requestType(ctx context.Context, field graphql.CollectedField, obj *model.ActionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActionPayload_k8sManifest(ctx context.Context, field graphql.CollectedField, obj *model.ActionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.K8sManifest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActionPayload_namespace(ctx context.Context, field graphql.CollectedField, obj *model.ActionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ActionPayload_externalData(ctx context.Context, field graphql.CollectedField, obj *model.ActionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ActionPayload_username(ctx context.Context, field graphql.CollectedField, obj *model.ActionPayload) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ActionPayload",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AgentStat_ns(ctx context.Context, field graphql.CollectedField, obj *model.AgentStat) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AgentStat",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _AgentStat_cluster(ctx context.Context, field graphql.CollectedField, obj *model.AgentStat) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AgentStat",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cluster, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _AgentStat_total(ctx context.Context, field graphql.CollectedField, obj *model.AgentStat) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AgentStat",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _AgentStat_active(ctx context.Context, field graphql.CollectedField, obj *model.AgentStat) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AgentStat",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Active, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Annotation_categories(ctx context.Context, field graphql.CollectedField, obj *model.Annotation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Annotation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Categories, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Annotation_vendor(ctx context.Context, field graphql.CollectedField, obj *model.Annotation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Annotation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vendor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Annotation_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Annotation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Annotation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Annotation_repository(ctx context.Context, field graphql.CollectedField, obj *model.Annotation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Annotation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repository, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Annotation_support(ctx context.Context, field graphql.CollectedField, obj *model.Annotation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Annotation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Support, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Annotation_chartDescription(ctx context.Context, field graphql.CollectedField, obj *model.Annotation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Annotation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChartDescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AnnotationsPromResponse_queryID(ctx context.Context, field graphql.CollectedField, obj *model.AnnotationsPromResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AnnotationsPromResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AnnotationsPromResponse_legends(ctx context.Context, field graphql.CollectedField, obj *model.AnnotationsPromResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AnnotationsPromResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Legends, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AnnotationsPromResponse_tsvs(ctx context.Context, field graphql.CollectedField, obj *model.AnnotationsPromResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AnnotationsPromResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tsvs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([][]*model.AnnotationsTimeStampValue)
	fc.Result = res
	return ec.marshalOAnnotationsTimeStampValue2ᚕᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAnnotationsTimeStampValue(ctx, field.Selections, res)
}

func (ec *executionContext) _AnnotationsPromResponse_subDataArray(ctx context.Context, field graphql.CollectedField, obj *model.AnnotationsPromResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AnnotationsPromResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubDataArray, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([][]*model.SubData)
	fc.Result = res
	return ec.marshalOSubData2ᚕᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐSubData(ctx, field.Selections, res)
}

func (ec *executionContext) _AnnotationsTimeStampValue_date(ctx context.Context, field graphql.CollectedField, obj *model.AnnotationsTimeStampValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AnnotationsTimeStampValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) _AnnotationsTimeStampValue_value(ctx context.Context, field graphql.CollectedField, obj *model.AnnotationsTimeStampValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "AnnotationsTimeStampValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationMetadataResponse_namespace(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationMetadataResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ApplicationMetadataResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Namespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationMetadataResponse_applications(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationMetadataResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ApplicationMetadataResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Applications, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ResourceResponse)
	fc.Result = res
	return ec.marshalOResourceResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐResourceResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_id(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_repoURL(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_repoBranch(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoBranch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_projectID(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_hubName(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HubName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_hubType(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HubType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.HubType)
	fc.Result = res
	return ec.marshalNHubType2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐHubType(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_isPrivate(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsPrivate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_authType(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AuthType)
	fc.Result = res
	return ec.marshalNAuthType2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAuthType(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_token(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_userName(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_password(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Password, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_sshPrivateKey(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SSHPrivateKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHub_lastSyncedAt(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHub) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHub",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSyncedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_id(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_repoURL(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_repoBranch(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoBranch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_isAvailable(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAvailable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_totalExp(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalExp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_hubName(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HubName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_hubType(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HubType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.HubType)
	fc.Result = res
	return ec.marshalNHubType2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐHubType(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_isPrivate(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsPrivate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_authType(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AuthType)
	fc.Result = res
	return ec.marshalNAuthType2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAuthType(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_token(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_userName(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_password(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Password, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_sshPrivateKey(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SSHPrivateKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_sshPublicKey(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SSHPublicKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosHubStatus_lastSyncedAt(ctx context.Context, field graphql.CollectedField, obj *model.ChaosHubStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosHubStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSyncedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosWorkFlowResponse_workflowID(ctx context.Context, field graphql.CollectedField, obj *model.ChaosWorkFlowResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosWorkFlowResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosWorkFlowResponse_cronSyntax(ctx context.Context, field graphql.CollectedField, obj *model.ChaosWorkFlowResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosWorkFlowResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CronSyntax, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosWorkFlowResponse_workflowName(ctx context.Context, field graphql.CollectedField, obj *model.ChaosWorkFlowResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosWorkFlowResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosWorkFlowResponse_workflowDescription(ctx context.Context, field graphql.CollectedField, obj *model.ChaosWorkFlowResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosWorkFlowResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowDescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ChaosWorkFlowResponse_isCustomWorkflow(ctx context.Context, field graphql.CollectedField, obj *model.ChaosWorkFlowResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ChaosWorkFlowResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsCustomWorkflow, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Chart_apiVersion(ctx context.Context, field graphql.CollectedField, obj *model.Chart) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Chart",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Chart_kind(ctx context.Context, field graphql.CollectedField, obj *model.Chart) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Chart",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Chart_metadata(ctx context.Context, field graphql.CollectedField, obj *model.Chart) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Chart",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Metadata)
	fc.Result = res
	return ec.marshalNMetadata2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Chart_spec(ctx context.Context, field graphql.CollectedField, obj *model.Chart) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Chart",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spec, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Spec)
	fc.Result = res
	return ec.marshalNSpec2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐSpec(ctx, field.Selections, res)
}

func (ec *executionContext) _Chart_packageInfo(ctx context.Context, field graphql.CollectedField, obj *model.Chart) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Chart",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PackageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PackageInformation)
	fc.Result = res
	return ec.marshalNPackageInformation2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPackageInformation(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_clusterID(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_projectID(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_clusterName(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_description(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_platformName(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlatformName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_accessKey(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccessKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_isRegistered(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRegistered, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_isClusterConfirmed(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsClusterConfirmed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_isActive(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsActive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_clusterType(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_noOfSchedules(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NoOfSchedules, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_noOfWorkflows(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NoOfWorkflows, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_token(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_agentNamespace(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentNamespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_serviceAccount(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceAccount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_agentScope(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentScope, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_agentNsExists(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentNsExists, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_agentSaExists(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentSaExists, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_lastWorkflowTimestamp(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastWorkflowTimestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_startTime(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Cluster_version(ctx context.Context, field graphql.CollectedField, obj *model.Cluster) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Cluster",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ClusterActionResponse_projectID(ctx context.Context, field graphql.CollectedField, obj *model.ClusterActionResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ClusterActionResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ClusterActionResponse_action(ctx context.Context, field graphql.CollectedField, obj *model.ClusterActionResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ClusterActionResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ActionPayload)
	fc.Result = res
	return ec.marshalNActionPayload2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐActionPayload(ctx, field.Selections, res)
}

func (ec *executionContext) _ClusterEventResponse_eventID(ctx context.Context, field graphql.CollectedField, obj *model.ClusterEventResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ClusterEventResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ClusterEventResponse_eventType(ctx context.Context, field graphql.CollectedField, obj *model.ClusterEventResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ClusterEventResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ClusterEventResponse_eventName(ctx context.Context, field graphql.CollectedField, obj *model.ClusterEventResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ClusterEventResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ClusterEventResponse_description(ctx context.Context, field graphql.CollectedField, obj *model.ClusterEventResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ClusterEventResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ClusterEventResponse_cluster(ctx context.Context, field graphql.CollectedField, obj *model.ClusterEventResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ClusterEventResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cluster, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Cluster)
	fc.Result = res
	return ec.marshalNCluster2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐCluster(ctx, field.Selections, res)
}

func (ec *executionContext) _ConfirmClusterRegistrationResponse_isClusterConfirmed(ctx context.Context, field graphql.CollectedField, obj *model.ConfirmClusterRegistrationResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ConfirmClusterRegistrationResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsClusterConfirmed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ConfirmClusterRegistrationResponse_newAccessKey(ctx context.Context, field graphql.CollectedField, obj *model.ConfirmClusterRegistrationResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ConfirmClusterRegistrationResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewAccessKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ConfirmClusterRegistrationResponse_clusterID(ctx context.Context, field graphql.CollectedField, obj *model.ConfirmClusterRegistrationResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ConfirmClusterRegistrationResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_dsID(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DsID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_dsName(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DsName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_dsType(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DsType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_dsURL(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DsURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_accessType(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccessType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_authType(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_basicAuthUsername(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BasicAuthUsername, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_basicAuthPassword(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BasicAuthPassword, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_scrapeInterval(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScrapeInterval, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_queryTimeout(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryTimeout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_httpMethod(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HTTPMethod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_projectID(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_healthStatus(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HealthStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _DSResponse_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.DSResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DSResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _DashboardPromResponse_dashboardMetricsResponse(ctx context.Context, field graphql.CollectedField, obj *model.DashboardPromResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DashboardPromResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DashboardMetricsResponse, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MetricDataForPanelGroup)
	fc.Result = res
	return ec.marshalOMetricDataForPanelGroup2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetricDataForPanelGroup(ctx, field.Selections, res)
}

func (ec *executionContext) _DashboardPromResponse_annotationsResponse(ctx context.Context, field graphql.CollectedField, obj *model.DashboardPromResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "DashboardPromResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AnnotationsResponse, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.AnnotationsPromResponse)
	fc.Result = res
	return ec.marshalOAnnotationsPromResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAnnotationsPromResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentDetails_engineDetails(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EngineDetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentDetails_experimentDetails(ctx context.Context, field graphql.CollectedField, obj *model.ExperimentDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ExperimentDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentDetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiments_name(ctx context.Context, field graphql.CollectedField, obj *model.Experiments) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiments",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiments_CSV(ctx context.Context, field graphql.CollectedField, obj *model.Experiments) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiments",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Csv, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiments_desc(ctx context.Context, field graphql.CollectedField, obj *model.Experiments) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Experiments",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_enabled(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_projectID(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_branch(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Branch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_repoURL(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_authType(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AuthType)
	fc.Result = res
	return ec.marshalOAuthType2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAuthType(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_token(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_userName(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_password(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Password, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _GitConfigResponse_sshPrivateKey(ctx context.Context, field graphql.CollectedField, obj *model.GitConfigResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "GitConfigResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SSHPrivateKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _HeatmapDataResponse_bins(ctx context.Context, field graphql.CollectedField, obj *model.HeatmapDataResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "HeatmapDataResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bins, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.WorkflowRunsData)
	fc.Result = res
	return ec.marshalNWorkflowRunsData2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunsData(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_isDefault(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDefault, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_imageRegistryName(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageRegistryName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_imageRepoName(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageRepoName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_imageRegistryType(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageRegistryType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_secretName(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecretName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_secretNamespace(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecretNamespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistry_enableRegistry(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistry",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnableRegistry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_isDefault(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDefault, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_imageRegistryInfo(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageRegistryInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ImageRegistry)
	fc.Result = res
	return ec.marshalOImageRegistry2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐImageRegistry(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_imageRegistryID(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageRegistryID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_projectID(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ImageRegistryResponse_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.ImageRegistryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ImageRegistryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _KubeObjectResponse_clusterID(ctx context.Context, field graphql.CollectedField, obj *model.KubeObjectResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KubeObjectResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _KubeObjectResponse_kubeObj(ctx context.Context, field graphql.CollectedField, obj *model.KubeObjectResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "KubeObjectResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KubeObj, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _LabelValue_label(ctx context.Context, field graphql.CollectedField, obj *model.LabelValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "LabelValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Label, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _LabelValue_values(ctx context.Context, field graphql.CollectedField, obj *model.LabelValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "LabelValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Values, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Option)
	fc.Result = res
	return ec.marshalOOption2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐOption(ctx, field.Selections, res)
}

func (ec *executionContext) _Link_name(ctx context.Context, field graphql.CollectedField, obj *model.Link) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Link",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Link_url(ctx context.Context, field graphql.CollectedField, obj *model.Link) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Link",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_dsID(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DsID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_dbID(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DbID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_dbName(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DbName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_dbTypeID(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DbTypeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_dbTypeName(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DbTypeName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_dbInformation(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DbInformation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_chaosEventQueryTemplate(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChaosEventQueryTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_chaosVerdictQueryTemplate(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChaosVerdictQueryTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_applicationMetadataMap(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplicationMetadataMap, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ApplicationMetadataResponse)
	fc.Result = res
	return ec.marshalOApplicationMetadataResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐApplicationMetadataResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_clusterName(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_dsName(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DsName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_dsType(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DsType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_dsURL(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DsURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_dsHealthStatus(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DsHealthStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_panelGroups(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PanelGroups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PanelGroupResponse)
	fc.Result = res
	return ec.marshalNPanelGroupResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanelGroupResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_endTime(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_startTime(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_refreshRate(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RefreshRate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_projectID(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_clusterID(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ListDashboardResponse_viewedAt(ctx context.Context, field graphql.CollectedField, obj *model.ListDashboardResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListDashboardResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ViewedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ListWorkflowRunsResponse_totalNoOfWorkflowRuns(ctx context.Context, field graphql.CollectedField, obj *model.ListWorkflowRunsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListWorkflowRunsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalNoOfWorkflowRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ListWorkflowRunsResponse_workflowRuns(ctx context.Context, field graphql.CollectedField, obj *model.ListWorkflowRunsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListWorkflowRunsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.WorkflowRun)
	fc.Result = res
	return ec.marshalNWorkflowRun2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRun(ctx, field.Selections, res)
}

func (ec *executionContext) _ListWorkflowsResponse_totalNoOfWorkflows(ctx context.Context, field graphql.CollectedField, obj *model.ListWorkflowsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListWorkflowsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalNoOfWorkflows, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _ListWorkflowsResponse_workflows(ctx context.Context, field graphql.CollectedField, obj *model.ListWorkflowsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ListWorkflowsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Workflows, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Workflow)
	fc.Result = res
	return ec.marshalNWorkflow2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflow(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_name(ctx context.Context, field graphql.CollectedField, obj *model.Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Maintainer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Maintainer_email(ctx context.Context, field graphql.CollectedField, obj *model.Maintainer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Maintainer",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Metadata_name(ctx context.Context, field graphql.CollectedField, obj *model.Metadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Metadata",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Metadata_version(ctx context.Context, field graphql.CollectedField, obj *model.Metadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Metadata",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Metadata_annotations(ctx context.Context, field graphql.CollectedField, obj *model.Metadata) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Metadata",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Annotation)
	fc.Result = res
	return ec.marshalNAnnotation2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAnnotation(ctx, field.Selections, res)
}

func (ec *executionContext) _MetricDataForPanel_panelID(ctx context.Context, field graphql.CollectedField, obj *model.MetricDataForPanel) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "MetricDataForPanel",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PanelID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MetricDataForPanel_panelMetricsResponse(ctx context.Context, field graphql.CollectedField, obj *model.MetricDataForPanel) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "MetricDataForPanel",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PanelMetricsResponse, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MetricsPromResponse)
	fc.Result = res
	return ec.marshalOMetricsPromResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetricsPromResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _MetricDataForPanelGroup_panelGroupID(ctx context.Context, field graphql.CollectedField, obj *model.MetricDataForPanelGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "MetricDataForPanelGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PanelGroupID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MetricDataForPanelGroup_panelGroupMetricsResponse(ctx context.Context, field graphql.CollectedField, obj *model.MetricDataForPanelGroup) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "MetricDataForPanelGroup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PanelGroupMetricsResponse, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MetricDataForPanel)
	fc.Result = res
	return ec.marshalOMetricDataForPanel2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetricDataForPanel(ctx, field.Selections, res)
}

func (ec *executionContext) _MetricsPromResponse_queryID(ctx context.Context, field graphql.CollectedField, obj *model.MetricsPromResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "MetricsPromResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MetricsPromResponse_legends(ctx context.Context, field graphql.CollectedField, obj *model.MetricsPromResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "MetricsPromResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Legends, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _MetricsPromResponse_tsvs(ctx context.Context, field graphql.CollectedField, obj *model.MetricsPromResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "MetricsPromResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tsvs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([][]*model.MetricsTimeStampValue)
	fc.Result = res
	return ec.marshalOMetricsTimeStampValue2ᚕᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetricsTimeStampValue(ctx, field.Selections, res)
}

func (ec *executionContext) _MetricsTimeStampValue_date(ctx context.Context, field graphql.CollectedField, obj *model.MetricsTimeStampValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "MetricsTimeStampValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) _MetricsTimeStampValue_value(ctx context.Context, field graphql.CollectedField, obj *model.MetricsTimeStampValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "MetricsTimeStampValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createChaosWorkFlow(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createChaosWorkFlow_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateChaosWorkFlow(rctx, args["request"].(model.ChaosWorkFlowRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ChaosWorkFlowResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ChaosWorkFlowResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosWorkFlowResponse)
	fc.Result = res
	return ec.marshalNChaosWorkFlowResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChaosWorkFlowResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_reRunChaosWorkFlow(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_reRunChaosWorkFlow_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ReRunChaosWorkFlow(rctx, args["projectID"].(string), args["workflowID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateChaosWorkflow(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateChaosWorkflow_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateChaosWorkflow(rctx, args["request"].(*model.ChaosWorkFlowRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ChaosWorkFlowResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ChaosWorkFlowResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosWorkFlowResponse)
	fc.Result = res
	return ec.marshalNChaosWorkFlowResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChaosWorkFlowResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteChaosWorkflow(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteChaosWorkflow_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteChaosWorkflow(rctx, args["projectID"].(string), args["workflowID"].(*string), args["workflowRunID"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_terminateChaosWorkflow(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_terminateChaosWorkflow_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().TerminateChaosWorkflow(rctx, args["projectID"].(string), args["workflowID"].(*string), args["workflowRunID"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_chaosWorkflowRun(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_chaosWorkflowRun_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ChaosWorkflowRun(rctx, args["request"].(model.WorkflowRunRequest))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_syncWorkflowRun(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_syncWorkflowRun_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SyncWorkflowRun(rctx, args["projectID"].(string), args["workflowID"].(string), args["workflowRunID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createDataSource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createDataSource_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateDataSource(rctx, args["datasource"].(*model.DSInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.DSResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.DSResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DSResponse)
	fc.Result = res
	return ec.marshalODSResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDSResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createDashBoard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createDashBoard_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateDashBoard(rctx, args["dashboard"].(*model.CreateDBInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ListDashboardResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ListDashboardResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ListDashboardResponse)
	fc.Result = res
	return ec.marshalNListDashboardResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐListDashboardResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateDataSource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateDataSource_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateDataSource(rctx, args["datasource"].(model.DSInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.DSResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.DSResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DSResponse)
	fc.Result = res
	return ec.marshalNDSResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDSResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateDashboard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateDashboard_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateDashboard(rctx, args["projectID"].(string), args["dashboard"].(model.UpdateDBInput), args["chaosQueryUpdate"].(bool))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updatePanel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updatePanel_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdatePanel(rctx, args["panelInput"].([]*model.Panel))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteDashboard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteDashboard_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteDashboard(rctx, args["projectID"].(string), args["dbID"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteDataSource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteDataSource_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteDataSource(rctx, args["projectID"].(string), args["input"].(model.DeleteDSInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_registerCluster(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_registerCluster_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RegisterCluster(rctx, args["request"].(model.RegisterClusterRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.RegisterClusterResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.RegisterClusterResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RegisterClusterResponse)
	fc.Result = res
	return ec.marshalNRegisterClusterResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐRegisterClusterResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_confirmClusterRegistration(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_confirmClusterRegistration_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ConfirmClusterRegistration(rctx, args["request"].(model.ClusterIdentity))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ConfirmClusterRegistrationResponse)
	fc.Result = res
	return ec.marshalNConfirmClusterRegistrationResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐConfirmClusterRegistrationResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_newClusterEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_newClusterEvent_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().NewClusterEvent(rctx, args["request"].(model.NewClusterEventRequest))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteClusters(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteClusters_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteClusters(rctx, args["projectID"].(string), args["clusterIDs"].([]*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_podLog(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_podLog_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PodLog(rctx, args["request"].(model.PodLog))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_kubeObj(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_kubeObj_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().KubeObj(rctx, args["request"].(model.KubeObjectData))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_gitopsNotifier(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_gitopsNotifier_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().GitopsNotifier(rctx, args["clusterInfo"].(model.ClusterIdentity), args["workflowID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_enableGitOps(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_enableGitOps_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().EnableGitOps(rctx, args["config"].(model.GitConfig))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_disableGitOps(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_disableGitOps_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DisableGitOps(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateGitOps(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateGitOps_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateGitOps(rctx, args["config"].(model.GitConfig))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createImageRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createImageRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateImageRegistry(rctx, args["projectID"].(string), args["imageRegistryInfo"].(model.ImageRegistryInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ImageRegistryResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ImageRegistryResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ImageRegistryResponse)
	fc.Result = res
	return ec.marshalNImageRegistryResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐImageRegistryResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateImageRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateImageRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateImageRegistry(rctx, args["imageRegistryID"].(string), args["projectID"].(string), args["imageRegistryInfo"].(model.ImageRegistryInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ImageRegistryResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ImageRegistryResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ImageRegistryResponse)
	fc.Result = res
	return ec.marshalNImageRegistryResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐImageRegistryResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteImageRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteImageRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteImageRegistry(rctx, args["imageRegistryID"].(string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_addChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_addChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddChaosHub(rctx, args["request"].(model.CreateChaosHubRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ChaosHub); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ChaosHub`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosHub)
	fc.Result = res
	return ec.marshalNChaosHub2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChaosHub(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_addRemoteChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_addRemoteChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddRemoteChaosHub(rctx, args["request"].(model.CreateRemoteMyHub))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ChaosHub); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ChaosHub`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosHub)
	fc.Result = res
	return ec.marshalNChaosHub2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChaosHub(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_saveChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_saveChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SaveChaosHub(rctx, args["request"].(model.CreateChaosHubRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ChaosHub); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ChaosHub`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosHub)
	fc.Result = res
	return ec.marshalNChaosHub2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChaosHub(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_syncChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_syncChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SyncChaosHub(rctx, args["id"].(string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_generateSSHKey(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().GenerateSSHKey(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.SSHKey); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.SSHKey`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.SSHKey)
	fc.Result = res
	return ec.marshalNSSHKey2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐSSHKey(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateChaosHub(rctx, args["request"].(model.UpdateChaosHubRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ChaosHub); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ChaosHub`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChaosHub)
	fc.Result = res
	return ec.marshalNChaosHub2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChaosHub(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteChaosHub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteChaosHub_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteChaosHub(rctx, args["projectID"].(string), args["hubID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createWorkflowTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createWorkflowTemplate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateWorkflowTemplate(rctx, args["request"].(*model.TemplateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.WorkflowTemplate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.WorkflowTemplate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.WorkflowTemplate)
	fc.Result = res
	return ec.marshalNWorkflowTemplate2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteWorkflowTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteWorkflowTemplate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteWorkflowTemplate(rctx, args["projectID"].(string), args["templateID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Option_name(ctx context.Context, field graphql.CollectedField, obj *model.Option) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Option",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PackageInformation_packageName(ctx context.Context, field graphql.CollectedField, obj *model.PackageInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PackageInformation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PackageName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PackageInformation_experiments(ctx context.Context, field graphql.CollectedField, obj *model.PackageInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PackageInformation",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Experiments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Experiments)
	fc.Result = res
	return ec.marshalNExperiments2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐExperimentsᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelGroupResponse_panels(ctx context.Context, field graphql.CollectedField, obj *model.PanelGroupResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelGroupResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Panels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.PanelResponse)
	fc.Result = res
	return ec.marshalOPanelResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelGroupResponse_panelGroupName(ctx context.Context, field graphql.CollectedField, obj *model.PanelGroupResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelGroupResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PanelGroupName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelGroupResponse_panelGroupID(ctx context.Context, field graphql.CollectedField, obj *model.PanelGroupResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelGroupResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PanelGroupID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelOptionResponse_points(ctx context.Context, field graphql.CollectedField, obj *model.PanelOptionResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelOptionResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Points, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelOptionResponse_grIDs(ctx context.Context, field graphql.CollectedField, obj *model.PanelOptionResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelOptionResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GrIDs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelOptionResponse_leftAxis(ctx context.Context, field graphql.CollectedField, obj *model.PanelOptionResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelOptionResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LeftAxis, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelResponse_panelID(ctx context.Context, field graphql.CollectedField, obj *model.PanelResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PanelID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelResponse_yAxisLeft(ctx context.Context, field graphql.CollectedField, obj *model.PanelResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.YAxisLeft, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelResponse_yAxisRight(ctx context.Context, field graphql.CollectedField, obj *model.PanelResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.YAxisRight, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelResponse_xAxisDown(ctx context.Context, field graphql.CollectedField, obj *model.PanelResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.XAxisDown, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelResponse_unit(ctx context.Context, field graphql.CollectedField, obj *model.PanelResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelResponse_promQueries(ctx context.Context, field graphql.CollectedField, obj *model.PanelResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PromQueries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.PromQueryResponse)
	fc.Result = res
	return ec.marshalOPromQueryResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromQueryResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelResponse_panelOptions(ctx context.Context, field graphql.CollectedField, obj *model.PanelResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PanelOptions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PanelOptionResponse)
	fc.Result = res
	return ec.marshalOPanelOptionResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanelOptionResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelResponse_panelName(ctx context.Context, field graphql.CollectedField, obj *model.PanelResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PanelName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _PanelResponse_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.PanelResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PanelResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _PodLogResponse_workflowRunID(ctx context.Context, field graphql.CollectedField, obj *model.PodLogResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PodLogResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowRunID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PodLogResponse_podName(ctx context.Context, field graphql.CollectedField, obj *model.PodLogResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PodLogResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PodName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PodLogResponse_podType(ctx context.Context, field graphql.CollectedField, obj *model.PodLogResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PodLogResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PodType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PodLogResponse_log(ctx context.Context, field graphql.CollectedField, obj *model.PodLogResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PodLogResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Log, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PortalDashboardDataResponse_name(ctx context.Context, field graphql.CollectedField, obj *model.PortalDashboardDataResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PortalDashboardDataResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PortalDashboardDataResponse_dashboardData(ctx context.Context, field graphql.CollectedField, obj *model.PortalDashboardDataResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PortalDashboardDataResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DashboardData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PredefinedWorkflowList_workflowName(ctx context.Context, field graphql.CollectedField, obj *model.PredefinedWorkflowList) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PredefinedWorkflowList",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PredefinedWorkflowList_workflowCSV(ctx context.Context, field graphql.CollectedField, obj *model.PredefinedWorkflowList) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PredefinedWorkflowList",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowCsv, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PredefinedWorkflowList_workflowManifest(ctx context.Context, field graphql.CollectedField, obj *model.PredefinedWorkflowList) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PredefinedWorkflowList",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowManifest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ProjectData_workflows(ctx context.Context, field graphql.CollectedField, obj *model.ProjectData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ProjectData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Workflows, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.WorkflowStat)
	fc.Result = res
	return ec.marshalNWorkflowStat2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowStat(ctx, field.Selections, res)
}

func (ec *executionContext) _ProjectData_agents(ctx context.Context, field graphql.CollectedField, obj *model.ProjectData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ProjectData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Agents, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AgentStat)
	fc.Result = res
	return ec.marshalNAgentStat2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAgentStat(ctx, field.Selections, res)
}

func (ec *executionContext) _ProjectData_projectID(ctx context.Context, field graphql.CollectedField, obj *model.ProjectData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ProjectData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PromQueryResponse_queryID(ctx context.Context, field graphql.CollectedField, obj *model.PromQueryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PromQueryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PromQueryResponse_promQueryName(ctx context.Context, field graphql.CollectedField, obj *model.PromQueryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PromQueryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PromQueryName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _PromQueryResponse_legend(ctx context.Context, field graphql.CollectedField, obj *model.PromQueryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PromQueryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Legend, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _PromQueryResponse_resolution(ctx context.Context, field graphql.CollectedField, obj *model.PromQueryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PromQueryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resolution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _PromQueryResponse_minstep(ctx context.Context, field graphql.CollectedField, obj *model.PromQueryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PromQueryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Minstep, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _PromQueryResponse_line(ctx context.Context, field graphql.CollectedField, obj *model.PromQueryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PromQueryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Line, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _PromQueryResponse_closeArea(ctx context.Context, field graphql.CollectedField, obj *model.PromQueryResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PromQueryResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CloseArea, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _PromSeriesListResponse_seriesList(ctx context.Context, field graphql.CollectedField, obj *model.PromSeriesListResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PromSeriesListResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SeriesList, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _PromSeriesResponse_series(ctx context.Context, field graphql.CollectedField, obj *model.PromSeriesResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PromSeriesResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Series, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PromSeriesResponse_labelValues(ctx context.Context, field graphql.CollectedField, obj *model.PromSeriesResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PromSeriesResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LabelValues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.LabelValue)
	fc.Result = res
	return ec.marshalOLabelValue2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐLabelValue(ctx, field.Selections, res)
}

func (ec *executionContext) _PrometheusDataResponse_metricsResponse(ctx context.Context, field graphql.CollectedField, obj *model.PrometheusDataResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PrometheusDataResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetricsResponse, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MetricsPromResponse)
	fc.Result = res
	return ec.marshalOMetricsPromResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetricsPromResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _PrometheusDataResponse_annotationsResponse(ctx context.Context, field graphql.CollectedField, obj *model.PrometheusDataResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "PrometheusDataResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AnnotationsResponse, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.AnnotationsPromResponse)
	fc.Result = res
	return ec.marshalOAnnotationsPromResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAnnotationsPromResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Provider_name(ctx context.Context, field graphql.CollectedField, obj *model.Provider) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Provider",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listWorkflows(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listWorkflows_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListWorkflows(rctx, args["request"].(model.ListWorkflowsRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ListWorkflowsResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ListWorkflowsResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ListWorkflowsResponse)
	fc.Result = res
	return ec.marshalNListWorkflowsResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐListWorkflowsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listWorkflowRuns(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listWorkflowRuns_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListWorkflowRuns(rctx, args["request"].(model.ListWorkflowRunsRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ListWorkflowRunsResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ListWorkflowRunsResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ListWorkflowRunsResponse)
	fc.Result = res
	return ec.marshalNListWorkflowRunsResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐListWorkflowRunsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listHeatmapData(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listHeatmapData_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListHeatmapData(rctx, args["projectID"].(string), args["workflowID"].(string), args["year"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.HeatmapDataResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.HeatmapDataResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.HeatmapDataResponse)
	fc.Result = res
	return ec.marshalNHeatmapDataResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐHeatmapDataResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listWorkflowStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listWorkflowStats_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListWorkflowStats(rctx, args["projectID"].(string), args["filter"].(model.TimeFrequency), args["showWorkflowRuns"].(bool))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.WorkflowStatsResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.WorkflowStatsResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.WorkflowStatsResponse)
	fc.Result = res
	return ec.marshalNWorkflowStatsResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowStatsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getWorkflowRunStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getWorkflowRunStats_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetWorkflowRunStats(rctx, args["workflowRunStatsRequest"].(model.WorkflowRunStatsRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.WorkflowRunStatsResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.WorkflowRunStatsResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.WorkflowRunStatsResponse)
	fc.Result = res
	return ec.marshalNWorkflowRunStatsResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunStatsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listDataSource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listDataSource_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListDataSource(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.DSResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.DSResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.DSResponse)
	fc.Result = res
	return ec.marshalNDSResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDSResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getPrometheusData(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getPrometheusData_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetPrometheusData(rctx, args["request"].(*model.PrometheusDataRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.PrometheusDataResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.PrometheusDataResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PrometheusDataResponse)
	fc.Result = res
	return ec.marshalNPrometheusDataResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPrometheusDataResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getPromLabelNamesAndValues(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getPromLabelNamesAndValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetPromLabelNamesAndValues(rctx, args["request"].(*model.PromSeriesInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.PromSeriesResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.PromSeriesResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PromSeriesResponse)
	fc.Result = res
	return ec.marshalNPromSeriesResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromSeriesResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getPromSeriesList(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getPromSeriesList_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetPromSeriesList(rctx, args["request"].(*model.DsDetails))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.PromSeriesListResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.PromSeriesListResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PromSeriesListResponse)
	fc.Result = res
	return ec.marshalNPromSeriesListResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromSeriesListResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listDashboard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listDashboard_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListDashboard(rctx, args["projectID"].(string), args["clusterID"].(*string), args["dbID"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.ListDashboardResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ListDashboardResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ListDashboardResponse)
	fc.Result = res
	return ec.marshalOListDashboardResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐListDashboardResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listPortalDashboardData(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listPortalDashboardData_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListPortalDashboardData(rctx, args["projectID"].(string), args["hubName"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.PortalDashboardDataResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.PortalDashboardDataResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PortalDashboardDataResponse)
	fc.Result = res
	return ec.marshalNPortalDashboardDataResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPortalDashboardDataResponseᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getServerVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetServerVersion(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ServerVersionResponse)
	fc.Result = res
	return ec.marshalNServerVersionResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐServerVersionResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listClusters(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listClusters_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListClusters(rctx, args["projectID"].(string), args["clusterType"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Cluster); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.Cluster`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Cluster)
	fc.Result = res
	return ec.marshalNCluster2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐClusterᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getAgentDetails(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getAgentDetails_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetAgentDetails(rctx, args["clusterID"].(string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Cluster); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.Cluster`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Cluster)
	fc.Result = res
	return ec.marshalNCluster2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐCluster(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getManifest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getManifest_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetManifest(rctx, args["projectID"].(string), args["clusterID"].(string), args["accessKey"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getGitOpsDetails(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getGitOpsDetails_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetGitOpsDetails(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.GitConfigResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.GitConfigResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.GitConfigResponse)
	fc.Result = res
	return ec.marshalNGitConfigResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐGitConfigResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listImageRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listImageRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListImageRegistry(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.ImageRegistryResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ImageRegistryResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ImageRegistryResponse)
	fc.Result = res
	return ec.marshalOImageRegistryResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐImageRegistryResponseᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getImageRegistry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getImageRegistry_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetImageRegistry(rctx, args["imageRegistryID"].(string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ImageRegistryResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ImageRegistryResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ImageRegistryResponse)
	fc.Result = res
	return ec.marshalNImageRegistryResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐImageRegistryResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listCharts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listCharts_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListCharts(rctx, args["hubName"].(string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Chart); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.Chart`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Chart)
	fc.Result = res
	return ec.marshalNChart2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChartᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getHubExperiment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getHubExperiment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetHubExperiment(rctx, args["request"].(model.ExperimentRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Chart); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.Chart`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Chart)
	fc.Result = res
	return ec.marshalNChart2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChart(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listHubStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listHubStatus_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListHubStatus(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.ChaosHubStatus); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ChaosHubStatus`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ChaosHubStatus)
	fc.Result = res
	return ec.marshalNChaosHubStatus2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChaosHubStatus(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getYAMLData(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getYAMLData_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetYAMLData(rctx, args["request"].(model.ExperimentRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getExperimentDetails(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getExperimentDetails_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetExperimentDetails(rctx, args["request"].(model.ExperimentRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ExperimentDetails); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ExperimentDetails`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ExperimentDetails)
	fc.Result = res
	return ec.marshalNExperimentDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐExperimentDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listPredefinedWorkflows(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listPredefinedWorkflows_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListPredefinedWorkflows(rctx, args["hubName"].(string), args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.PredefinedWorkflowList); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.PredefinedWorkflowList`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PredefinedWorkflowList)
	fc.Result = res
	return ec.marshalNPredefinedWorkflowList2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPredefinedWorkflowListᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getPredefinedExperimentYAML(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getPredefinedExperimentYAML_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetPredefinedExperimentYaml(rctx, args["request"].(model.ExperimentRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getUsageData(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getUsageData_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetUsageData(rctx, args["request"].(model.UsageDataRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.UsageDataResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.UsageDataResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UsageDataResponse)
	fc.Result = res
	return ec.marshalNUsageDataResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐUsageDataResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_listWorkflowManifests(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_listWorkflowManifests_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListWorkflowManifests(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.WorkflowTemplate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.WorkflowTemplate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.WorkflowTemplate)
	fc.Result = res
	return ec.marshalNWorkflowTemplate2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getWorkflowManifestByID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getWorkflowManifestByID_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetWorkflowManifestByID(rctx, args["projectID"].(string), args["templateID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.WorkflowTemplate); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.WorkflowTemplate`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.WorkflowTemplate)
	fc.Result = res
	return ec.marshalNWorkflowTemplate2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _RegisterClusterResponse_token(ctx context.Context, field graphql.CollectedField, obj *model.RegisterClusterResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RegisterClusterResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RegisterClusterResponse_clusterID(ctx context.Context, field graphql.CollectedField, obj *model.RegisterClusterResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RegisterClusterResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RegisterClusterResponse_clusterName(ctx context.Context, field graphql.CollectedField, obj *model.RegisterClusterResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "RegisterClusterResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ResourceResponse_kind(ctx context.Context, field graphql.CollectedField, obj *model.ResourceResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ResourceResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ResourceResponse_names(ctx context.Context, field graphql.CollectedField, obj *model.ResourceResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ResourceResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Names, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _SSHKey_publicKey(ctx context.Context, field graphql.CollectedField, obj *model.SSHKey) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "SSHKey",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublicKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _SSHKey_privateKey(ctx context.Context, field graphql.CollectedField, obj *model.SSHKey) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "SSHKey",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrivateKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ServerVersionResponse_key(ctx context.Context, field graphql.CollectedField, obj *model.ServerVersionResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ServerVersionResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ServerVersionResponse_value(ctx context.Context, field graphql.CollectedField, obj *model.ServerVersionResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ServerVersionResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_displayName(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_categoryDescription(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CategoryDescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_keywords(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Keywords, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_maturity(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Maturity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_maintainers(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Maintainers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Maintainer)
	fc.Result = res
	return ec.marshalNMaintainer2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMaintainerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_minKubeVersion(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinKubeVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_provider(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Provider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Provider)
	fc.Result = res
	return ec.marshalNProvider2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐProvider(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_links(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Links, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Link)
	fc.Result = res
	return ec.marshalNLink2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐLinkᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_experiments(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Experiments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_chaosExpCRDLink(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChaosExpCRDLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_platforms(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Platforms, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Spec_chaosType(ctx context.Context, field graphql.CollectedField, obj *model.Spec) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Spec",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChaosType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _SubData_date(ctx context.Context, field graphql.CollectedField, obj *model.SubData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "SubData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) _SubData_value(ctx context.Context, field graphql.CollectedField, obj *model.SubData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "SubData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _SubData_subDataName(ctx context.Context, field graphql.CollectedField, obj *model.SubData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "SubData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubDataName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Subscription_getWorkflowEvents(ctx context.Context, field graphql.CollectedField) (ret func() graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Subscription",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_getWorkflowEvents_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().GetWorkflowEvents(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *model.WorkflowRun); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.WorkflowRun`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-resTmp.(<-chan *model.WorkflowRun)
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalNWorkflowRun2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRun(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _Subscription_viewDashboard(ctx context.Context, field graphql.CollectedField) (ret func() graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Subscription",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_viewDashboard_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().ViewDashboard(rctx, args["dashboardID"].(*string), args["promQueries"].([]*model.PromQueryInput), args["dashboardQueryMap"].([]*model.QueryMapForPanelGroup), args["dataVariables"].(model.DataVars))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *model.DashboardPromResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.DashboardPromResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-resTmp.(<-chan *model.DashboardPromResponse)
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalNDashboardPromResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDashboardPromResponse(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _Subscription_getClusterEvents(ctx context.Context, field graphql.CollectedField) (ret func() graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Subscription",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_getClusterEvents_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().GetClusterEvents(rctx, args["projectID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *model.ClusterEventResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.ClusterEventResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-resTmp.(<-chan *model.ClusterEventResponse)
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalNClusterEventResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐClusterEventResponse(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _Subscription_clusterConnect(ctx context.Context, field graphql.CollectedField) (ret func() graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Subscription",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_clusterConnect_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().ClusterConnect(rctx, args["clusterInfo"].(model.ClusterIdentity))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-resTmp.(<-chan *model.ClusterActionResponse)
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalNClusterActionResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐClusterActionResponse(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _Subscription_getPodLog(ctx context.Context, field graphql.CollectedField) (ret func() graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Subscription",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_getPodLog_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().GetPodLog(rctx, args["request"].(model.PodLogRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *model.PodLogResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.PodLogResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-resTmp.(<-chan *model.PodLogResponse)
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalNPodLogResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPodLogResponse(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _Subscription_getKubeObject(ctx context.Context, field graphql.CollectedField) (ret func() graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Subscription",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_getKubeObject_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().GetKubeObject(rctx, args["request"].(model.KubeObjectRequest))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *model.KubeObjectResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/litmuschaos/litmus/litmus-portal/graphql-server/graph/model.KubeObjectResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-resTmp.(<-chan *model.KubeObjectResponse)
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalNKubeObjectResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐKubeObjectResponse(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _TotalCount_projects(ctx context.Context, field graphql.CollectedField, obj *model.TotalCount) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "TotalCount",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Projects, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _TotalCount_users(ctx context.Context, field graphql.CollectedField, obj *model.TotalCount) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "TotalCount",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _TotalCount_agents(ctx context.Context, field graphql.CollectedField, obj *model.TotalCount) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "TotalCount",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Agents, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AgentStat)
	fc.Result = res
	return ec.marshalNAgentStat2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAgentStat(ctx, field.Selections, res)
}

func (ec *executionContext) _TotalCount_workflows(ctx context.Context, field graphql.CollectedField, obj *model.TotalCount) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "TotalCount",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Workflows, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.WorkflowStat)
	fc.Result = res
	return ec.marshalNWorkflowStat2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowStat(ctx, field.Selections, res)
}

func (ec *executionContext) _UsageDataResponse_projects(ctx context.Context, field graphql.CollectedField, obj *model.UsageDataResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "UsageDataResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Projects, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ProjectData)
	fc.Result = res
	return ec.marshalNProjectData2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐProjectData(ctx, field.Selections, res)
}

func (ec *executionContext) _UsageDataResponse_totalEntries(ctx context.Context, field graphql.CollectedField, obj *model.UsageDataResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "UsageDataResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalEntries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _UsageDataResponse_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.UsageDataResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "UsageDataResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TotalCount)
	fc.Result = res
	return ec.marshalNTotalCount2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐTotalCount(ctx, field.Selections, res)
}

func (ec *executionContext) _Weightages_experimentName(ctx context.Context, field graphql.CollectedField, obj *model.Weightages) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Weightages",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Weightages_weightage(ctx context.Context, field graphql.CollectedField, obj *model.Weightages) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Weightages",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weightage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_workflowID(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_workflowManifest(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowManifest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_cronSyntax(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CronSyntax, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_clusterName(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_workflowName(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_workflowDescription(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowDescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_weightages(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weightages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Weightages)
	fc.Result = res
	return ec.marshalNWeightages2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWeightagesᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_isCustomWorkflow(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsCustomWorkflow, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_projectID(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_clusterID(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_clusterType(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Workflow_lastUpdatedBy(ctx context.Context, field graphql.CollectedField, obj *model.Workflow) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Workflow",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_workflowRunID(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowRunID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_workflowID(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_clusterName(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_weightages(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weightages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Weightages)
	fc.Result = res
	return ec.marshalNWeightages2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWeightagesᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_lastUpdated(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_projectID(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_clusterID(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_workflowName(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_clusterType(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClusterType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_phase(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phase, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_resiliencyScore(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResiliencyScore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_experimentsPassed(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentsPassed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_experimentsFailed(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentsFailed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_experimentsAwaited(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentsAwaited, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_experimentsStopped(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentsStopped, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_experimentsNa(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentsNa, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_totalExperiments(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalExperiments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_executionData(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExecutionData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRun_executedBy(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRun) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExecutedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunDetails_noOfRuns(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NoOfRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunDetails_dateStamp(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunDetails",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DateStamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_totalWorkflowRuns(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalWorkflowRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_succeededWorkflowRuns(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SucceededWorkflowRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_failedWorkflowRuns(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailedWorkflowRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_runningWorkflowRuns(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RunningWorkflowRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_averageResiliencyScore(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AverageResiliencyScore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_totalExperiments(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalExperiments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_experimentsPassed(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentsPassed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_experimentsFailed(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentsFailed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_experimentsAwaited(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentsAwaited, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_experimentsStopped(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentsStopped, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_experimentsNa(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentsNa, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_passedPercentage(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PassedPercentage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_failedPercentage(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailedPercentage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_workflowRunSucceededPercentage(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowRunSucceededPercentage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunStatsResponse_workflowRunFailedPercentage(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowRunFailedPercentage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunsData_value(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunsData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunsData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowRunsData_workflowRunDetail(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowRunsData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowRunsData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowRunDetail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.WorkflowRunDetails)
	fc.Result = res
	return ec.marshalOWorkflowRunDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowStat_schedules(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowStat) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowStat",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Schedules, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowStat_runs(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowStat) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowStat",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Runs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowStat_expRuns(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowStat) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowStat",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowStatsResponse_date(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowStatsResponse_value(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowStatsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowStatsResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowTemplate_templateID(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowTemplate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TemplateID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowTemplate_manifest(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowTemplate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Manifest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowTemplate_templateName(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowTemplate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TemplateName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowTemplate_templateDescription(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowTemplate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TemplateDescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowTemplate_projectID(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowTemplate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowTemplate_projectName(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowTemplate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowTemplate_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowTemplate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowTemplate_isRemoved(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowTemplate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _WorkflowTemplate_isCustomWorkflow(ctx context.Context, field graphql.CollectedField, obj *model.WorkflowTemplate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "WorkflowTemplate",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsCustomWorkflow, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputApplicationMetadata(ctx context.Context, obj interface{}) (model.ApplicationMetadata, error) {
	var it model.ApplicationMetadata
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "namespace":
			var err error
			it.Namespace, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "applications":
			var err error
			it.Applications, err = ec.unmarshalOResource2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐResource(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChaosWorkFlowRequest(ctx context.Context, obj interface{}) (model.ChaosWorkFlowRequest, error) {
	var it model.ChaosWorkFlowRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "workflowID":
			var err error
			it.WorkflowID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowManifest":
			var err error
			it.WorkflowManifest, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "cronSyntax":
			var err error
			it.CronSyntax, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowName":
			var err error
			it.WorkflowName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowDescription":
			var err error
			it.WorkflowDescription, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "weightages":
			var err error
			it.Weightages, err = ec.unmarshalNWeightagesInput2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWeightagesInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "isCustomWorkflow":
			var err error
			it.IsCustomWorkflow, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "clusterID":
			var err error
			it.ClusterID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCloningInput(ctx context.Context, obj interface{}) (model.CloningInput, error) {
	var it model.CloningInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "hubName":
			var err error
			it.HubName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoBranch":
			var err error
			it.RepoBranch, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoURL":
			var err error
			it.RepoURL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isPrivate":
			var err error
			it.IsPrivate, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "authType":
			var err error
			it.AuthType, err = ec.unmarshalNAuthType2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAuthType(ctx, v)
			if err != nil {
				return it, err
			}
		case "token":
			var err error
			it.Token, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "userName":
			var err error
			it.UserName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sshPrivateKey":
			var err error
			it.SSHPrivateKey, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputClusterIdentity(ctx context.Context, obj interface{}) (model.ClusterIdentity, error) {
	var it model.ClusterIdentity
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "clusterID":
			var err error
			it.ClusterID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessKey":
			var err error
			it.AccessKey, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "version":
			var err error
			it.Version, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateChaosHubRequest(ctx context.Context, obj interface{}) (model.CreateChaosHubRequest, error) {
	var it model.CreateChaosHubRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "hubName":
			var err error
			it.HubName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoURL":
			var err error
			it.RepoURL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoBranch":
			var err error
			it.RepoBranch, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isPrivate":
			var err error
			it.IsPrivate, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "authType":
			var err error
			it.AuthType, err = ec.unmarshalNAuthType2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAuthType(ctx, v)
			if err != nil {
				return it, err
			}
		case "token":
			var err error
			it.Token, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "userName":
			var err error
			it.UserName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sshPrivateKey":
			var err error
			it.SSHPrivateKey, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sshPublicKey":
			var err error
			it.SSHPublicKey, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateDBInput(ctx context.Context, obj interface{}) (model.CreateDBInput, error) {
	var it model.CreateDBInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "dsID":
			var err error
			it.DsID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dbName":
			var err error
			it.DbName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dbTypeName":
			var err error
			it.DbTypeName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dbTypeID":
			var err error
			it.DbTypeID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dbInformation":
			var err error
			it.DbInformation, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "chaosEventQueryTemplate":
			var err error
			it.ChaosEventQueryTemplate, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "chaosVerdictQueryTemplate":
			var err error
			it.ChaosVerdictQueryTemplate, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "applicationMetadataMap":
			var err error
			it.ApplicationMetadataMap, err = ec.unmarshalOApplicationMetadata2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐApplicationMetadata(ctx, v)
			if err != nil {
				return it, err
			}
		case "panelGroups":
			var err error
			it.PanelGroups, err = ec.unmarshalNPanelGroup2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanelGroup(ctx, v)
			if err != nil {
				return it, err
			}
		case "endTime":
			var err error
			it.EndTime, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "startTime":
			var err error
			it.StartTime, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "clusterID":
			var err error
			it.ClusterID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "refreshRate":
			var err error
			it.RefreshRate, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateRemoteMyHub(ctx context.Context, obj interface{}) (model.CreateRemoteMyHub, error) {
	var it model.CreateRemoteMyHub
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "hubName":
			var err error
			it.HubName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoURL":
			var err error
			it.RepoURL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDSInput(ctx context.Context, obj interface{}) (model.DSInput, error) {
	var it model.DSInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "dsID":
			var err error
			it.DsID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "dsName":
			var err error
			it.DsName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dsType":
			var err error
			it.DsType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dsURL":
			var err error
			it.DsURL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessType":
			var err error
			it.AccessType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "authType":
			var err error
			it.AuthType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "basicAuthUsername":
			var err error
			it.BasicAuthUsername, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "basicAuthPassword":
			var err error
			it.BasicAuthPassword, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "scrapeInterval":
			var err error
			it.ScrapeInterval, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "queryTimeout":
			var err error
			it.QueryTimeout, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "httpMethod":
			var err error
			it.HTTPMethod, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDataVars(ctx context.Context, obj interface{}) (model.DataVars, error) {
	var it model.DataVars
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "url":
			var err error
			it.URL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "start":
			var err error
			it.Start, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "end":
			var err error
			it.End, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "relativeTime":
			var err error
			it.RelativeTime, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "refreshInterval":
			var err error
			it.RefreshInterval, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDateRange(ctx context.Context, obj interface{}) (model.DateRange, error) {
	var it model.DateRange
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "startDate":
			var err error
			it.StartDate, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "endDate":
			var err error
			it.EndDate, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteDSInput(ctx context.Context, obj interface{}) (model.DeleteDSInput, error) {
	var it model.DeleteDSInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "forceDelete":
			var err error
			it.ForceDelete, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "dsID":
			var err error
			it.DsID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDsDetails(ctx context.Context, obj interface{}) (model.DsDetails, error) {
	var it model.DsDetails
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "url":
			var err error
			it.URL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "start":
			var err error
			it.Start, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "end":
			var err error
			it.End, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExperimentRequest(ctx context.Context, obj interface{}) (model.ExperimentRequest, error) {
	var it model.ExperimentRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "chartName":
			var err error
			it.ChartName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "experimentName":
			var err error
			it.ExperimentName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hubName":
			var err error
			it.HubName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "fileType":
			var err error
			it.FileType, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGitConfig(ctx context.Context, obj interface{}) (model.GitConfig, error) {
	var it model.GitConfig
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "branch":
			var err error
			it.Branch, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoURL":
			var err error
			it.RepoURL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "authType":
			var err error
			it.AuthType, err = ec.unmarshalNAuthType2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAuthType(ctx, v)
			if err != nil {
				return it, err
			}
		case "token":
			var err error
			it.Token, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "userName":
			var err error
			it.UserName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sshPrivateKey":
			var err error
			it.SSHPrivateKey, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputImageRegistryInput(ctx context.Context, obj interface{}) (model.ImageRegistryInput, error) {
	var it model.ImageRegistryInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "isDefault":
			var err error
			it.IsDefault, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageRegistryName":
			var err error
			it.ImageRegistryName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageRepoName":
			var err error
			it.ImageRepoName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageRegistryType":
			var err error
			it.ImageRegistryType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "secretName":
			var err error
			it.SecretName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "secretNamespace":
			var err error
			it.SecretNamespace, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "enableRegistry":
			var err error
			it.EnableRegistry, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKubeGVRRequest(ctx context.Context, obj interface{}) (model.KubeGVRRequest, error) {
	var it model.KubeGVRRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "group":
			var err error
			it.Group, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "version":
			var err error
			it.Version, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "resource":
			var err error
			it.Resource, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKubeObjectData(ctx context.Context, obj interface{}) (model.KubeObjectData, error) {
	var it model.KubeObjectData
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "requestID":
			var err error
			it.RequestID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "clusterID":
			var err error
			it.ClusterID, err = ec.unmarshalNClusterIdentity2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐClusterIdentity(ctx, v)
			if err != nil {
				return it, err
			}
		case "kubeObj":
			var err error
			it.KubeObj, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKubeObjectRequest(ctx context.Context, obj interface{}) (model.KubeObjectRequest, error) {
	var it model.KubeObjectRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "clusterID":
			var err error
			it.ClusterID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "objectType":
			var err error
			it.ObjectType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "kubeObjRequest":
			var err error
			it.KubeObjRequest, err = ec.unmarshalNKubeGVRRequest2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐKubeGVRRequest(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListWorkflowRunsRequest(ctx context.Context, obj interface{}) (model.ListWorkflowRunsRequest, error) {
	var it model.ListWorkflowRunsRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowRunIDs":
			var err error
			it.WorkflowRunIDs, err = ec.unmarshalOID2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowIDs":
			var err error
			it.WorkflowIDs, err = ec.unmarshalOID2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "pagination":
			var err error
			it.Pagination, err = ec.unmarshalOPagination2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPagination(ctx, v)
			if err != nil {
				return it, err
			}
		case "sort":
			var err error
			it.Sort, err = ec.unmarshalOWorkflowRunSortInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunSortInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "filter":
			var err error
			it.Filter, err = ec.unmarshalOWorkflowRunFilterInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListWorkflowsRequest(ctx context.Context, obj interface{}) (model.ListWorkflowsRequest, error) {
	var it model.ListWorkflowsRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowIDs":
			var err error
			it.WorkflowIDs, err = ec.unmarshalOID2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "pagination":
			var err error
			it.Pagination, err = ec.unmarshalOPagination2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPagination(ctx, v)
			if err != nil {
				return it, err
			}
		case "sort":
			var err error
			it.Sort, err = ec.unmarshalOWorkflowSortInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowSortInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "filter":
			var err error
			it.Filter, err = ec.unmarshalOWorkflowFilterInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewClusterEventRequest(ctx context.Context, obj interface{}) (model.NewClusterEventRequest, error) {
	var it model.NewClusterEventRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "eventName":
			var err error
			it.EventName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "clusterID":
			var err error
			it.ClusterID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessKey":
			var err error
			it.AccessKey, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPagination(ctx context.Context, obj interface{}) (model.Pagination, error) {
	var it model.Pagination
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "page":
			var err error
			it.Page, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "limit":
			var err error
			it.Limit, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPanel(ctx context.Context, obj interface{}) (model.Panel, error) {
	var it model.Panel
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "panelID":
			var err error
			it.PanelID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "dbID":
			var err error
			it.DbID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "yAxisLeft":
			var err error
			it.YAxisLeft, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "yAxisRight":
			var err error
			it.YAxisRight, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "xAxisDown":
			var err error
			it.XAxisDown, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "unit":
			var err error
			it.Unit, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "panelGroupID":
			var err error
			it.PanelGroupID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error
			it.CreatedAt, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "promQueries":
			var err error
			it.PromQueries, err = ec.unmarshalOPromQuery2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromQuery(ctx, v)
			if err != nil {
				return it, err
			}
		case "panelOptions":
			var err error
			it.PanelOptions, err = ec.unmarshalOPanelOption2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanelOption(ctx, v)
			if err != nil {
				return it, err
			}
		case "panelName":
			var err error
			it.PanelName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPanelGroup(ctx context.Context, obj interface{}) (model.PanelGroup, error) {
	var it model.PanelGroup
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "panels":
			var err error
			it.Panels, err = ec.unmarshalOPanel2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanel(ctx, v)
			if err != nil {
				return it, err
			}
		case "panelGroupName":
			var err error
			it.PanelGroupName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPanelOption(ctx context.Context, obj interface{}) (model.PanelOption, error) {
	var it model.PanelOption
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "points":
			var err error
			it.Points, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "grIDs":
			var err error
			it.GrIDs, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "leftAxis":
			var err error
			it.LeftAxis, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPodLog(ctx context.Context, obj interface{}) (model.PodLog, error) {
	var it model.PodLog
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "clusterID":
			var err error
			it.ClusterID, err = ec.unmarshalNClusterIdentity2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐClusterIdentity(ctx, v)
			if err != nil {
				return it, err
			}
		case "requestID":
			var err error
			it.RequestID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowRunID":
			var err error
			it.WorkflowRunID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "podName":
			var err error
			it.PodName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "podType":
			var err error
			it.PodType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "log":
			var err error
			it.Log, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPodLogRequest(ctx context.Context, obj interface{}) (model.PodLogRequest, error) {
	var it model.PodLogRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "clusterID":
			var err error
			it.ClusterID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowRunID":
			var err error
			it.WorkflowRunID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "podName":
			var err error
			it.PodName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "podNamespace":
			var err error
			it.PodNamespace, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "podType":
			var err error
			it.PodType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "expPod":
			var err error
			it.ExpPod, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "runnerPod":
			var err error
			it.RunnerPod, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "chaosNamespace":
			var err error
			it.ChaosNamespace, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPromQuery(ctx context.Context, obj interface{}) (model.PromQuery, error) {
	var it model.PromQuery
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "queryID":
			var err error
			it.QueryID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "promQueryName":
			var err error
			it.PromQueryName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "legend":
			var err error
			it.Legend, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "resolution":
			var err error
			it.Resolution, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "minstep":
			var err error
			it.Minstep, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "line":
			var err error
			it.Line, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "closeArea":
			var err error
			it.CloseArea, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPromQueryInput(ctx context.Context, obj interface{}) (model.PromQueryInput, error) {
	var it model.PromQueryInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "queryID":
			var err error
			it.QueryID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "query":
			var err error
			it.Query, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "legend":
			var err error
			it.Legend, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "resolution":
			var err error
			it.Resolution, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "minstep":
			var err error
			it.Minstep, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPromSeriesInput(ctx context.Context, obj interface{}) (model.PromSeriesInput, error) {
	var it model.PromSeriesInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "series":
			var err error
			it.Series, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dsDetails":
			var err error
			it.DsDetails, err = ec.unmarshalNDsDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDsDetails(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPrometheusDataRequest(ctx context.Context, obj interface{}) (model.PrometheusDataRequest, error) {
	var it model.PrometheusDataRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "queries":
			var err error
			it.Queries, err = ec.unmarshalOPromQueryInput2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromQueryInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "dsDetails":
			var err error
			it.DsDetails, err = ec.unmarshalNDsDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDsDetails(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputQueryMapForPanel(ctx context.Context, obj interface{}) (model.QueryMapForPanel, error) {
	var it model.QueryMapForPanel
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "panelID":
			var err error
			it.PanelID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "queryIDs":
			var err error
			it.QueryIDs, err = ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputQueryMapForPanelGroup(ctx context.Context, obj interface{}) (model.QueryMapForPanelGroup, error) {
	var it model.QueryMapForPanelGroup
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "panelGroupID":
			var err error
			it.PanelGroupID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "panelQueryMap":
			var err error
			it.PanelQueryMap, err = ec.unmarshalNQueryMapForPanel2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐQueryMapForPanelᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRegisterClusterRequest(ctx context.Context, obj interface{}) (model.RegisterClusterRequest, error) {
	var it model.RegisterClusterRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "clusterName":
			var err error
			it.ClusterName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "platformName":
			var err error
			it.PlatformName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "clusterType":
			var err error
			it.ClusterType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentNamespace":
			var err error
			it.AgentNamespace, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "serviceAccount":
			var err error
			it.ServiceAccount, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentScope":
			var err error
			it.AgentScope, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentNsExists":
			var err error
			it.AgentNsExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "agentSaExists":
			var err error
			it.AgentSaExists, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "skipSsl":
			var err error
			it.SkipSsl, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "nodeSelector":
			var err error
			it.NodeSelector, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tolerations":
			var err error
			it.Tolerations, err = ec.unmarshalOToleration2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐToleration(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputResource(ctx context.Context, obj interface{}) (model.Resource, error) {
	var it model.Resource
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "kind":
			var err error
			it.Kind, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "names":
			var err error
			it.Names, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTemplateInput(ctx context.Context, obj interface{}) (model.TemplateInput, error) {
	var it model.TemplateInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "manifest":
			var err error
			it.Manifest, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "templateName":
			var err error
			it.TemplateName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "templateDescription":
			var err error
			it.TemplateDescription, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isCustomWorkflow":
			var err error
			it.IsCustomWorkflow, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputToleration(ctx context.Context, obj interface{}) (model.Toleration, error) {
	var it model.Toleration
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "tolerationSeconds":
			var err error
			it.TolerationSeconds, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "key":
			var err error
			it.Key, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "operator":
			var err error
			it.Operator, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "effect":
			var err error
			it.Effect, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error
			it.Value, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateChaosHubRequest(ctx context.Context, obj interface{}) (model.UpdateChaosHubRequest, error) {
	var it model.UpdateChaosHubRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hubName":
			var err error
			it.HubName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoURL":
			var err error
			it.RepoURL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repoBranch":
			var err error
			it.RepoBranch, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isPrivate":
			var err error
			it.IsPrivate, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "authType":
			var err error
			it.AuthType, err = ec.unmarshalNAuthType2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAuthType(ctx, v)
			if err != nil {
				return it, err
			}
		case "token":
			var err error
			it.Token, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "userName":
			var err error
			it.UserName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sshPrivateKey":
			var err error
			it.SSHPrivateKey, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "sshPublicKey":
			var err error
			it.SSHPublicKey, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateDBInput(ctx context.Context, obj interface{}) (model.UpdateDBInput, error) {
	var it model.UpdateDBInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "dbID":
			var err error
			it.DbID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dsID":
			var err error
			it.DsID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "dbName":
			var err error
			it.DbName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "dbTypeName":
			var err error
			it.DbTypeName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "dbTypeID":
			var err error
			it.DbTypeID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "dbInformation":
			var err error
			it.DbInformation, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "chaosEventQueryTemplate":
			var err error
			it.ChaosEventQueryTemplate, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "chaosVerdictQueryTemplate":
			var err error
			it.ChaosVerdictQueryTemplate, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "applicationMetadataMap":
			var err error
			it.ApplicationMetadataMap, err = ec.unmarshalOApplicationMetadata2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐApplicationMetadata(ctx, v)
			if err != nil {
				return it, err
			}
		case "panelGroups":
			var err error
			it.PanelGroups, err = ec.unmarshalOUpdatePanelGroupInput2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐUpdatePanelGroupInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "endTime":
			var err error
			it.EndTime, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "startTime":
			var err error
			it.StartTime, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "clusterID":
			var err error
			it.ClusterID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "refreshRate":
			var err error
			it.RefreshRate, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdatePanelGroupInput(ctx context.Context, obj interface{}) (model.UpdatePanelGroupInput, error) {
	var it model.UpdatePanelGroupInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "panelGroupName":
			var err error
			it.PanelGroupName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "panelGroupID":
			var err error
			it.PanelGroupID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "panels":
			var err error
			it.Panels, err = ec.unmarshalOPanel2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanel(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUsageDataRequest(ctx context.Context, obj interface{}) (model.UsageDataRequest, error) {
	var it model.UsageDataRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pagination":
			var err error
			it.Pagination, err = ec.unmarshalOPagination2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPagination(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateRange":
			var err error
			it.DateRange, err = ec.unmarshalNDateRange2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDateRange(ctx, v)
			if err != nil {
				return it, err
			}
		case "sort":
			var err error
			it.Sort, err = ec.unmarshalOUsageSortInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐUsageSortInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "searchProject":
			var err error
			it.SearchProject, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUsageSortInput(ctx context.Context, obj interface{}) (model.UsageSortInput, error) {
	var it model.UsageSortInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "field":
			var err error
			it.Field, err = ec.unmarshalNUsageSort2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐUsageSort(ctx, v)
			if err != nil {
				return it, err
			}
		case "descending":
			var err error
			it.Descending, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWeightagesInput(ctx context.Context, obj interface{}) (model.WeightagesInput, error) {
	var it model.WeightagesInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "experimentName":
			var err error
			it.ExperimentName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "weightage":
			var err error
			it.Weightage, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkflowFilterInput(ctx context.Context, obj interface{}) (model.WorkflowFilterInput, error) {
	var it model.WorkflowFilterInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "workflowName":
			var err error
			it.WorkflowName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "clusterName":
			var err error
			it.ClusterName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkflowRunFilterInput(ctx context.Context, obj interface{}) (model.WorkflowRunFilterInput, error) {
	var it model.WorkflowRunFilterInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "workflowName":
			var err error
			it.WorkflowName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "clusterName":
			var err error
			it.ClusterName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowStatus":
			var err error
			it.WorkflowStatus, err = ec.unmarshalOWorkflowRunStatus2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "dateRange":
			var err error
			it.DateRange, err = ec.unmarshalODateRange2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDateRange(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkflowRunRequest(ctx context.Context, obj interface{}) (model.WorkflowRunRequest, error) {
	var it model.WorkflowRunRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "workflowID":
			var err error
			it.WorkflowID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowRunID":
			var err error
			it.WorkflowRunID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowName":
			var err error
			it.WorkflowName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "executedBy":
			var err error
			it.ExecutedBy, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "executionData":
			var err error
			it.ExecutionData, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "clusterID":
			var err error
			it.ClusterID, err = ec.unmarshalNClusterIdentity2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐClusterIdentity(ctx, v)
			if err != nil {
				return it, err
			}
		case "completed":
			var err error
			it.Completed, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isRemoved":
			var err error
			it.IsRemoved, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkflowRunSortInput(ctx context.Context, obj interface{}) (model.WorkflowRunSortInput, error) {
	var it model.WorkflowRunSortInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "field":
			var err error
			it.Field, err = ec.unmarshalNWorkflowSortingField2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowSortingField(ctx, v)
			if err != nil {
				return it, err
			}
		case "descending":
			var err error
			it.Descending, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkflowRunStatsRequest(ctx context.Context, obj interface{}) (model.WorkflowRunStatsRequest, error) {
	var it model.WorkflowRunStatsRequest
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "projectID":
			var err error
			it.ProjectID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowIDs":
			var err error
			it.WorkflowIDs, err = ec.unmarshalOID2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkflowSortInput(ctx context.Context, obj interface{}) (model.WorkflowSortInput, error) {
	var it model.WorkflowSortInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "field":
			var err error
			it.Field, err = ec.unmarshalNWorkflowSortingField2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowSortingField(ctx, v)
			if err != nil {
				return it, err
			}
		case "descending":
			var err error
			it.Descending, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var actionPayloadImplementors = []string{"ActionPayload"}

func (ec *executionContext) _ActionPayload(ctx context.Context, sel ast.SelectionSet, obj *model.ActionPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, actionPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ActionPayload")
		case "requestType":
			out.Values[i] = ec._ActionPayload_requestType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "k8sManifest":
			out.Values[i] = ec._ActionPayload_k8sManifest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "namespace":
			out.Values[i] = ec._ActionPayload_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "externalData":
			out.Values[i] = ec._ActionPayload_externalData(ctx, field, obj)
		case "username":
			out.Values[i] = ec._ActionPayload_username(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var agentStatImplementors = []string{"AgentStat"}

func (ec *executionContext) _AgentStat(ctx context.Context, sel ast.SelectionSet, obj *model.AgentStat) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, agentStatImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AgentStat")
		case "ns":
			out.Values[i] = ec._AgentStat_ns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cluster":
			out.Values[i] = ec._AgentStat_cluster(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "total":
			out.Values[i] = ec._AgentStat_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "active":
			out.Values[i] = ec._AgentStat_active(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var annotationImplementors = []string{"Annotation"}

func (ec *executionContext) _Annotation(ctx context.Context, sel ast.SelectionSet, obj *model.Annotation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, annotationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Annotation")
		case "categories":
			out.Values[i] = ec._Annotation_categories(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "vendor":
			out.Values[i] = ec._Annotation_vendor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Annotation_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repository":
			out.Values[i] = ec._Annotation_repository(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "support":
			out.Values[i] = ec._Annotation_support(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "chartDescription":
			out.Values[i] = ec._Annotation_chartDescription(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var annotationsPromResponseImplementors = []string{"AnnotationsPromResponse"}

func (ec *executionContext) _AnnotationsPromResponse(ctx context.Context, sel ast.SelectionSet, obj *model.AnnotationsPromResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, annotationsPromResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AnnotationsPromResponse")
		case "queryID":
			out.Values[i] = ec._AnnotationsPromResponse_queryID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "legends":
			out.Values[i] = ec._AnnotationsPromResponse_legends(ctx, field, obj)
		case "tsvs":
			out.Values[i] = ec._AnnotationsPromResponse_tsvs(ctx, field, obj)
		case "subDataArray":
			out.Values[i] = ec._AnnotationsPromResponse_subDataArray(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var annotationsTimeStampValueImplementors = []string{"AnnotationsTimeStampValue"}

func (ec *executionContext) _AnnotationsTimeStampValue(ctx context.Context, sel ast.SelectionSet, obj *model.AnnotationsTimeStampValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, annotationsTimeStampValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AnnotationsTimeStampValue")
		case "date":
			out.Values[i] = ec._AnnotationsTimeStampValue_date(ctx, field, obj)
		case "value":
			out.Values[i] = ec._AnnotationsTimeStampValue_value(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var applicationMetadataResponseImplementors = []string{"ApplicationMetadataResponse"}

func (ec *executionContext) _ApplicationMetadataResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ApplicationMetadataResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationMetadataResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationMetadataResponse")
		case "namespace":
			out.Values[i] = ec._ApplicationMetadataResponse_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "applications":
			out.Values[i] = ec._ApplicationMetadataResponse_applications(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var chaosHubImplementors = []string{"ChaosHub"}

func (ec *executionContext) _ChaosHub(ctx context.Context, sel ast.SelectionSet, obj *model.ChaosHub) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chaosHubImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChaosHub")
		case "id":
			out.Values[i] = ec._ChaosHub_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repoURL":
			out.Values[i] = ec._ChaosHub_repoURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repoBranch":
			out.Values[i] = ec._ChaosHub_repoBranch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._ChaosHub_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hubName":
			out.Values[i] = ec._ChaosHub_hubName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hubType":
			out.Values[i] = ec._ChaosHub_hubType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isPrivate":
			out.Values[i] = ec._ChaosHub_isPrivate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "authType":
			out.Values[i] = ec._ChaosHub_authType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "token":
			out.Values[i] = ec._ChaosHub_token(ctx, field, obj)
		case "userName":
			out.Values[i] = ec._ChaosHub_userName(ctx, field, obj)
		case "password":
			out.Values[i] = ec._ChaosHub_password(ctx, field, obj)
		case "sshPrivateKey":
			out.Values[i] = ec._ChaosHub_sshPrivateKey(ctx, field, obj)
		case "isRemoved":
			out.Values[i] = ec._ChaosHub_isRemoved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ChaosHub_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._ChaosHub_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lastSyncedAt":
			out.Values[i] = ec._ChaosHub_lastSyncedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var chaosHubStatusImplementors = []string{"ChaosHubStatus"}

func (ec *executionContext) _ChaosHubStatus(ctx context.Context, sel ast.SelectionSet, obj *model.ChaosHubStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chaosHubStatusImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChaosHubStatus")
		case "id":
			out.Values[i] = ec._ChaosHubStatus_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repoURL":
			out.Values[i] = ec._ChaosHubStatus_repoURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repoBranch":
			out.Values[i] = ec._ChaosHubStatus_repoBranch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isAvailable":
			out.Values[i] = ec._ChaosHubStatus_isAvailable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalExp":
			out.Values[i] = ec._ChaosHubStatus_totalExp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hubName":
			out.Values[i] = ec._ChaosHubStatus_hubName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hubType":
			out.Values[i] = ec._ChaosHubStatus_hubType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isPrivate":
			out.Values[i] = ec._ChaosHubStatus_isPrivate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "authType":
			out.Values[i] = ec._ChaosHubStatus_authType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "token":
			out.Values[i] = ec._ChaosHubStatus_token(ctx, field, obj)
		case "userName":
			out.Values[i] = ec._ChaosHubStatus_userName(ctx, field, obj)
		case "password":
			out.Values[i] = ec._ChaosHubStatus_password(ctx, field, obj)
		case "isRemoved":
			out.Values[i] = ec._ChaosHubStatus_isRemoved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "sshPrivateKey":
			out.Values[i] = ec._ChaosHubStatus_sshPrivateKey(ctx, field, obj)
		case "sshPublicKey":
			out.Values[i] = ec._ChaosHubStatus_sshPublicKey(ctx, field, obj)
		case "lastSyncedAt":
			out.Values[i] = ec._ChaosHubStatus_lastSyncedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var chaosWorkFlowResponseImplementors = []string{"ChaosWorkFlowResponse"}

func (ec *executionContext) _ChaosWorkFlowResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ChaosWorkFlowResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chaosWorkFlowResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChaosWorkFlowResponse")
		case "workflowID":
			out.Values[i] = ec._ChaosWorkFlowResponse_workflowID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cronSyntax":
			out.Values[i] = ec._ChaosWorkFlowResponse_cronSyntax(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflowName":
			out.Values[i] = ec._ChaosWorkFlowResponse_workflowName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflowDescription":
			out.Values[i] = ec._ChaosWorkFlowResponse_workflowDescription(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isCustomWorkflow":
			out.Values[i] = ec._ChaosWorkFlowResponse_isCustomWorkflow(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var chartImplementors = []string{"Chart"}

func (ec *executionContext) _Chart(ctx context.Context, sel ast.SelectionSet, obj *model.Chart) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chartImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Chart")
		case "apiVersion":
			out.Values[i] = ec._Chart_apiVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "kind":
			out.Values[i] = ec._Chart_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "metadata":
			out.Values[i] = ec._Chart_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "spec":
			out.Values[i] = ec._Chart_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "packageInfo":
			out.Values[i] = ec._Chart_packageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var clusterImplementors = []string{"Cluster"}

func (ec *executionContext) _Cluster(ctx context.Context, sel ast.SelectionSet, obj *model.Cluster) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, clusterImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Cluster")
		case "clusterID":
			out.Values[i] = ec._Cluster_clusterID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._Cluster_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clusterName":
			out.Values[i] = ec._Cluster_clusterName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec._Cluster_description(ctx, field, obj)
		case "platformName":
			out.Values[i] = ec._Cluster_platformName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "accessKey":
			out.Values[i] = ec._Cluster_accessKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRegistered":
			out.Values[i] = ec._Cluster_isRegistered(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isClusterConfirmed":
			out.Values[i] = ec._Cluster_isClusterConfirmed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isActive":
			out.Values[i] = ec._Cluster_isActive(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Cluster_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Cluster_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clusterType":
			out.Values[i] = ec._Cluster_clusterType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "noOfSchedules":
			out.Values[i] = ec._Cluster_noOfSchedules(ctx, field, obj)
		case "noOfWorkflows":
			out.Values[i] = ec._Cluster_noOfWorkflows(ctx, field, obj)
		case "token":
			out.Values[i] = ec._Cluster_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "agentNamespace":
			out.Values[i] = ec._Cluster_agentNamespace(ctx, field, obj)
		case "serviceAccount":
			out.Values[i] = ec._Cluster_serviceAccount(ctx, field, obj)
		case "agentScope":
			out.Values[i] = ec._Cluster_agentScope(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "agentNsExists":
			out.Values[i] = ec._Cluster_agentNsExists(ctx, field, obj)
		case "agentSaExists":
			out.Values[i] = ec._Cluster_agentSaExists(ctx, field, obj)
		case "lastWorkflowTimestamp":
			out.Values[i] = ec._Cluster_lastWorkflowTimestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "startTime":
			out.Values[i] = ec._Cluster_startTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "version":
			out.Values[i] = ec._Cluster_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var clusterActionResponseImplementors = []string{"ClusterActionResponse"}

func (ec *executionContext) _ClusterActionResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ClusterActionResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, clusterActionResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClusterActionResponse")
		case "projectID":
			out.Values[i] = ec._ClusterActionResponse_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "action":
			out.Values[i] = ec._ClusterActionResponse_action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var clusterEventResponseImplementors = []string{"ClusterEventResponse"}

func (ec *executionContext) _ClusterEventResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ClusterEventResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, clusterEventResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClusterEventResponse")
		case "eventID":
			out.Values[i] = ec._ClusterEventResponse_eventID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "eventType":
			out.Values[i] = ec._ClusterEventResponse_eventType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "eventName":
			out.Values[i] = ec._ClusterEventResponse_eventName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec._ClusterEventResponse_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cluster":
			out.Values[i] = ec._ClusterEventResponse_cluster(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var confirmClusterRegistrationResponseImplementors = []string{"ConfirmClusterRegistrationResponse"}

func (ec *executionContext) _ConfirmClusterRegistrationResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ConfirmClusterRegistrationResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, confirmClusterRegistrationResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfirmClusterRegistrationResponse")
		case "isClusterConfirmed":
			out.Values[i] = ec._ConfirmClusterRegistrationResponse_isClusterConfirmed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "newAccessKey":
			out.Values[i] = ec._ConfirmClusterRegistrationResponse_newAccessKey(ctx, field, obj)
		case "clusterID":
			out.Values[i] = ec._ConfirmClusterRegistrationResponse_clusterID(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var dSResponseImplementors = []string{"DSResponse"}

func (ec *executionContext) _DSResponse(ctx context.Context, sel ast.SelectionSet, obj *model.DSResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dSResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DSResponse")
		case "dsID":
			out.Values[i] = ec._DSResponse_dsID(ctx, field, obj)
		case "dsName":
			out.Values[i] = ec._DSResponse_dsName(ctx, field, obj)
		case "dsType":
			out.Values[i] = ec._DSResponse_dsType(ctx, field, obj)
		case "dsURL":
			out.Values[i] = ec._DSResponse_dsURL(ctx, field, obj)
		case "accessType":
			out.Values[i] = ec._DSResponse_accessType(ctx, field, obj)
		case "authType":
			out.Values[i] = ec._DSResponse_authType(ctx, field, obj)
		case "basicAuthUsername":
			out.Values[i] = ec._DSResponse_basicAuthUsername(ctx, field, obj)
		case "basicAuthPassword":
			out.Values[i] = ec._DSResponse_basicAuthPassword(ctx, field, obj)
		case "scrapeInterval":
			out.Values[i] = ec._DSResponse_scrapeInterval(ctx, field, obj)
		case "queryTimeout":
			out.Values[i] = ec._DSResponse_queryTimeout(ctx, field, obj)
		case "httpMethod":
			out.Values[i] = ec._DSResponse_httpMethod(ctx, field, obj)
		case "projectID":
			out.Values[i] = ec._DSResponse_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "healthStatus":
			out.Values[i] = ec._DSResponse_healthStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._DSResponse_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._DSResponse_updatedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var dashboardPromResponseImplementors = []string{"DashboardPromResponse"}

func (ec *executionContext) _DashboardPromResponse(ctx context.Context, sel ast.SelectionSet, obj *model.DashboardPromResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dashboardPromResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DashboardPromResponse")
		case "dashboardMetricsResponse":
			out.Values[i] = ec._DashboardPromResponse_dashboardMetricsResponse(ctx, field, obj)
		case "annotationsResponse":
			out.Values[i] = ec._DashboardPromResponse_annotationsResponse(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var experimentDetailsImplementors = []string{"ExperimentDetails"}

func (ec *executionContext) _ExperimentDetails(ctx context.Context, sel ast.SelectionSet, obj *model.ExperimentDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, experimentDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExperimentDetails")
		case "engineDetails":
			out.Values[i] = ec._ExperimentDetails_engineDetails(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentDetails":
			out.Values[i] = ec._ExperimentDetails_experimentDetails(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var experimentsImplementors = []string{"Experiments"}

func (ec *executionContext) _Experiments(ctx context.Context, sel ast.SelectionSet, obj *model.Experiments) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, experimentsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Experiments")
		case "name":
			out.Values[i] = ec._Experiments_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CSV":
			out.Values[i] = ec._Experiments_CSV(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "desc":
			out.Values[i] = ec._Experiments_desc(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gitConfigResponseImplementors = []string{"GitConfigResponse"}

func (ec *executionContext) _GitConfigResponse(ctx context.Context, sel ast.SelectionSet, obj *model.GitConfigResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gitConfigResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GitConfigResponse")
		case "enabled":
			out.Values[i] = ec._GitConfigResponse_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._GitConfigResponse_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "branch":
			out.Values[i] = ec._GitConfigResponse_branch(ctx, field, obj)
		case "repoURL":
			out.Values[i] = ec._GitConfigResponse_repoURL(ctx, field, obj)
		case "authType":
			out.Values[i] = ec._GitConfigResponse_authType(ctx, field, obj)
		case "token":
			out.Values[i] = ec._GitConfigResponse_token(ctx, field, obj)
		case "userName":
			out.Values[i] = ec._GitConfigResponse_userName(ctx, field, obj)
		case "password":
			out.Values[i] = ec._GitConfigResponse_password(ctx, field, obj)
		case "sshPrivateKey":
			out.Values[i] = ec._GitConfigResponse_sshPrivateKey(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var heatmapDataResponseImplementors = []string{"HeatmapDataResponse"}

func (ec *executionContext) _HeatmapDataResponse(ctx context.Context, sel ast.SelectionSet, obj *model.HeatmapDataResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, heatmapDataResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HeatmapDataResponse")
		case "bins":
			out.Values[i] = ec._HeatmapDataResponse_bins(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var imageRegistryImplementors = []string{"ImageRegistry"}

func (ec *executionContext) _ImageRegistry(ctx context.Context, sel ast.SelectionSet, obj *model.ImageRegistry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageRegistryImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageRegistry")
		case "isDefault":
			out.Values[i] = ec._ImageRegistry_isDefault(ctx, field, obj)
		case "imageRegistryName":
			out.Values[i] = ec._ImageRegistry_imageRegistryName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "imageRepoName":
			out.Values[i] = ec._ImageRegistry_imageRepoName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "imageRegistryType":
			out.Values[i] = ec._ImageRegistry_imageRegistryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "secretName":
			out.Values[i] = ec._ImageRegistry_secretName(ctx, field, obj)
		case "secretNamespace":
			out.Values[i] = ec._ImageRegistry_secretNamespace(ctx, field, obj)
		case "enableRegistry":
			out.Values[i] = ec._ImageRegistry_enableRegistry(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var imageRegistryResponseImplementors = []string{"ImageRegistryResponse"}

func (ec *executionContext) _ImageRegistryResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ImageRegistryResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageRegistryResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageRegistryResponse")
		case "isDefault":
			out.Values[i] = ec._ImageRegistryResponse_isDefault(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "imageRegistryInfo":
			out.Values[i] = ec._ImageRegistryResponse_imageRegistryInfo(ctx, field, obj)
		case "imageRegistryID":
			out.Values[i] = ec._ImageRegistryResponse_imageRegistryID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._ImageRegistryResponse_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._ImageRegistryResponse_updatedAt(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._ImageRegistryResponse_createdAt(ctx, field, obj)
		case "isRemoved":
			out.Values[i] = ec._ImageRegistryResponse_isRemoved(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var kubeObjectResponseImplementors = []string{"KubeObjectResponse"}

func (ec *executionContext) _KubeObjectResponse(ctx context.Context, sel ast.SelectionSet, obj *model.KubeObjectResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kubeObjectResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KubeObjectResponse")
		case "clusterID":
			out.Values[i] = ec._KubeObjectResponse_clusterID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "kubeObj":
			out.Values[i] = ec._KubeObjectResponse_kubeObj(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var labelValueImplementors = []string{"LabelValue"}

func (ec *executionContext) _LabelValue(ctx context.Context, sel ast.SelectionSet, obj *model.LabelValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, labelValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LabelValue")
		case "label":
			out.Values[i] = ec._LabelValue_label(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "values":
			out.Values[i] = ec._LabelValue_values(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var linkImplementors = []string{"Link"}

func (ec *executionContext) _Link(ctx context.Context, sel ast.SelectionSet, obj *model.Link) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, linkImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Link")
		case "name":
			out.Values[i] = ec._Link_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "url":
			out.Values[i] = ec._Link_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var listDashboardResponseImplementors = []string{"ListDashboardResponse"}

func (ec *executionContext) _ListDashboardResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ListDashboardResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listDashboardResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListDashboardResponse")
		case "dsID":
			out.Values[i] = ec._ListDashboardResponse_dsID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dbID":
			out.Values[i] = ec._ListDashboardResponse_dbID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dbName":
			out.Values[i] = ec._ListDashboardResponse_dbName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dbTypeID":
			out.Values[i] = ec._ListDashboardResponse_dbTypeID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dbTypeName":
			out.Values[i] = ec._ListDashboardResponse_dbTypeName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dbInformation":
			out.Values[i] = ec._ListDashboardResponse_dbInformation(ctx, field, obj)
		case "chaosEventQueryTemplate":
			out.Values[i] = ec._ListDashboardResponse_chaosEventQueryTemplate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "chaosVerdictQueryTemplate":
			out.Values[i] = ec._ListDashboardResponse_chaosVerdictQueryTemplate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "applicationMetadataMap":
			out.Values[i] = ec._ListDashboardResponse_applicationMetadataMap(ctx, field, obj)
		case "clusterName":
			out.Values[i] = ec._ListDashboardResponse_clusterName(ctx, field, obj)
		case "dsName":
			out.Values[i] = ec._ListDashboardResponse_dsName(ctx, field, obj)
		case "dsType":
			out.Values[i] = ec._ListDashboardResponse_dsType(ctx, field, obj)
		case "dsURL":
			out.Values[i] = ec._ListDashboardResponse_dsURL(ctx, field, obj)
		case "dsHealthStatus":
			out.Values[i] = ec._ListDashboardResponse_dsHealthStatus(ctx, field, obj)
		case "panelGroups":
			out.Values[i] = ec._ListDashboardResponse_panelGroups(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "endTime":
			out.Values[i] = ec._ListDashboardResponse_endTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "startTime":
			out.Values[i] = ec._ListDashboardResponse_startTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "refreshRate":
			out.Values[i] = ec._ListDashboardResponse_refreshRate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._ListDashboardResponse_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clusterID":
			out.Values[i] = ec._ListDashboardResponse_clusterID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._ListDashboardResponse_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._ListDashboardResponse_updatedAt(ctx, field, obj)
		case "viewedAt":
			out.Values[i] = ec._ListDashboardResponse_viewedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var listWorkflowRunsResponseImplementors = []string{"ListWorkflowRunsResponse"}

func (ec *executionContext) _ListWorkflowRunsResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ListWorkflowRunsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listWorkflowRunsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListWorkflowRunsResponse")
		case "totalNoOfWorkflowRuns":
			out.Values[i] = ec._ListWorkflowRunsResponse_totalNoOfWorkflowRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflowRuns":
			out.Values[i] = ec._ListWorkflowRunsResponse_workflowRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var listWorkflowsResponseImplementors = []string{"ListWorkflowsResponse"}

func (ec *executionContext) _ListWorkflowsResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ListWorkflowsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listWorkflowsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListWorkflowsResponse")
		case "totalNoOfWorkflows":
			out.Values[i] = ec._ListWorkflowsResponse_totalNoOfWorkflows(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflows":
			out.Values[i] = ec._ListWorkflowsResponse_workflows(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var maintainerImplementors = []string{"Maintainer"}

func (ec *executionContext) _Maintainer(ctx context.Context, sel ast.SelectionSet, obj *model.Maintainer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, maintainerImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Maintainer")
		case "name":
			out.Values[i] = ec._Maintainer_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "email":
			out.Values[i] = ec._Maintainer_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var metadataImplementors = []string{"Metadata"}

func (ec *executionContext) _Metadata(ctx context.Context, sel ast.SelectionSet, obj *model.Metadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, metadataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Metadata")
		case "name":
			out.Values[i] = ec._Metadata_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "version":
			out.Values[i] = ec._Metadata_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "annotations":
			out.Values[i] = ec._Metadata_annotations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var metricDataForPanelImplementors = []string{"MetricDataForPanel"}

func (ec *executionContext) _MetricDataForPanel(ctx context.Context, sel ast.SelectionSet, obj *model.MetricDataForPanel) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, metricDataForPanelImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MetricDataForPanel")
		case "panelID":
			out.Values[i] = ec._MetricDataForPanel_panelID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "panelMetricsResponse":
			out.Values[i] = ec._MetricDataForPanel_panelMetricsResponse(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var metricDataForPanelGroupImplementors = []string{"MetricDataForPanelGroup"}

func (ec *executionContext) _MetricDataForPanelGroup(ctx context.Context, sel ast.SelectionSet, obj *model.MetricDataForPanelGroup) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, metricDataForPanelGroupImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MetricDataForPanelGroup")
		case "panelGroupID":
			out.Values[i] = ec._MetricDataForPanelGroup_panelGroupID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "panelGroupMetricsResponse":
			out.Values[i] = ec._MetricDataForPanelGroup_panelGroupMetricsResponse(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var metricsPromResponseImplementors = []string{"MetricsPromResponse"}

func (ec *executionContext) _MetricsPromResponse(ctx context.Context, sel ast.SelectionSet, obj *model.MetricsPromResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, metricsPromResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MetricsPromResponse")
		case "queryID":
			out.Values[i] = ec._MetricsPromResponse_queryID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "legends":
			out.Values[i] = ec._MetricsPromResponse_legends(ctx, field, obj)
		case "tsvs":
			out.Values[i] = ec._MetricsPromResponse_tsvs(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var metricsTimeStampValueImplementors = []string{"MetricsTimeStampValue"}

func (ec *executionContext) _MetricsTimeStampValue(ctx context.Context, sel ast.SelectionSet, obj *model.MetricsTimeStampValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, metricsTimeStampValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MetricsTimeStampValue")
		case "date":
			out.Values[i] = ec._MetricsTimeStampValue_date(ctx, field, obj)
		case "value":
			out.Values[i] = ec._MetricsTimeStampValue_value(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createChaosWorkFlow":
			out.Values[i] = ec._Mutation_createChaosWorkFlow(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "reRunChaosWorkFlow":
			out.Values[i] = ec._Mutation_reRunChaosWorkFlow(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateChaosWorkflow":
			out.Values[i] = ec._Mutation_updateChaosWorkflow(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteChaosWorkflow":
			out.Values[i] = ec._Mutation_deleteChaosWorkflow(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "terminateChaosWorkflow":
			out.Values[i] = ec._Mutation_terminateChaosWorkflow(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "chaosWorkflowRun":
			out.Values[i] = ec._Mutation_chaosWorkflowRun(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "syncWorkflowRun":
			out.Values[i] = ec._Mutation_syncWorkflowRun(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createDataSource":
			out.Values[i] = ec._Mutation_createDataSource(ctx, field)
		case "createDashBoard":
			out.Values[i] = ec._Mutation_createDashBoard(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateDataSource":
			out.Values[i] = ec._Mutation_updateDataSource(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateDashboard":
			out.Values[i] = ec._Mutation_updateDashboard(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatePanel":
			out.Values[i] = ec._Mutation_updatePanel(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteDashboard":
			out.Values[i] = ec._Mutation_deleteDashboard(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteDataSource":
			out.Values[i] = ec._Mutation_deleteDataSource(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "registerCluster":
			out.Values[i] = ec._Mutation_registerCluster(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "confirmClusterRegistration":
			out.Values[i] = ec._Mutation_confirmClusterRegistration(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "newClusterEvent":
			out.Values[i] = ec._Mutation_newClusterEvent(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteClusters":
			out.Values[i] = ec._Mutation_deleteClusters(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "podLog":
			out.Values[i] = ec._Mutation_podLog(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "kubeObj":
			out.Values[i] = ec._Mutation_kubeObj(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "gitopsNotifier":
			out.Values[i] = ec._Mutation_gitopsNotifier(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "enableGitOps":
			out.Values[i] = ec._Mutation_enableGitOps(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "disableGitOps":
			out.Values[i] = ec._Mutation_disableGitOps(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateGitOps":
			out.Values[i] = ec._Mutation_updateGitOps(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createImageRegistry":
			out.Values[i] = ec._Mutation_createImageRegistry(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateImageRegistry":
			out.Values[i] = ec._Mutation_updateImageRegistry(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteImageRegistry":
			out.Values[i] = ec._Mutation_deleteImageRegistry(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "addChaosHub":
			out.Values[i] = ec._Mutation_addChaosHub(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "addRemoteChaosHub":
			out.Values[i] = ec._Mutation_addRemoteChaosHub(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "saveChaosHub":
			out.Values[i] = ec._Mutation_saveChaosHub(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "syncChaosHub":
			out.Values[i] = ec._Mutation_syncChaosHub(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "generateSSHKey":
			out.Values[i] = ec._Mutation_generateSSHKey(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateChaosHub":
			out.Values[i] = ec._Mutation_updateChaosHub(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteChaosHub":
			out.Values[i] = ec._Mutation_deleteChaosHub(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createWorkflowTemplate":
			out.Values[i] = ec._Mutation_createWorkflowTemplate(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteWorkflowTemplate":
			out.Values[i] = ec._Mutation_deleteWorkflowTemplate(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var optionImplementors = []string{"Option"}

func (ec *executionContext) _Option(ctx context.Context, sel ast.SelectionSet, obj *model.Option) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, optionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Option")
		case "name":
			out.Values[i] = ec._Option_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var packageInformationImplementors = []string{"PackageInformation"}

func (ec *executionContext) _PackageInformation(ctx context.Context, sel ast.SelectionSet, obj *model.PackageInformation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, packageInformationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PackageInformation")
		case "packageName":
			out.Values[i] = ec._PackageInformation_packageName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experiments":
			out.Values[i] = ec._PackageInformation_experiments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var panelGroupResponseImplementors = []string{"PanelGroupResponse"}

func (ec *executionContext) _PanelGroupResponse(ctx context.Context, sel ast.SelectionSet, obj *model.PanelGroupResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, panelGroupResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PanelGroupResponse")
		case "panels":
			out.Values[i] = ec._PanelGroupResponse_panels(ctx, field, obj)
		case "panelGroupName":
			out.Values[i] = ec._PanelGroupResponse_panelGroupName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "panelGroupID":
			out.Values[i] = ec._PanelGroupResponse_panelGroupID(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var panelOptionResponseImplementors = []string{"PanelOptionResponse"}

func (ec *executionContext) _PanelOptionResponse(ctx context.Context, sel ast.SelectionSet, obj *model.PanelOptionResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, panelOptionResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PanelOptionResponse")
		case "points":
			out.Values[i] = ec._PanelOptionResponse_points(ctx, field, obj)
		case "grIDs":
			out.Values[i] = ec._PanelOptionResponse_grIDs(ctx, field, obj)
		case "leftAxis":
			out.Values[i] = ec._PanelOptionResponse_leftAxis(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var panelResponseImplementors = []string{"PanelResponse"}

func (ec *executionContext) _PanelResponse(ctx context.Context, sel ast.SelectionSet, obj *model.PanelResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, panelResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PanelResponse")
		case "panelID":
			out.Values[i] = ec._PanelResponse_panelID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "yAxisLeft":
			out.Values[i] = ec._PanelResponse_yAxisLeft(ctx, field, obj)
		case "yAxisRight":
			out.Values[i] = ec._PanelResponse_yAxisRight(ctx, field, obj)
		case "xAxisDown":
			out.Values[i] = ec._PanelResponse_xAxisDown(ctx, field, obj)
		case "unit":
			out.Values[i] = ec._PanelResponse_unit(ctx, field, obj)
		case "promQueries":
			out.Values[i] = ec._PanelResponse_promQueries(ctx, field, obj)
		case "panelOptions":
			out.Values[i] = ec._PanelResponse_panelOptions(ctx, field, obj)
		case "panelName":
			out.Values[i] = ec._PanelResponse_panelName(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._PanelResponse_createdAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var podLogResponseImplementors = []string{"PodLogResponse"}

func (ec *executionContext) _PodLogResponse(ctx context.Context, sel ast.SelectionSet, obj *model.PodLogResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, podLogResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PodLogResponse")
		case "workflowRunID":
			out.Values[i] = ec._PodLogResponse_workflowRunID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "podName":
			out.Values[i] = ec._PodLogResponse_podName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "podType":
			out.Values[i] = ec._PodLogResponse_podType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "log":
			out.Values[i] = ec._PodLogResponse_log(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var portalDashboardDataResponseImplementors = []string{"PortalDashboardDataResponse"}

func (ec *executionContext) _PortalDashboardDataResponse(ctx context.Context, sel ast.SelectionSet, obj *model.PortalDashboardDataResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, portalDashboardDataResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PortalDashboardDataResponse")
		case "name":
			out.Values[i] = ec._PortalDashboardDataResponse_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dashboardData":
			out.Values[i] = ec._PortalDashboardDataResponse_dashboardData(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var predefinedWorkflowListImplementors = []string{"PredefinedWorkflowList"}

func (ec *executionContext) _PredefinedWorkflowList(ctx context.Context, sel ast.SelectionSet, obj *model.PredefinedWorkflowList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, predefinedWorkflowListImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PredefinedWorkflowList")
		case "workflowName":
			out.Values[i] = ec._PredefinedWorkflowList_workflowName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflowCSV":
			out.Values[i] = ec._PredefinedWorkflowList_workflowCSV(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflowManifest":
			out.Values[i] = ec._PredefinedWorkflowList_workflowManifest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectDataImplementors = []string{"ProjectData"}

func (ec *executionContext) _ProjectData(ctx context.Context, sel ast.SelectionSet, obj *model.ProjectData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectDataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectData")
		case "workflows":
			out.Values[i] = ec._ProjectData_workflows(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "agents":
			out.Values[i] = ec._ProjectData_agents(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._ProjectData_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var promQueryResponseImplementors = []string{"PromQueryResponse"}

func (ec *executionContext) _PromQueryResponse(ctx context.Context, sel ast.SelectionSet, obj *model.PromQueryResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, promQueryResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PromQueryResponse")
		case "queryID":
			out.Values[i] = ec._PromQueryResponse_queryID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "promQueryName":
			out.Values[i] = ec._PromQueryResponse_promQueryName(ctx, field, obj)
		case "legend":
			out.Values[i] = ec._PromQueryResponse_legend(ctx, field, obj)
		case "resolution":
			out.Values[i] = ec._PromQueryResponse_resolution(ctx, field, obj)
		case "minstep":
			out.Values[i] = ec._PromQueryResponse_minstep(ctx, field, obj)
		case "line":
			out.Values[i] = ec._PromQueryResponse_line(ctx, field, obj)
		case "closeArea":
			out.Values[i] = ec._PromQueryResponse_closeArea(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var promSeriesListResponseImplementors = []string{"PromSeriesListResponse"}

func (ec *executionContext) _PromSeriesListResponse(ctx context.Context, sel ast.SelectionSet, obj *model.PromSeriesListResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, promSeriesListResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PromSeriesListResponse")
		case "seriesList":
			out.Values[i] = ec._PromSeriesListResponse_seriesList(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var promSeriesResponseImplementors = []string{"PromSeriesResponse"}

func (ec *executionContext) _PromSeriesResponse(ctx context.Context, sel ast.SelectionSet, obj *model.PromSeriesResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, promSeriesResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PromSeriesResponse")
		case "series":
			out.Values[i] = ec._PromSeriesResponse_series(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "labelValues":
			out.Values[i] = ec._PromSeriesResponse_labelValues(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var prometheusDataResponseImplementors = []string{"PrometheusDataResponse"}

func (ec *executionContext) _PrometheusDataResponse(ctx context.Context, sel ast.SelectionSet, obj *model.PrometheusDataResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, prometheusDataResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PrometheusDataResponse")
		case "metricsResponse":
			out.Values[i] = ec._PrometheusDataResponse_metricsResponse(ctx, field, obj)
		case "annotationsResponse":
			out.Values[i] = ec._PrometheusDataResponse_annotationsResponse(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var providerImplementors = []string{"Provider"}

func (ec *executionContext) _Provider(ctx context.Context, sel ast.SelectionSet, obj *model.Provider) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, providerImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Provider")
		case "name":
			out.Values[i] = ec._Provider_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "listWorkflows":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listWorkflows(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listWorkflowRuns":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listWorkflowRuns(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listHeatmapData":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listHeatmapData(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listWorkflowStats":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listWorkflowStats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getWorkflowRunStats":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getWorkflowRunStats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listDataSource":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listDataSource(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getPrometheusData":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getPrometheusData(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getPromLabelNamesAndValues":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getPromLabelNamesAndValues(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getPromSeriesList":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getPromSeriesList(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listDashboard":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listDashboard(ctx, field)
				return res
			})
		case "listPortalDashboardData":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listPortalDashboardData(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getServerVersion":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getServerVersion(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listClusters":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listClusters(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getAgentDetails":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getAgentDetails(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getManifest":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getManifest(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getGitOpsDetails":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getGitOpsDetails(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listImageRegistry":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listImageRegistry(ctx, field)
				return res
			})
		case "getImageRegistry":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getImageRegistry(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listCharts":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listCharts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getHubExperiment":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getHubExperiment(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listHubStatus":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listHubStatus(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getYAMLData":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getYAMLData(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getExperimentDetails":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getExperimentDetails(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listPredefinedWorkflows":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listPredefinedWorkflows(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getPredefinedExperimentYAML":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getPredefinedExperimentYAML(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getUsageData":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getUsageData(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "listWorkflowManifests":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listWorkflowManifests(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getWorkflowManifestByID":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getWorkflowManifestByID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var registerClusterResponseImplementors = []string{"RegisterClusterResponse"}

func (ec *executionContext) _RegisterClusterResponse(ctx context.Context, sel ast.SelectionSet, obj *model.RegisterClusterResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, registerClusterResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RegisterClusterResponse")
		case "token":
			out.Values[i] = ec._RegisterClusterResponse_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clusterID":
			out.Values[i] = ec._RegisterClusterResponse_clusterID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clusterName":
			out.Values[i] = ec._RegisterClusterResponse_clusterName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var resourceResponseImplementors = []string{"ResourceResponse"}

func (ec *executionContext) _ResourceResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ResourceResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceResponse")
		case "kind":
			out.Values[i] = ec._ResourceResponse_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "names":
			out.Values[i] = ec._ResourceResponse_names(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var sSHKeyImplementors = []string{"SSHKey"}

func (ec *executionContext) _SSHKey(ctx context.Context, sel ast.SelectionSet, obj *model.SSHKey) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sSHKeyImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SSHKey")
		case "publicKey":
			out.Values[i] = ec._SSHKey_publicKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "privateKey":
			out.Values[i] = ec._SSHKey_privateKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var serverVersionResponseImplementors = []string{"ServerVersionResponse"}

func (ec *executionContext) _ServerVersionResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ServerVersionResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serverVersionResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServerVersionResponse")
		case "key":
			out.Values[i] = ec._ServerVersionResponse_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":
			out.Values[i] = ec._ServerVersionResponse_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var specImplementors = []string{"Spec"}

func (ec *executionContext) _Spec(ctx context.Context, sel ast.SelectionSet, obj *model.Spec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, specImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Spec")
		case "displayName":
			out.Values[i] = ec._Spec_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "categoryDescription":
			out.Values[i] = ec._Spec_categoryDescription(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "keywords":
			out.Values[i] = ec._Spec_keywords(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maturity":
			out.Values[i] = ec._Spec_maturity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maintainers":
			out.Values[i] = ec._Spec_maintainers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "minKubeVersion":
			out.Values[i] = ec._Spec_minKubeVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "provider":
			out.Values[i] = ec._Spec_provider(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "links":
			out.Values[i] = ec._Spec_links(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experiments":
			out.Values[i] = ec._Spec_experiments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "chaosExpCRDLink":
			out.Values[i] = ec._Spec_chaosExpCRDLink(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "platforms":
			out.Values[i] = ec._Spec_platforms(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "chaosType":
			out.Values[i] = ec._Spec_chaosType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var subDataImplementors = []string{"SubData"}

func (ec *executionContext) _SubData(ctx context.Context, sel ast.SelectionSet, obj *model.SubData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subDataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SubData")
		case "date":
			out.Values[i] = ec._SubData_date(ctx, field, obj)
		case "value":
			out.Values[i] = ec._SubData_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "subDataName":
			out.Values[i] = ec._SubData_subDataName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func() graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "getWorkflowEvents":
		return ec._Subscription_getWorkflowEvents(ctx, fields[0])
	case "viewDashboard":
		return ec._Subscription_viewDashboard(ctx, fields[0])
	case "getClusterEvents":
		return ec._Subscription_getClusterEvents(ctx, fields[0])
	case "clusterConnect":
		return ec._Subscription_clusterConnect(ctx, fields[0])
	case "getPodLog":
		return ec._Subscription_getPodLog(ctx, fields[0])
	case "getKubeObject":
		return ec._Subscription_getKubeObject(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var totalCountImplementors = []string{"TotalCount"}

func (ec *executionContext) _TotalCount(ctx context.Context, sel ast.SelectionSet, obj *model.TotalCount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, totalCountImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TotalCount")
		case "projects":
			out.Values[i] = ec._TotalCount_projects(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "users":
			out.Values[i] = ec._TotalCount_users(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "agents":
			out.Values[i] = ec._TotalCount_agents(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflows":
			out.Values[i] = ec._TotalCount_workflows(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var usageDataResponseImplementors = []string{"UsageDataResponse"}

func (ec *executionContext) _UsageDataResponse(ctx context.Context, sel ast.SelectionSet, obj *model.UsageDataResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, usageDataResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UsageDataResponse")
		case "projects":
			out.Values[i] = ec._UsageDataResponse_projects(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalEntries":
			out.Values[i] = ec._UsageDataResponse_totalEntries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":
			out.Values[i] = ec._UsageDataResponse_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var weightagesImplementors = []string{"Weightages"}

func (ec *executionContext) _Weightages(ctx context.Context, sel ast.SelectionSet, obj *model.Weightages) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, weightagesImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Weightages")
		case "experimentName":
			out.Values[i] = ec._Weightages_experimentName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "weightage":
			out.Values[i] = ec._Weightages_weightage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var workflowImplementors = []string{"Workflow"}

func (ec *executionContext) _Workflow(ctx context.Context, sel ast.SelectionSet, obj *model.Workflow) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workflowImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Workflow")
		case "workflowID":
			out.Values[i] = ec._Workflow_workflowID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflowManifest":
			out.Values[i] = ec._Workflow_workflowManifest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cronSyntax":
			out.Values[i] = ec._Workflow_cronSyntax(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clusterName":
			out.Values[i] = ec._Workflow_clusterName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflowName":
			out.Values[i] = ec._Workflow_workflowName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflowDescription":
			out.Values[i] = ec._Workflow_workflowDescription(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "weightages":
			out.Values[i] = ec._Workflow_weightages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isCustomWorkflow":
			out.Values[i] = ec._Workflow_isCustomWorkflow(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Workflow_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Workflow_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._Workflow_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clusterID":
			out.Values[i] = ec._Workflow_clusterID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clusterType":
			out.Values[i] = ec._Workflow_clusterType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRemoved":
			out.Values[i] = ec._Workflow_isRemoved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lastUpdatedBy":
			out.Values[i] = ec._Workflow_lastUpdatedBy(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var workflowRunImplementors = []string{"WorkflowRun"}

func (ec *executionContext) _WorkflowRun(ctx context.Context, sel ast.SelectionSet, obj *model.WorkflowRun) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workflowRunImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkflowRun")
		case "workflowRunID":
			out.Values[i] = ec._WorkflowRun_workflowRunID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflowID":
			out.Values[i] = ec._WorkflowRun_workflowID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clusterName":
			out.Values[i] = ec._WorkflowRun_clusterName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "weightages":
			out.Values[i] = ec._WorkflowRun_weightages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lastUpdated":
			out.Values[i] = ec._WorkflowRun_lastUpdated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._WorkflowRun_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clusterID":
			out.Values[i] = ec._WorkflowRun_clusterID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflowName":
			out.Values[i] = ec._WorkflowRun_workflowName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clusterType":
			out.Values[i] = ec._WorkflowRun_clusterType(ctx, field, obj)
		case "phase":
			out.Values[i] = ec._WorkflowRun_phase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "resiliencyScore":
			out.Values[i] = ec._WorkflowRun_resiliencyScore(ctx, field, obj)
		case "experimentsPassed":
			out.Values[i] = ec._WorkflowRun_experimentsPassed(ctx, field, obj)
		case "experimentsFailed":
			out.Values[i] = ec._WorkflowRun_experimentsFailed(ctx, field, obj)
		case "experimentsAwaited":
			out.Values[i] = ec._WorkflowRun_experimentsAwaited(ctx, field, obj)
		case "experimentsStopped":
			out.Values[i] = ec._WorkflowRun_experimentsStopped(ctx, field, obj)
		case "experimentsNa":
			out.Values[i] = ec._WorkflowRun_experimentsNa(ctx, field, obj)
		case "totalExperiments":
			out.Values[i] = ec._WorkflowRun_totalExperiments(ctx, field, obj)
		case "executionData":
			out.Values[i] = ec._WorkflowRun_executionData(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRemoved":
			out.Values[i] = ec._WorkflowRun_isRemoved(ctx, field, obj)
		case "executedBy":
			out.Values[i] = ec._WorkflowRun_executedBy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var workflowRunDetailsImplementors = []string{"WorkflowRunDetails"}

func (ec *executionContext) _WorkflowRunDetails(ctx context.Context, sel ast.SelectionSet, obj *model.WorkflowRunDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workflowRunDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkflowRunDetails")
		case "noOfRuns":
			out.Values[i] = ec._WorkflowRunDetails_noOfRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dateStamp":
			out.Values[i] = ec._WorkflowRunDetails_dateStamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var workflowRunStatsResponseImplementors = []string{"WorkflowRunStatsResponse"}

func (ec *executionContext) _WorkflowRunStatsResponse(ctx context.Context, sel ast.SelectionSet, obj *model.WorkflowRunStatsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workflowRunStatsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkflowRunStatsResponse")
		case "totalWorkflowRuns":
			out.Values[i] = ec._WorkflowRunStatsResponse_totalWorkflowRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "succeededWorkflowRuns":
			out.Values[i] = ec._WorkflowRunStatsResponse_succeededWorkflowRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "failedWorkflowRuns":
			out.Values[i] = ec._WorkflowRunStatsResponse_failedWorkflowRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "runningWorkflowRuns":
			out.Values[i] = ec._WorkflowRunStatsResponse_runningWorkflowRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "averageResiliencyScore":
			out.Values[i] = ec._WorkflowRunStatsResponse_averageResiliencyScore(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalExperiments":
			out.Values[i] = ec._WorkflowRunStatsResponse_totalExperiments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentsPassed":
			out.Values[i] = ec._WorkflowRunStatsResponse_experimentsPassed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentsFailed":
			out.Values[i] = ec._WorkflowRunStatsResponse_experimentsFailed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentsAwaited":
			out.Values[i] = ec._WorkflowRunStatsResponse_experimentsAwaited(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentsStopped":
			out.Values[i] = ec._WorkflowRunStatsResponse_experimentsStopped(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experimentsNa":
			out.Values[i] = ec._WorkflowRunStatsResponse_experimentsNa(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "passedPercentage":
			out.Values[i] = ec._WorkflowRunStatsResponse_passedPercentage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "failedPercentage":
			out.Values[i] = ec._WorkflowRunStatsResponse_failedPercentage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflowRunSucceededPercentage":
			out.Values[i] = ec._WorkflowRunStatsResponse_workflowRunSucceededPercentage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workflowRunFailedPercentage":
			out.Values[i] = ec._WorkflowRunStatsResponse_workflowRunFailedPercentage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var workflowRunsDataImplementors = []string{"WorkflowRunsData"}

func (ec *executionContext) _WorkflowRunsData(ctx context.Context, sel ast.SelectionSet, obj *model.WorkflowRunsData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workflowRunsDataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkflowRunsData")
		case "value":
			out.Values[i] = ec._WorkflowRunsData_value(ctx, field, obj)
		case "workflowRunDetail":
			out.Values[i] = ec._WorkflowRunsData_workflowRunDetail(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var workflowStatImplementors = []string{"WorkflowStat"}

func (ec *executionContext) _WorkflowStat(ctx context.Context, sel ast.SelectionSet, obj *model.WorkflowStat) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workflowStatImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkflowStat")
		case "schedules":
			out.Values[i] = ec._WorkflowStat_schedules(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "runs":
			out.Values[i] = ec._WorkflowStat_runs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "expRuns":
			out.Values[i] = ec._WorkflowStat_expRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var workflowStatsResponseImplementors = []string{"WorkflowStatsResponse"}

func (ec *executionContext) _WorkflowStatsResponse(ctx context.Context, sel ast.SelectionSet, obj *model.WorkflowStatsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workflowStatsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkflowStatsResponse")
		case "date":
			out.Values[i] = ec._WorkflowStatsResponse_date(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":
			out.Values[i] = ec._WorkflowStatsResponse_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var workflowTemplateImplementors = []string{"WorkflowTemplate"}

func (ec *executionContext) _WorkflowTemplate(ctx context.Context, sel ast.SelectionSet, obj *model.WorkflowTemplate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workflowTemplateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkflowTemplate")
		case "templateID":
			out.Values[i] = ec._WorkflowTemplate_templateID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "manifest":
			out.Values[i] = ec._WorkflowTemplate_manifest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "templateName":
			out.Values[i] = ec._WorkflowTemplate_templateName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "templateDescription":
			out.Values[i] = ec._WorkflowTemplate_templateDescription(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectID":
			out.Values[i] = ec._WorkflowTemplate_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectName":
			out.Values[i] = ec._WorkflowTemplate_projectName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":
			out.Values[i] = ec._WorkflowTemplate_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRemoved":
			out.Values[i] = ec._WorkflowTemplate_isRemoved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isCustomWorkflow":
			out.Values[i] = ec._WorkflowTemplate_isCustomWorkflow(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNActionPayload2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐActionPayload(ctx context.Context, sel ast.SelectionSet, v model.ActionPayload) graphql.Marshaler {
	return ec._ActionPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNActionPayload2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐActionPayload(ctx context.Context, sel ast.SelectionSet, v *model.ActionPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ActionPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNAgentStat2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAgentStat(ctx context.Context, sel ast.SelectionSet, v model.AgentStat) graphql.Marshaler {
	return ec._AgentStat(ctx, sel, &v)
}

func (ec *executionContext) marshalNAgentStat2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAgentStat(ctx context.Context, sel ast.SelectionSet, v *model.AgentStat) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._AgentStat(ctx, sel, v)
}

func (ec *executionContext) marshalNAnnotation2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAnnotation(ctx context.Context, sel ast.SelectionSet, v model.Annotation) graphql.Marshaler {
	return ec._Annotation(ctx, sel, &v)
}

func (ec *executionContext) marshalNAnnotation2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAnnotation(ctx context.Context, sel ast.SelectionSet, v *model.Annotation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Annotation(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAuthType2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAuthType(ctx context.Context, v interface{}) (model.AuthType, error) {
	var res model.AuthType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNAuthType2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAuthType(ctx context.Context, sel ast.SelectionSet, v model.AuthType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNChaosHub2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChaosHub(ctx context.Context, sel ast.SelectionSet, v model.ChaosHub) graphql.Marshaler {
	return ec._ChaosHub(ctx, sel, &v)
}

func (ec *executionContext) marshalNChaosHub2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChaosHub(ctx context.Context, sel ast.SelectionSet, v *model.ChaosHub) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ChaosHub(ctx, sel, v)
}

func (ec *executionContext) marshalNChaosHubStatus2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChaosHubStatus(ctx context.Context, sel ast.SelectionSet, v []*model.ChaosHubStatus) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOChaosHubStatus2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChaosHubStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNChaosWorkFlowRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChaosWorkFlowRequest(ctx context.Context, v interface{}) (model.ChaosWorkFlowRequest, error) {
	return ec.unmarshalInputChaosWorkFlowRequest(ctx, v)
}

func (ec *executionContext) marshalNChaosWorkFlowResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChaosWorkFlowResponse(ctx context.Context, sel ast.SelectionSet, v model.ChaosWorkFlowResponse) graphql.Marshaler {
	return ec._ChaosWorkFlowResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNChaosWorkFlowResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChaosWorkFlowResponse(ctx context.Context, sel ast.SelectionSet, v *model.ChaosWorkFlowResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ChaosWorkFlowResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNChart2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChart(ctx context.Context, sel ast.SelectionSet, v model.Chart) graphql.Marshaler {
	return ec._Chart(ctx, sel, &v)
}

func (ec *executionContext) marshalNChart2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChartᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Chart) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChart2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChart(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNChart2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChart(ctx context.Context, sel ast.SelectionSet, v *model.Chart) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Chart(ctx, sel, v)
}

func (ec *executionContext) marshalNCluster2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐCluster(ctx context.Context, sel ast.SelectionSet, v model.Cluster) graphql.Marshaler {
	return ec._Cluster(ctx, sel, &v)
}

func (ec *executionContext) marshalNCluster2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐClusterᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Cluster) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCluster2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐCluster(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNCluster2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐCluster(ctx context.Context, sel ast.SelectionSet, v *model.Cluster) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Cluster(ctx, sel, v)
}

func (ec *executionContext) marshalNClusterActionResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐClusterActionResponse(ctx context.Context, sel ast.SelectionSet, v model.ClusterActionResponse) graphql.Marshaler {
	return ec._ClusterActionResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNClusterActionResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐClusterActionResponse(ctx context.Context, sel ast.SelectionSet, v *model.ClusterActionResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ClusterActionResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNClusterEventResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐClusterEventResponse(ctx context.Context, sel ast.SelectionSet, v model.ClusterEventResponse) graphql.Marshaler {
	return ec._ClusterEventResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNClusterEventResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐClusterEventResponse(ctx context.Context, sel ast.SelectionSet, v *model.ClusterEventResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ClusterEventResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNClusterIdentity2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐClusterIdentity(ctx context.Context, v interface{}) (model.ClusterIdentity, error) {
	return ec.unmarshalInputClusterIdentity(ctx, v)
}

func (ec *executionContext) unmarshalNClusterIdentity2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐClusterIdentity(ctx context.Context, v interface{}) (*model.ClusterIdentity, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNClusterIdentity2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐClusterIdentity(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalNConfirmClusterRegistrationResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐConfirmClusterRegistrationResponse(ctx context.Context, sel ast.SelectionSet, v model.ConfirmClusterRegistrationResponse) graphql.Marshaler {
	return ec._ConfirmClusterRegistrationResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNConfirmClusterRegistrationResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐConfirmClusterRegistrationResponse(ctx context.Context, sel ast.SelectionSet, v *model.ConfirmClusterRegistrationResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ConfirmClusterRegistrationResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateChaosHubRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐCreateChaosHubRequest(ctx context.Context, v interface{}) (model.CreateChaosHubRequest, error) {
	return ec.unmarshalInputCreateChaosHubRequest(ctx, v)
}

func (ec *executionContext) unmarshalNCreateRemoteMyHub2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐCreateRemoteMyHub(ctx context.Context, v interface{}) (model.CreateRemoteMyHub, error) {
	return ec.unmarshalInputCreateRemoteMyHub(ctx, v)
}

func (ec *executionContext) unmarshalNDSInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDSInput(ctx context.Context, v interface{}) (model.DSInput, error) {
	return ec.unmarshalInputDSInput(ctx, v)
}

func (ec *executionContext) marshalNDSResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDSResponse(ctx context.Context, sel ast.SelectionSet, v model.DSResponse) graphql.Marshaler {
	return ec._DSResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNDSResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDSResponse(ctx context.Context, sel ast.SelectionSet, v []*model.DSResponse) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODSResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDSResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNDSResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDSResponse(ctx context.Context, sel ast.SelectionSet, v *model.DSResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._DSResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNDashboardPromResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDashboardPromResponse(ctx context.Context, sel ast.SelectionSet, v model.DashboardPromResponse) graphql.Marshaler {
	return ec._DashboardPromResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNDashboardPromResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDashboardPromResponse(ctx context.Context, sel ast.SelectionSet, v *model.DashboardPromResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._DashboardPromResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDataVars2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDataVars(ctx context.Context, v interface{}) (model.DataVars, error) {
	return ec.unmarshalInputDataVars(ctx, v)
}

func (ec *executionContext) unmarshalNDateRange2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDateRange(ctx context.Context, v interface{}) (model.DateRange, error) {
	return ec.unmarshalInputDateRange(ctx, v)
}

func (ec *executionContext) unmarshalNDateRange2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDateRange(ctx context.Context, v interface{}) (*model.DateRange, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNDateRange2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDateRange(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNDeleteDSInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDeleteDSInput(ctx context.Context, v interface{}) (model.DeleteDSInput, error) {
	return ec.unmarshalInputDeleteDSInput(ctx, v)
}

func (ec *executionContext) unmarshalNDsDetails2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDsDetails(ctx context.Context, v interface{}) (model.DsDetails, error) {
	return ec.unmarshalInputDsDetails(ctx, v)
}

func (ec *executionContext) unmarshalNDsDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDsDetails(ctx context.Context, v interface{}) (*model.DsDetails, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNDsDetails2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDsDetails(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalNExperimentDetails2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐExperimentDetails(ctx context.Context, sel ast.SelectionSet, v model.ExperimentDetails) graphql.Marshaler {
	return ec._ExperimentDetails(ctx, sel, &v)
}

func (ec *executionContext) marshalNExperimentDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐExperimentDetails(ctx context.Context, sel ast.SelectionSet, v *model.ExperimentDetails) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ExperimentDetails(ctx, sel, v)
}

func (ec *executionContext) unmarshalNExperimentRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐExperimentRequest(ctx context.Context, v interface{}) (model.ExperimentRequest, error) {
	return ec.unmarshalInputExperimentRequest(ctx, v)
}

func (ec *executionContext) marshalNExperiments2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐExperiments(ctx context.Context, sel ast.SelectionSet, v model.Experiments) graphql.Marshaler {
	return ec._Experiments(ctx, sel, &v)
}

func (ec *executionContext) marshalNExperiments2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐExperimentsᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Experiments) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExperiments2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐExperiments(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNExperiments2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐExperiments(ctx context.Context, sel ast.SelectionSet, v *model.Experiments) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Experiments(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	return graphql.UnmarshalFloat(v)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloat(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNGitConfig2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐGitConfig(ctx context.Context, v interface{}) (model.GitConfig, error) {
	return ec.unmarshalInputGitConfig(ctx, v)
}

func (ec *executionContext) marshalNGitConfigResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐGitConfigResponse(ctx context.Context, sel ast.SelectionSet, v model.GitConfigResponse) graphql.Marshaler {
	return ec._GitConfigResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNGitConfigResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐGitConfigResponse(ctx context.Context, sel ast.SelectionSet, v *model.GitConfigResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._GitConfigResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNHeatmapDataResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐHeatmapDataResponse(ctx context.Context, sel ast.SelectionSet, v []*model.HeatmapDataResponse) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOHeatmapDataResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐHeatmapDataResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNHubType2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐHubType(ctx context.Context, v interface{}) (model.HubType, error) {
	var res model.HubType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNHubType2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐHubType(ctx context.Context, sel ast.SelectionSet, v model.HubType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNImageRegistryInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐImageRegistryInput(ctx context.Context, v interface{}) (model.ImageRegistryInput, error) {
	return ec.unmarshalInputImageRegistryInput(ctx, v)
}

func (ec *executionContext) marshalNImageRegistryResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐImageRegistryResponse(ctx context.Context, sel ast.SelectionSet, v model.ImageRegistryResponse) graphql.Marshaler {
	return ec._ImageRegistryResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageRegistryResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐImageRegistryResponse(ctx context.Context, sel ast.SelectionSet, v *model.ImageRegistryResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ImageRegistryResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNKubeGVRRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐKubeGVRRequest(ctx context.Context, v interface{}) (model.KubeGVRRequest, error) {
	return ec.unmarshalInputKubeGVRRequest(ctx, v)
}

func (ec *executionContext) unmarshalNKubeGVRRequest2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐKubeGVRRequest(ctx context.Context, v interface{}) (*model.KubeGVRRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNKubeGVRRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐKubeGVRRequest(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNKubeObjectData2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐKubeObjectData(ctx context.Context, v interface{}) (model.KubeObjectData, error) {
	return ec.unmarshalInputKubeObjectData(ctx, v)
}

func (ec *executionContext) unmarshalNKubeObjectRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐKubeObjectRequest(ctx context.Context, v interface{}) (model.KubeObjectRequest, error) {
	return ec.unmarshalInputKubeObjectRequest(ctx, v)
}

func (ec *executionContext) marshalNKubeObjectResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐKubeObjectResponse(ctx context.Context, sel ast.SelectionSet, v model.KubeObjectResponse) graphql.Marshaler {
	return ec._KubeObjectResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNKubeObjectResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐKubeObjectResponse(ctx context.Context, sel ast.SelectionSet, v *model.KubeObjectResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._KubeObjectResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNLink2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐLink(ctx context.Context, sel ast.SelectionSet, v model.Link) graphql.Marshaler {
	return ec._Link(ctx, sel, &v)
}

func (ec *executionContext) marshalNLink2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐLinkᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Link) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLink2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐLink(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNLink2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐLink(ctx context.Context, sel ast.SelectionSet, v *model.Link) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Link(ctx, sel, v)
}

func (ec *executionContext) marshalNListDashboardResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐListDashboardResponse(ctx context.Context, sel ast.SelectionSet, v model.ListDashboardResponse) graphql.Marshaler {
	return ec._ListDashboardResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNListDashboardResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐListDashboardResponse(ctx context.Context, sel ast.SelectionSet, v *model.ListDashboardResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ListDashboardResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNListWorkflowRunsRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐListWorkflowRunsRequest(ctx context.Context, v interface{}) (model.ListWorkflowRunsRequest, error) {
	return ec.unmarshalInputListWorkflowRunsRequest(ctx, v)
}

func (ec *executionContext) marshalNListWorkflowRunsResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐListWorkflowRunsResponse(ctx context.Context, sel ast.SelectionSet, v model.ListWorkflowRunsResponse) graphql.Marshaler {
	return ec._ListWorkflowRunsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNListWorkflowRunsResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐListWorkflowRunsResponse(ctx context.Context, sel ast.SelectionSet, v *model.ListWorkflowRunsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ListWorkflowRunsResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNListWorkflowsRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐListWorkflowsRequest(ctx context.Context, v interface{}) (model.ListWorkflowsRequest, error) {
	return ec.unmarshalInputListWorkflowsRequest(ctx, v)
}

func (ec *executionContext) marshalNListWorkflowsResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐListWorkflowsResponse(ctx context.Context, sel ast.SelectionSet, v model.ListWorkflowsResponse) graphql.Marshaler {
	return ec._ListWorkflowsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNListWorkflowsResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐListWorkflowsResponse(ctx context.Context, sel ast.SelectionSet, v *model.ListWorkflowsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ListWorkflowsResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNMaintainer2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMaintainer(ctx context.Context, sel ast.SelectionSet, v model.Maintainer) graphql.Marshaler {
	return ec._Maintainer(ctx, sel, &v)
}

func (ec *executionContext) marshalNMaintainer2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMaintainerᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Maintainer) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMaintainer2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMaintainer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNMaintainer2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMaintainer(ctx context.Context, sel ast.SelectionSet, v *model.Maintainer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Maintainer(ctx, sel, v)
}

func (ec *executionContext) marshalNMetadata2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetadata(ctx context.Context, sel ast.SelectionSet, v model.Metadata) graphql.Marshaler {
	return ec._Metadata(ctx, sel, &v)
}

func (ec *executionContext) marshalNMetadata2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetadata(ctx context.Context, sel ast.SelectionSet, v *model.Metadata) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Metadata(ctx, sel, v)
}

func (ec *executionContext) unmarshalNNewClusterEventRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐNewClusterEventRequest(ctx context.Context, v interface{}) (model.NewClusterEventRequest, error) {
	return ec.unmarshalInputNewClusterEventRequest(ctx, v)
}

func (ec *executionContext) marshalNPackageInformation2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPackageInformation(ctx context.Context, sel ast.SelectionSet, v model.PackageInformation) graphql.Marshaler {
	return ec._PackageInformation(ctx, sel, &v)
}

func (ec *executionContext) marshalNPackageInformation2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPackageInformation(ctx context.Context, sel ast.SelectionSet, v *model.PackageInformation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PackageInformation(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPanelGroup2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanelGroup(ctx context.Context, v interface{}) ([]*model.PanelGroup, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.PanelGroup, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOPanelGroup2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanelGroup(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNPanelGroupResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanelGroupResponse(ctx context.Context, sel ast.SelectionSet, v []*model.PanelGroupResponse) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPanelGroupResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanelGroupResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNPodLog2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPodLog(ctx context.Context, v interface{}) (model.PodLog, error) {
	return ec.unmarshalInputPodLog(ctx, v)
}

func (ec *executionContext) unmarshalNPodLogRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPodLogRequest(ctx context.Context, v interface{}) (model.PodLogRequest, error) {
	return ec.unmarshalInputPodLogRequest(ctx, v)
}

func (ec *executionContext) marshalNPodLogResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPodLogResponse(ctx context.Context, sel ast.SelectionSet, v model.PodLogResponse) graphql.Marshaler {
	return ec._PodLogResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNPodLogResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPodLogResponse(ctx context.Context, sel ast.SelectionSet, v *model.PodLogResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PodLogResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNPortalDashboardDataResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPortalDashboardDataResponse(ctx context.Context, sel ast.SelectionSet, v model.PortalDashboardDataResponse) graphql.Marshaler {
	return ec._PortalDashboardDataResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNPortalDashboardDataResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPortalDashboardDataResponseᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.PortalDashboardDataResponse) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPortalDashboardDataResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPortalDashboardDataResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNPortalDashboardDataResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPortalDashboardDataResponse(ctx context.Context, sel ast.SelectionSet, v *model.PortalDashboardDataResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PortalDashboardDataResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNPredefinedWorkflowList2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPredefinedWorkflowList(ctx context.Context, sel ast.SelectionSet, v model.PredefinedWorkflowList) graphql.Marshaler {
	return ec._PredefinedWorkflowList(ctx, sel, &v)
}

func (ec *executionContext) marshalNPredefinedWorkflowList2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPredefinedWorkflowListᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.PredefinedWorkflowList) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPredefinedWorkflowList2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPredefinedWorkflowList(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNPredefinedWorkflowList2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPredefinedWorkflowList(ctx context.Context, sel ast.SelectionSet, v *model.PredefinedWorkflowList) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PredefinedWorkflowList(ctx, sel, v)
}

func (ec *executionContext) marshalNProjectData2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐProjectData(ctx context.Context, sel ast.SelectionSet, v []*model.ProjectData) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOProjectData2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐProjectData(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNPromQueryInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromQueryInput(ctx context.Context, v interface{}) (model.PromQueryInput, error) {
	return ec.unmarshalInputPromQueryInput(ctx, v)
}

func (ec *executionContext) unmarshalNPromQueryInput2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromQueryInputᚄ(ctx context.Context, v interface{}) ([]*model.PromQueryInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.PromQueryInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNPromQueryInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromQueryInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNPromQueryInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromQueryInput(ctx context.Context, v interface{}) (*model.PromQueryInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNPromQueryInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromQueryInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalNPromSeriesListResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromSeriesListResponse(ctx context.Context, sel ast.SelectionSet, v model.PromSeriesListResponse) graphql.Marshaler {
	return ec._PromSeriesListResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNPromSeriesListResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromSeriesListResponse(ctx context.Context, sel ast.SelectionSet, v *model.PromSeriesListResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PromSeriesListResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNPromSeriesResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromSeriesResponse(ctx context.Context, sel ast.SelectionSet, v model.PromSeriesResponse) graphql.Marshaler {
	return ec._PromSeriesResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNPromSeriesResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromSeriesResponse(ctx context.Context, sel ast.SelectionSet, v *model.PromSeriesResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PromSeriesResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNPrometheusDataResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPrometheusDataResponse(ctx context.Context, sel ast.SelectionSet, v model.PrometheusDataResponse) graphql.Marshaler {
	return ec._PrometheusDataResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNPrometheusDataResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPrometheusDataResponse(ctx context.Context, sel ast.SelectionSet, v *model.PrometheusDataResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PrometheusDataResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNProvider2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐProvider(ctx context.Context, sel ast.SelectionSet, v model.Provider) graphql.Marshaler {
	return ec._Provider(ctx, sel, &v)
}

func (ec *executionContext) marshalNProvider2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐProvider(ctx context.Context, sel ast.SelectionSet, v *model.Provider) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Provider(ctx, sel, v)
}

func (ec *executionContext) unmarshalNQueryMapForPanel2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐQueryMapForPanel(ctx context.Context, v interface{}) (model.QueryMapForPanel, error) {
	return ec.unmarshalInputQueryMapForPanel(ctx, v)
}

func (ec *executionContext) unmarshalNQueryMapForPanel2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐQueryMapForPanelᚄ(ctx context.Context, v interface{}) ([]*model.QueryMapForPanel, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.QueryMapForPanel, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNQueryMapForPanel2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐQueryMapForPanel(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNQueryMapForPanel2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐQueryMapForPanel(ctx context.Context, v interface{}) (*model.QueryMapForPanel, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNQueryMapForPanel2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐQueryMapForPanel(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNQueryMapForPanelGroup2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐQueryMapForPanelGroup(ctx context.Context, v interface{}) (model.QueryMapForPanelGroup, error) {
	return ec.unmarshalInputQueryMapForPanelGroup(ctx, v)
}

func (ec *executionContext) unmarshalNQueryMapForPanelGroup2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐQueryMapForPanelGroupᚄ(ctx context.Context, v interface{}) ([]*model.QueryMapForPanelGroup, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.QueryMapForPanelGroup, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNQueryMapForPanelGroup2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐQueryMapForPanelGroup(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNQueryMapForPanelGroup2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐQueryMapForPanelGroup(ctx context.Context, v interface{}) (*model.QueryMapForPanelGroup, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNQueryMapForPanelGroup2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐQueryMapForPanelGroup(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNRegisterClusterRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐRegisterClusterRequest(ctx context.Context, v interface{}) (model.RegisterClusterRequest, error) {
	return ec.unmarshalInputRegisterClusterRequest(ctx, v)
}

func (ec *executionContext) marshalNRegisterClusterResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐRegisterClusterResponse(ctx context.Context, sel ast.SelectionSet, v model.RegisterClusterResponse) graphql.Marshaler {
	return ec._RegisterClusterResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNRegisterClusterResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐRegisterClusterResponse(ctx context.Context, sel ast.SelectionSet, v *model.RegisterClusterResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._RegisterClusterResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNSSHKey2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐSSHKey(ctx context.Context, sel ast.SelectionSet, v model.SSHKey) graphql.Marshaler {
	return ec._SSHKey(ctx, sel, &v)
}

func (ec *executionContext) marshalNSSHKey2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐSSHKey(ctx context.Context, sel ast.SelectionSet, v *model.SSHKey) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._SSHKey(ctx, sel, v)
}

func (ec *executionContext) marshalNServerVersionResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐServerVersionResponse(ctx context.Context, sel ast.SelectionSet, v model.ServerVersionResponse) graphql.Marshaler {
	return ec._ServerVersionResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNServerVersionResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐServerVersionResponse(ctx context.Context, sel ast.SelectionSet, v *model.ServerVersionResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ServerVersionResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNSpec2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐSpec(ctx context.Context, sel ast.SelectionSet, v model.Spec) graphql.Marshaler {
	return ec._Spec(ctx, sel, &v)
}

func (ec *executionContext) marshalNSpec2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐSpec(ctx context.Context, sel ast.SelectionSet, v *model.Spec) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Spec(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNString2ᚕᚖstring(ctx context.Context, v interface{}) ([]*string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOString2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕᚖstring(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2ᚖstring(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNTimeFrequency2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐTimeFrequency(ctx context.Context, v interface{}) (model.TimeFrequency, error) {
	var res model.TimeFrequency
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNTimeFrequency2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐTimeFrequency(ctx context.Context, sel ast.SelectionSet, v model.TimeFrequency) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTotalCount2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐTotalCount(ctx context.Context, sel ast.SelectionSet, v model.TotalCount) graphql.Marshaler {
	return ec._TotalCount(ctx, sel, &v)
}

func (ec *executionContext) marshalNTotalCount2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐTotalCount(ctx context.Context, sel ast.SelectionSet, v *model.TotalCount) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TotalCount(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateChaosHubRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐUpdateChaosHubRequest(ctx context.Context, v interface{}) (model.UpdateChaosHubRequest, error) {
	return ec.unmarshalInputUpdateChaosHubRequest(ctx, v)
}

func (ec *executionContext) unmarshalNUpdateDBInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐUpdateDBInput(ctx context.Context, v interface{}) (model.UpdateDBInput, error) {
	return ec.unmarshalInputUpdateDBInput(ctx, v)
}

func (ec *executionContext) unmarshalNUsageDataRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐUsageDataRequest(ctx context.Context, v interface{}) (model.UsageDataRequest, error) {
	return ec.unmarshalInputUsageDataRequest(ctx, v)
}

func (ec *executionContext) marshalNUsageDataResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐUsageDataResponse(ctx context.Context, sel ast.SelectionSet, v model.UsageDataResponse) graphql.Marshaler {
	return ec._UsageDataResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUsageDataResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐUsageDataResponse(ctx context.Context, sel ast.SelectionSet, v *model.UsageDataResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._UsageDataResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUsageSort2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐUsageSort(ctx context.Context, v interface{}) (model.UsageSort, error) {
	var res model.UsageSort
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNUsageSort2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐUsageSort(ctx context.Context, sel ast.SelectionSet, v model.UsageSort) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNWeightages2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWeightages(ctx context.Context, sel ast.SelectionSet, v model.Weightages) graphql.Marshaler {
	return ec._Weightages(ctx, sel, &v)
}

func (ec *executionContext) marshalNWeightages2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWeightagesᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Weightages) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWeightages2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWeightages(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNWeightages2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWeightages(ctx context.Context, sel ast.SelectionSet, v *model.Weightages) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Weightages(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWeightagesInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWeightagesInput(ctx context.Context, v interface{}) (model.WeightagesInput, error) {
	return ec.unmarshalInputWeightagesInput(ctx, v)
}

func (ec *executionContext) unmarshalNWeightagesInput2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWeightagesInputᚄ(ctx context.Context, v interface{}) ([]*model.WeightagesInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.WeightagesInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNWeightagesInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWeightagesInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNWeightagesInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWeightagesInput(ctx context.Context, v interface{}) (*model.WeightagesInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNWeightagesInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWeightagesInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalNWorkflow2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflow(ctx context.Context, sel ast.SelectionSet, v []*model.Workflow) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOWorkflow2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflow(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNWorkflowRun2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRun(ctx context.Context, sel ast.SelectionSet, v model.WorkflowRun) graphql.Marshaler {
	return ec._WorkflowRun(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkflowRun2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRun(ctx context.Context, sel ast.SelectionSet, v []*model.WorkflowRun) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOWorkflowRun2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRun(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNWorkflowRun2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRun(ctx context.Context, sel ast.SelectionSet, v *model.WorkflowRun) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._WorkflowRun(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWorkflowRunRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunRequest(ctx context.Context, v interface{}) (model.WorkflowRunRequest, error) {
	return ec.unmarshalInputWorkflowRunRequest(ctx, v)
}

func (ec *executionContext) unmarshalNWorkflowRunStatsRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunStatsRequest(ctx context.Context, v interface{}) (model.WorkflowRunStatsRequest, error) {
	return ec.unmarshalInputWorkflowRunStatsRequest(ctx, v)
}

func (ec *executionContext) marshalNWorkflowRunStatsResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunStatsResponse(ctx context.Context, sel ast.SelectionSet, v model.WorkflowRunStatsResponse) graphql.Marshaler {
	return ec._WorkflowRunStatsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkflowRunStatsResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunStatsResponse(ctx context.Context, sel ast.SelectionSet, v *model.WorkflowRunStatsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._WorkflowRunStatsResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNWorkflowRunsData2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunsData(ctx context.Context, sel ast.SelectionSet, v []*model.WorkflowRunsData) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOWorkflowRunsData2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunsData(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNWorkflowSortingField2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowSortingField(ctx context.Context, v interface{}) (model.WorkflowSortingField, error) {
	var res model.WorkflowSortingField
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNWorkflowSortingField2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowSortingField(ctx context.Context, sel ast.SelectionSet, v model.WorkflowSortingField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNWorkflowStat2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowStat(ctx context.Context, sel ast.SelectionSet, v model.WorkflowStat) graphql.Marshaler {
	return ec._WorkflowStat(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkflowStat2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowStat(ctx context.Context, sel ast.SelectionSet, v *model.WorkflowStat) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._WorkflowStat(ctx, sel, v)
}

func (ec *executionContext) marshalNWorkflowStatsResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowStatsResponse(ctx context.Context, sel ast.SelectionSet, v []*model.WorkflowStatsResponse) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOWorkflowStatsResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowStatsResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNWorkflowTemplate2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowTemplate(ctx context.Context, sel ast.SelectionSet, v model.WorkflowTemplate) graphql.Marshaler {
	return ec._WorkflowTemplate(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkflowTemplate2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowTemplate(ctx context.Context, sel ast.SelectionSet, v []*model.WorkflowTemplate) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOWorkflowTemplate2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowTemplate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNWorkflowTemplate2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowTemplate(ctx context.Context, sel ast.SelectionSet, v *model.WorkflowTemplate) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._WorkflowTemplate(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalOAnnotationsPromResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAnnotationsPromResponse(ctx context.Context, sel ast.SelectionSet, v model.AnnotationsPromResponse) graphql.Marshaler {
	return ec._AnnotationsPromResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalOAnnotationsPromResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAnnotationsPromResponse(ctx context.Context, sel ast.SelectionSet, v []*model.AnnotationsPromResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAnnotationsPromResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAnnotationsPromResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAnnotationsPromResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAnnotationsPromResponse(ctx context.Context, sel ast.SelectionSet, v *model.AnnotationsPromResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AnnotationsPromResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOAnnotationsTimeStampValue2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAnnotationsTimeStampValue(ctx context.Context, sel ast.SelectionSet, v model.AnnotationsTimeStampValue) graphql.Marshaler {
	return ec._AnnotationsTimeStampValue(ctx, sel, &v)
}

func (ec *executionContext) marshalOAnnotationsTimeStampValue2ᚕᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAnnotationsTimeStampValue(ctx context.Context, sel ast.SelectionSet, v [][]*model.AnnotationsTimeStampValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAnnotationsTimeStampValue2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAnnotationsTimeStampValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAnnotationsTimeStampValue2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAnnotationsTimeStampValue(ctx context.Context, sel ast.SelectionSet, v []*model.AnnotationsTimeStampValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAnnotationsTimeStampValue2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAnnotationsTimeStampValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAnnotationsTimeStampValue2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAnnotationsTimeStampValue(ctx context.Context, sel ast.SelectionSet, v *model.AnnotationsTimeStampValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AnnotationsTimeStampValue(ctx, sel, v)
}

func (ec *executionContext) unmarshalOApplicationMetadata2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐApplicationMetadata(ctx context.Context, v interface{}) (model.ApplicationMetadata, error) {
	return ec.unmarshalInputApplicationMetadata(ctx, v)
}

func (ec *executionContext) unmarshalOApplicationMetadata2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐApplicationMetadata(ctx context.Context, v interface{}) ([]*model.ApplicationMetadata, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.ApplicationMetadata, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOApplicationMetadata2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐApplicationMetadata(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOApplicationMetadata2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐApplicationMetadata(ctx context.Context, v interface{}) (*model.ApplicationMetadata, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOApplicationMetadata2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐApplicationMetadata(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOApplicationMetadataResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐApplicationMetadataResponse(ctx context.Context, sel ast.SelectionSet, v model.ApplicationMetadataResponse) graphql.Marshaler {
	return ec._ApplicationMetadataResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalOApplicationMetadataResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐApplicationMetadataResponse(ctx context.Context, sel ast.SelectionSet, v []*model.ApplicationMetadataResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOApplicationMetadataResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐApplicationMetadataResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOApplicationMetadataResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐApplicationMetadataResponse(ctx context.Context, sel ast.SelectionSet, v *model.ApplicationMetadataResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ApplicationMetadataResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAuthType2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAuthType(ctx context.Context, v interface{}) (model.AuthType, error) {
	var res model.AuthType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOAuthType2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAuthType(ctx context.Context, sel ast.SelectionSet, v model.AuthType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOAuthType2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAuthType(ctx context.Context, v interface{}) (*model.AuthType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOAuthType2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAuthType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOAuthType2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐAuthType(ctx context.Context, sel ast.SelectionSet, v *model.AuthType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBoolean2bool(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOBoolean2bool(ctx, sel, *v)
}

func (ec *executionContext) marshalOChaosHubStatus2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChaosHubStatus(ctx context.Context, sel ast.SelectionSet, v model.ChaosHubStatus) graphql.Marshaler {
	return ec._ChaosHubStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalOChaosHubStatus2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChaosHubStatus(ctx context.Context, sel ast.SelectionSet, v *model.ChaosHubStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ChaosHubStatus(ctx, sel, v)
}

func (ec *executionContext) unmarshalOChaosWorkFlowRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChaosWorkFlowRequest(ctx context.Context, v interface{}) (model.ChaosWorkFlowRequest, error) {
	return ec.unmarshalInputChaosWorkFlowRequest(ctx, v)
}

func (ec *executionContext) unmarshalOChaosWorkFlowRequest2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChaosWorkFlowRequest(ctx context.Context, v interface{}) (*model.ChaosWorkFlowRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOChaosWorkFlowRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐChaosWorkFlowRequest(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOCreateDBInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐCreateDBInput(ctx context.Context, v interface{}) (model.CreateDBInput, error) {
	return ec.unmarshalInputCreateDBInput(ctx, v)
}

func (ec *executionContext) unmarshalOCreateDBInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐCreateDBInput(ctx context.Context, v interface{}) (*model.CreateDBInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOCreateDBInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐCreateDBInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalODSInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDSInput(ctx context.Context, v interface{}) (model.DSInput, error) {
	return ec.unmarshalInputDSInput(ctx, v)
}

func (ec *executionContext) unmarshalODSInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDSInput(ctx context.Context, v interface{}) (*model.DSInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODSInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDSInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalODSResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDSResponse(ctx context.Context, sel ast.SelectionSet, v model.DSResponse) graphql.Marshaler {
	return ec._DSResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalODSResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDSResponse(ctx context.Context, sel ast.SelectionSet, v *model.DSResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DSResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalODateRange2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDateRange(ctx context.Context, v interface{}) (model.DateRange, error) {
	return ec.unmarshalInputDateRange(ctx, v)
}

func (ec *executionContext) unmarshalODateRange2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDateRange(ctx context.Context, v interface{}) (*model.DateRange, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODateRange2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDateRange(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalODsDetails2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDsDetails(ctx context.Context, v interface{}) (model.DsDetails, error) {
	return ec.unmarshalInputDsDetails(ctx, v)
}

func (ec *executionContext) unmarshalODsDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDsDetails(ctx context.Context, v interface{}) (*model.DsDetails, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODsDetails2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐDsDetails(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	return graphql.UnmarshalFloat(v)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	return graphql.MarshalFloat(v)
}

func (ec *executionContext) unmarshalOFloat2ᚖfloat64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOFloat2float64(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOFloat2ᚖfloat64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOFloat2float64(ctx, sel, *v)
}

func (ec *executionContext) marshalOHeatmapDataResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐHeatmapDataResponse(ctx context.Context, sel ast.SelectionSet, v model.HeatmapDataResponse) graphql.Marshaler {
	return ec._HeatmapDataResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalOHeatmapDataResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐHeatmapDataResponse(ctx context.Context, sel ast.SelectionSet, v *model.HeatmapDataResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._HeatmapDataResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalID(v)
}

func (ec *executionContext) unmarshalOID2ᚕᚖstring(ctx context.Context, v interface{}) ([]*string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOID2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2ᚕᚖstring(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOID2ᚖstring(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOID2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOID2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOID2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOID2string(ctx, sel, *v)
}

func (ec *executionContext) marshalOImageRegistry2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐImageRegistry(ctx context.Context, sel ast.SelectionSet, v model.ImageRegistry) graphql.Marshaler {
	return ec._ImageRegistry(ctx, sel, &v)
}

func (ec *executionContext) marshalOImageRegistry2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐImageRegistry(ctx context.Context, sel ast.SelectionSet, v *model.ImageRegistry) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ImageRegistry(ctx, sel, v)
}

func (ec *executionContext) marshalOImageRegistryResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐImageRegistryResponseᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ImageRegistryResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImageRegistryResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐImageRegistryResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInt2int(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOInt2int(ctx, sel, *v)
}

func (ec *executionContext) marshalOLabelValue2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐLabelValue(ctx context.Context, sel ast.SelectionSet, v model.LabelValue) graphql.Marshaler {
	return ec._LabelValue(ctx, sel, &v)
}

func (ec *executionContext) marshalOLabelValue2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐLabelValue(ctx context.Context, sel ast.SelectionSet, v []*model.LabelValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOLabelValue2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐLabelValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOLabelValue2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐLabelValue(ctx context.Context, sel ast.SelectionSet, v *model.LabelValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LabelValue(ctx, sel, v)
}

func (ec *executionContext) marshalOListDashboardResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐListDashboardResponse(ctx context.Context, sel ast.SelectionSet, v model.ListDashboardResponse) graphql.Marshaler {
	return ec._ListDashboardResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalOListDashboardResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐListDashboardResponse(ctx context.Context, sel ast.SelectionSet, v []*model.ListDashboardResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOListDashboardResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐListDashboardResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOListDashboardResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐListDashboardResponse(ctx context.Context, sel ast.SelectionSet, v *model.ListDashboardResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ListDashboardResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOMetricDataForPanel2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetricDataForPanel(ctx context.Context, sel ast.SelectionSet, v model.MetricDataForPanel) graphql.Marshaler {
	return ec._MetricDataForPanel(ctx, sel, &v)
}

func (ec *executionContext) marshalOMetricDataForPanel2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetricDataForPanel(ctx context.Context, sel ast.SelectionSet, v []*model.MetricDataForPanel) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMetricDataForPanel2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetricDataForPanel(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOMetricDataForPanel2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetricDataForPanel(ctx context.Context, sel ast.SelectionSet, v *model.MetricDataForPanel) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MetricDataForPanel(ctx, sel, v)
}

func (ec *executionContext) marshalOMetricDataForPanelGroup2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetricDataForPanelGroup(ctx context.Context, sel ast.SelectionSet, v model.MetricDataForPanelGroup) graphql.Marshaler {
	return ec._MetricDataForPanelGroup(ctx, sel, &v)
}

func (ec *executionContext) marshalOMetricDataForPanelGroup2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetricDataForPanelGroup(ctx context.Context, sel ast.SelectionSet, v []*model.MetricDataForPanelGroup) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMetricDataForPanelGroup2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetricDataForPanelGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOMetricDataForPanelGroup2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetricDataForPanelGroup(ctx context.Context, sel ast.SelectionSet, v *model.MetricDataForPanelGroup) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MetricDataForPanelGroup(ctx, sel, v)
}

func (ec *executionContext) marshalOMetricsPromResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetricsPromResponse(ctx context.Context, sel ast.SelectionSet, v model.MetricsPromResponse) graphql.Marshaler {
	return ec._MetricsPromResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalOMetricsPromResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetricsPromResponse(ctx context.Context, sel ast.SelectionSet, v []*model.MetricsPromResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMetricsPromResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetricsPromResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOMetricsPromResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetricsPromResponse(ctx context.Context, sel ast.SelectionSet, v *model.MetricsPromResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MetricsPromResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOMetricsTimeStampValue2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetricsTimeStampValue(ctx context.Context, sel ast.SelectionSet, v model.MetricsTimeStampValue) graphql.Marshaler {
	return ec._MetricsTimeStampValue(ctx, sel, &v)
}

func (ec *executionContext) marshalOMetricsTimeStampValue2ᚕᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetricsTimeStampValue(ctx context.Context, sel ast.SelectionSet, v [][]*model.MetricsTimeStampValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMetricsTimeStampValue2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetricsTimeStampValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOMetricsTimeStampValue2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetricsTimeStampValue(ctx context.Context, sel ast.SelectionSet, v []*model.MetricsTimeStampValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMetricsTimeStampValue2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetricsTimeStampValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOMetricsTimeStampValue2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐMetricsTimeStampValue(ctx context.Context, sel ast.SelectionSet, v *model.MetricsTimeStampValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MetricsTimeStampValue(ctx, sel, v)
}

func (ec *executionContext) marshalOOption2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐOption(ctx context.Context, sel ast.SelectionSet, v model.Option) graphql.Marshaler {
	return ec._Option(ctx, sel, &v)
}

func (ec *executionContext) marshalOOption2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐOption(ctx context.Context, sel ast.SelectionSet, v []*model.Option) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOOption2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐOption(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOOption2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐOption(ctx context.Context, sel ast.SelectionSet, v *model.Option) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Option(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPagination2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPagination(ctx context.Context, v interface{}) (model.Pagination, error) {
	return ec.unmarshalInputPagination(ctx, v)
}

func (ec *executionContext) unmarshalOPagination2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPagination(ctx context.Context, v interface{}) (*model.Pagination, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPagination2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPagination(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOPanel2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanel(ctx context.Context, v interface{}) (model.Panel, error) {
	return ec.unmarshalInputPanel(ctx, v)
}

func (ec *executionContext) unmarshalOPanel2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanel(ctx context.Context, v interface{}) ([]*model.Panel, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.Panel, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOPanel2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanel(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPanel2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanel(ctx context.Context, v interface{}) (*model.Panel, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPanel2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanel(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOPanelGroup2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanelGroup(ctx context.Context, v interface{}) (model.PanelGroup, error) {
	return ec.unmarshalInputPanelGroup(ctx, v)
}

func (ec *executionContext) unmarshalOPanelGroup2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanelGroup(ctx context.Context, v interface{}) (*model.PanelGroup, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPanelGroup2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanelGroup(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOPanelGroupResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanelGroupResponse(ctx context.Context, sel ast.SelectionSet, v model.PanelGroupResponse) graphql.Marshaler {
	return ec._PanelGroupResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalOPanelGroupResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanelGroupResponse(ctx context.Context, sel ast.SelectionSet, v *model.PanelGroupResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PanelGroupResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPanelOption2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanelOption(ctx context.Context, v interface{}) (model.PanelOption, error) {
	return ec.unmarshalInputPanelOption(ctx, v)
}

func (ec *executionContext) unmarshalOPanelOption2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanelOption(ctx context.Context, v interface{}) (*model.PanelOption, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPanelOption2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanelOption(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOPanelOptionResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanelOptionResponse(ctx context.Context, sel ast.SelectionSet, v model.PanelOptionResponse) graphql.Marshaler {
	return ec._PanelOptionResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalOPanelOptionResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanelOptionResponse(ctx context.Context, sel ast.SelectionSet, v *model.PanelOptionResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PanelOptionResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOPanelResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanelResponse(ctx context.Context, sel ast.SelectionSet, v model.PanelResponse) graphql.Marshaler {
	return ec._PanelResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalOPanelResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanelResponse(ctx context.Context, sel ast.SelectionSet, v []*model.PanelResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPanelResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanelResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOPanelResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPanelResponse(ctx context.Context, sel ast.SelectionSet, v *model.PanelResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PanelResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOProjectData2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐProjectData(ctx context.Context, sel ast.SelectionSet, v model.ProjectData) graphql.Marshaler {
	return ec._ProjectData(ctx, sel, &v)
}

func (ec *executionContext) marshalOProjectData2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐProjectData(ctx context.Context, sel ast.SelectionSet, v *model.ProjectData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProjectData(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPromQuery2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromQuery(ctx context.Context, v interface{}) (model.PromQuery, error) {
	return ec.unmarshalInputPromQuery(ctx, v)
}

func (ec *executionContext) unmarshalOPromQuery2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromQuery(ctx context.Context, v interface{}) ([]*model.PromQuery, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.PromQuery, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOPromQuery2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromQuery(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPromQuery2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromQuery(ctx context.Context, v interface{}) (*model.PromQuery, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPromQuery2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromQuery(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOPromQueryInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromQueryInput(ctx context.Context, v interface{}) (model.PromQueryInput, error) {
	return ec.unmarshalInputPromQueryInput(ctx, v)
}

func (ec *executionContext) unmarshalOPromQueryInput2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromQueryInput(ctx context.Context, v interface{}) ([]*model.PromQueryInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.PromQueryInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOPromQueryInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromQueryInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPromQueryInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromQueryInput(ctx context.Context, v interface{}) (*model.PromQueryInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPromQueryInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromQueryInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOPromQueryResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromQueryResponse(ctx context.Context, sel ast.SelectionSet, v model.PromQueryResponse) graphql.Marshaler {
	return ec._PromQueryResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalOPromQueryResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromQueryResponse(ctx context.Context, sel ast.SelectionSet, v []*model.PromQueryResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPromQueryResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromQueryResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOPromQueryResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromQueryResponse(ctx context.Context, sel ast.SelectionSet, v *model.PromQueryResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PromQueryResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPromSeriesInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromSeriesInput(ctx context.Context, v interface{}) (model.PromSeriesInput, error) {
	return ec.unmarshalInputPromSeriesInput(ctx, v)
}

func (ec *executionContext) unmarshalOPromSeriesInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromSeriesInput(ctx context.Context, v interface{}) (*model.PromSeriesInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPromSeriesInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPromSeriesInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOPrometheusDataRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPrometheusDataRequest(ctx context.Context, v interface{}) (model.PrometheusDataRequest, error) {
	return ec.unmarshalInputPrometheusDataRequest(ctx, v)
}

func (ec *executionContext) unmarshalOPrometheusDataRequest2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPrometheusDataRequest(ctx context.Context, v interface{}) (*model.PrometheusDataRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPrometheusDataRequest2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐPrometheusDataRequest(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOResource2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐResource(ctx context.Context, v interface{}) (model.Resource, error) {
	return ec.unmarshalInputResource(ctx, v)
}

func (ec *executionContext) unmarshalOResource2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐResource(ctx context.Context, v interface{}) ([]*model.Resource, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.Resource, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOResource2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐResource(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOResource2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐResource(ctx context.Context, v interface{}) (*model.Resource, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOResource2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐResource(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOResourceResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐResourceResponse(ctx context.Context, sel ast.SelectionSet, v model.ResourceResponse) graphql.Marshaler {
	return ec._ResourceResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalOResourceResponse2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐResourceResponse(ctx context.Context, sel ast.SelectionSet, v []*model.ResourceResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOResourceResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐResourceResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOResourceResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐResourceResponse(ctx context.Context, sel ast.SelectionSet, v *model.ResourceResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ResourceResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2ᚕᚖstring(ctx context.Context, v interface{}) ([]*string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOString2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕᚖstring(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2ᚖstring(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOString2string(ctx, sel, *v)
}

func (ec *executionContext) marshalOSubData2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐSubData(ctx context.Context, sel ast.SelectionSet, v model.SubData) graphql.Marshaler {
	return ec._SubData(ctx, sel, &v)
}

func (ec *executionContext) marshalOSubData2ᚕᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐSubData(ctx context.Context, sel ast.SelectionSet, v [][]*model.SubData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSubData2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐSubData(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOSubData2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐSubData(ctx context.Context, sel ast.SelectionSet, v []*model.SubData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSubData2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐSubData(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOSubData2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐSubData(ctx context.Context, sel ast.SelectionSet, v *model.SubData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SubData(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTemplateInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐTemplateInput(ctx context.Context, v interface{}) (model.TemplateInput, error) {
	return ec.unmarshalInputTemplateInput(ctx, v)
}

func (ec *executionContext) unmarshalOTemplateInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐTemplateInput(ctx context.Context, v interface{}) (*model.TemplateInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOTemplateInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐTemplateInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOToleration2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐToleration(ctx context.Context, v interface{}) (model.Toleration, error) {
	return ec.unmarshalInputToleration(ctx, v)
}

func (ec *executionContext) unmarshalOToleration2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐToleration(ctx context.Context, v interface{}) ([]*model.Toleration, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.Toleration, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOToleration2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐToleration(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOToleration2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐToleration(ctx context.Context, v interface{}) (*model.Toleration, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOToleration2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐToleration(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOUpdatePanelGroupInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐUpdatePanelGroupInput(ctx context.Context, v interface{}) (model.UpdatePanelGroupInput, error) {
	return ec.unmarshalInputUpdatePanelGroupInput(ctx, v)
}

func (ec *executionContext) unmarshalOUpdatePanelGroupInput2ᚕᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐUpdatePanelGroupInput(ctx context.Context, v interface{}) ([]*model.UpdatePanelGroupInput, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.UpdatePanelGroupInput, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOUpdatePanelGroupInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐUpdatePanelGroupInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUpdatePanelGroupInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐUpdatePanelGroupInput(ctx context.Context, v interface{}) (*model.UpdatePanelGroupInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUpdatePanelGroupInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐUpdatePanelGroupInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOUsageSortInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐUsageSortInput(ctx context.Context, v interface{}) (model.UsageSortInput, error) {
	return ec.unmarshalInputUsageSortInput(ctx, v)
}

func (ec *executionContext) unmarshalOUsageSortInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐUsageSortInput(ctx context.Context, v interface{}) (*model.UsageSortInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUsageSortInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐUsageSortInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOWorkflow2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflow(ctx context.Context, sel ast.SelectionSet, v model.Workflow) graphql.Marshaler {
	return ec._Workflow(ctx, sel, &v)
}

func (ec *executionContext) marshalOWorkflow2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflow(ctx context.Context, sel ast.SelectionSet, v *model.Workflow) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Workflow(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWorkflowFilterInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowFilterInput(ctx context.Context, v interface{}) (model.WorkflowFilterInput, error) {
	return ec.unmarshalInputWorkflowFilterInput(ctx, v)
}

func (ec *executionContext) unmarshalOWorkflowFilterInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowFilterInput(ctx context.Context, v interface{}) (*model.WorkflowFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOWorkflowFilterInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowFilterInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOWorkflowRun2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRun(ctx context.Context, sel ast.SelectionSet, v model.WorkflowRun) graphql.Marshaler {
	return ec._WorkflowRun(ctx, sel, &v)
}

func (ec *executionContext) marshalOWorkflowRun2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRun(ctx context.Context, sel ast.SelectionSet, v *model.WorkflowRun) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WorkflowRun(ctx, sel, v)
}

func (ec *executionContext) marshalOWorkflowRunDetails2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunDetails(ctx context.Context, sel ast.SelectionSet, v model.WorkflowRunDetails) graphql.Marshaler {
	return ec._WorkflowRunDetails(ctx, sel, &v)
}

func (ec *executionContext) marshalOWorkflowRunDetails2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunDetails(ctx context.Context, sel ast.SelectionSet, v *model.WorkflowRunDetails) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WorkflowRunDetails(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWorkflowRunFilterInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunFilterInput(ctx context.Context, v interface{}) (model.WorkflowRunFilterInput, error) {
	return ec.unmarshalInputWorkflowRunFilterInput(ctx, v)
}

func (ec *executionContext) unmarshalOWorkflowRunFilterInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunFilterInput(ctx context.Context, v interface{}) (*model.WorkflowRunFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOWorkflowRunFilterInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunFilterInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOWorkflowRunSortInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunSortInput(ctx context.Context, v interface{}) (model.WorkflowRunSortInput, error) {
	return ec.unmarshalInputWorkflowRunSortInput(ctx, v)
}

func (ec *executionContext) unmarshalOWorkflowRunSortInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunSortInput(ctx context.Context, v interface{}) (*model.WorkflowRunSortInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOWorkflowRunSortInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunSortInput(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOWorkflowRunStatus2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunStatus(ctx context.Context, v interface{}) (model.WorkflowRunStatus, error) {
	var res model.WorkflowRunStatus
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOWorkflowRunStatus2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunStatus(ctx context.Context, sel ast.SelectionSet, v model.WorkflowRunStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOWorkflowRunStatus2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunStatus(ctx context.Context, v interface{}) (*model.WorkflowRunStatus, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOWorkflowRunStatus2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunStatus(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOWorkflowRunStatus2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunStatus(ctx context.Context, sel ast.SelectionSet, v *model.WorkflowRunStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOWorkflowRunsData2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunsData(ctx context.Context, sel ast.SelectionSet, v model.WorkflowRunsData) graphql.Marshaler {
	return ec._WorkflowRunsData(ctx, sel, &v)
}

func (ec *executionContext) marshalOWorkflowRunsData2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowRunsData(ctx context.Context, sel ast.SelectionSet, v *model.WorkflowRunsData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WorkflowRunsData(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWorkflowSortInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowSortInput(ctx context.Context, v interface{}) (model.WorkflowSortInput, error) {
	return ec.unmarshalInputWorkflowSortInput(ctx, v)
}

func (ec *executionContext) unmarshalOWorkflowSortInput2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowSortInput(ctx context.Context, v interface{}) (*model.WorkflowSortInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOWorkflowSortInput2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowSortInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOWorkflowStatsResponse2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowStatsResponse(ctx context.Context, sel ast.SelectionSet, v model.WorkflowStatsResponse) graphql.Marshaler {
	return ec._WorkflowStatsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalOWorkflowStatsResponse2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowStatsResponse(ctx context.Context, sel ast.SelectionSet, v *model.WorkflowStatsResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WorkflowStatsResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOWorkflowTemplate2githubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowTemplate(ctx context.Context, sel ast.SelectionSet, v model.WorkflowTemplate) graphql.Marshaler {
	return ec._WorkflowTemplate(ctx, sel, &v)
}

func (ec *executionContext) marshalOWorkflowTemplate2ᚖgithubᚗcomᚋlitmuschaosᚋlitmusᚋlitmusᚑportalᚋgraphqlᚑserverᚋgraphᚋmodelᚐWorkflowTemplate(ctx context.Context, sel ast.SelectionSet, v *model.WorkflowTemplate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WorkflowTemplate(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v introspection.Schema) graphql.Marshaler {
	return ec.___Schema(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
