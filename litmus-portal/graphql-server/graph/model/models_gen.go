// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type ActionPayload struct {
	RequestType  string  `json:"requestType"`
	K8sManifest  string  `json:"k8sManifest"`
	Namespace    string  `json:"namespace"`
	ExternalData *string `json:"externalData"`
	Username     *string `json:"username"`
}

// Defines details of agent statistics
type AgentStat struct {
	// Number of namespaces
	Ns int `json:"ns"`
	// Number of clusters
	Cluster int `json:"cluster"`
	// Total number of agents
	Total int `json:"total"`
	// Number of active agents
	Active int `json:"active"`
}

type Annotation struct {
	Categories       string `json:"categories"`
	Vendor           string `json:"vendor"`
	CreatedAt        string `json:"createdAt"`
	Repository       string `json:"repository"`
	Support          string `json:"support"`
	ChartDescription string `json:"chartDescription"`
}

type AnnotationsPromResponse struct {
	QueryID      string                         `json:"queryID"`
	Legends      []*string                      `json:"legends"`
	Tsvs         [][]*AnnotationsTimeStampValue `json:"tsvs"`
	SubDataArray [][]*SubData                   `json:"subDataArray"`
}

type AnnotationsTimeStampValue struct {
	Date  *float64 `json:"date"`
	Value *int     `json:"value"`
}

type ApplicationMetadata struct {
	Namespace    string      `json:"namespace"`
	Applications []*Resource `json:"applications"`
}

type ApplicationMetadataResponse struct {
	Namespace    string              `json:"namespace"`
	Applications []*ResourceResponse `json:"applications"`
}

type ChaosHub struct {
	// ID of the chaos hub
	ID string `json:"id"`
	// URL of the git repository
	RepoURL string `json:"repoURL"`
	// Branch of the git repository
	RepoBranch string `json:"repoBranch"`
	// ID of the project in which the chaos hub is present
	ProjectID string `json:"projectID"`
	// Name of the chaos hub
	HubName string `json:"hubName"`
	// Type of ChaosHub
	HubType HubType `json:"hubType"`
	// Bool value indicating whether the hub is private or not.
	IsPrivate bool `json:"isPrivate"`
	// Type of authentication used: 	BASIC, SSH,	TOKEN
	AuthType AuthType `json:"authType"`
	// Token for authentication of private chaos hub
	Token *string `json:"token"`
	// Git username
	UserName *string `json:"userName"`
	// Git password
	Password *string `json:"password"`
	// Private SSH key for authenticating into private chaos hub
	SSHPrivateKey *string `json:"sshPrivateKey"`
	// Bool value indicating if the chaos hub is removed
	IsRemoved bool `json:"isRemoved"`
	// Timestamp when the chaos hub was created
	CreatedAt string `json:"createdAt"`
	// Timestamp when the chaos hub was last updated
	UpdatedAt string `json:"updatedAt"`
	// Timestamp when the chaos hub was last synced
	LastSyncedAt string `json:"lastSyncedAt"`
}

type ChaosHubStatus struct {
	// ID of the hub
	ID string `json:"id"`
	// URL of the git repository
	RepoURL string `json:"repoURL"`
	// Branch of the git repository
	RepoBranch string `json:"repoBranch"`
	// Bool value indicating whether the hub is available or not.
	IsAvailable bool `json:"isAvailable"`
	// Total number of experiments in the hub
	TotalExp string `json:"totalExp"`
	// Name of the chaos hub
	HubName string `json:"hubName"`
	// Type of ChaosHub
	HubType HubType `json:"hubType"`
	// Bool value indicating whether the hub is private or not.
	IsPrivate bool `json:"isPrivate"`
	// Type of authentication used: 	BASIC, SSH,	TOKEN
	AuthType AuthType `json:"authType"`
	// Token for authentication of private chaos hub
	Token *string `json:"token"`
	// Git username
	UserName *string `json:"userName"`
	// Git password
	Password *string `json:"password"`
	// Bool value indicating whether the hub is private or not.
	IsRemoved bool `json:"isRemoved"`
	// Private SSH key for authenticating into private chaos hub
	SSHPrivateKey *string `json:"sshPrivateKey"`
	// Public SSH key for authenticating into private chaos hub
	SSHPublicKey *string `json:"sshPublicKey"`
	// Timestamp when the chaos hub was last synced
	LastSyncedAt string `json:"lastSyncedAt"`
}

// Defines the details for a chaos workflow
type ChaosWorkFlowRequest struct {
	// ID of the workflow
	WorkflowID *string `json:"workflowID"`
	// Manifest of the workflow
	WorkflowManifest string `json:"workflowManifest"`
	// Cron syntax of the workflow schedule
	CronSyntax string `json:"cronSyntax"`
	// Name of the workflow
	WorkflowName string `json:"workflowName"`
	// Description of the workflow
	WorkflowDescription string `json:"workflowDescription"`
	// Array containing weightage and name of each chaos experiment in the workflow
	Weightages []*WeightagesInput `json:"weightages"`
	// Bool value indicating whether the workflow is a custom workflow or not
	IsCustomWorkflow bool `json:"isCustomWorkflow"`
	// ID of the project under which the workflow is scheduled
	ProjectID string `json:"projectID"`
	// ID of the target cluster in which the workflow will run
	ClusterID string `json:"clusterID"`
}

// Defines the response received for querying the details of chaos workflow
type ChaosWorkFlowResponse struct {
	// ID of the workflow
	WorkflowID string `json:"workflowID"`
	// Cron syntax of the workflow schedule
	CronSyntax string `json:"cronSyntax"`
	// Name of the workflow
	WorkflowName string `json:"workflowName"`
	// Description of the workflow
	WorkflowDescription string `json:"workflowDescription"`
	// Bool value indicating whether the workflow is a custom workflow or not
	IsCustomWorkflow bool `json:"isCustomWorkflow"`
}

type Chart struct {
	APIVersion  string              `json:"apiVersion"`
	Kind        string              `json:"kind"`
	Metadata    *Metadata           `json:"metadata"`
	Spec        *Spec               `json:"spec"`
	PackageInfo *PackageInformation `json:"packageInfo"`
}

type CloningInput struct {
	// Name of the chaos hub
	HubName string `json:"hubName"`
	// ID of the project
	ProjectID string `json:"projectID"`
	// Branch of the git repository
	RepoBranch string `json:"repoBranch"`
	// URL of the git repository
	RepoURL string `json:"repoURL"`
	// Bool value indicating whether the hub is private or not.
	IsPrivate bool `json:"isPrivate"`
	// Type of authentication used: 	BASIC, SSH,	TOKEN
	AuthType AuthType `json:"authType"`
	// Token for authentication of private chaos hub
	Token *string `json:"token"`
	// Git username
	UserName *string `json:"userName"`
	// Git password
	Password      *string `json:"password"`
	SSHPrivateKey *string `json:"sshPrivateKey"`
}

// Defines the details for a cluster
type Cluster struct {
	// ID of the cluster
	ClusterID string `json:"clusterID"`
	// Project ID the cluster is being connected to
	ProjectID string `json:"projectID"`
	// Name of the cluster
	ClusterName string `json:"clusterName"`
	// Description of the cluster
	Description *string `json:"description"`
	// Cluster Platform Name eg. GKE,AWS, Others
	PlatformName string `json:"platformName"`
	AccessKey    string `json:"accessKey"`
	// Bool value indicating if the cluster agent is registered or not
	IsRegistered bool `json:"isRegistered"`
	// Bool value indicating if the cluster agent is confirmed or not
	IsClusterConfirmed bool `json:"isClusterConfirmed"`
	// Bool value indicating if the cluster agent is active or not
	IsActive bool `json:"isActive"`
	// Timestamp when the cluster agent was last updated
	UpdatedAt string `json:"updatedAt"`
	// Timestamp when the cluster agent was created
	CreatedAt string `json:"createdAt"`
	// Cluster type : Internal or External
	ClusterType string `json:"clusterType"`
	// Number of schedules created in the cluster agent
	NoOfSchedules *int `json:"noOfSchedules"`
	// Number of workflows run in the cluster agent
	NoOfWorkflows *int `json:"noOfWorkflows"`
	// Token used to verify and retrieve the cluster agent manifest
	Token string `json:"token"`
	// Namespace where the cluster agent is being installed
	AgentNamespace *string `json:"agentNamespace"`
	// Name of service account used by cluster agent
	ServiceAccount *string `json:"serviceAccount"`
	// Scope of the cluster agent : ns or cluster
	AgentScope string `json:"agentScope"`
	// Bool value indicating whether agent ns used already exists on cluster or not
	AgentNsExists *bool `json:"agentNsExists"`
	// Bool value indicating whether service account used already exists on cluster or not
	AgentSaExists *bool `json:"agentSaExists"`
	// Timestamp of the last workflow run in the cluster agent
	LastWorkflowTimestamp string `json:"lastWorkflowTimestamp"`
	// Timestamp when the cluster agent got connected
	StartTime string `json:"startTime"`
	// Version of the cluster agent
	Version string `json:"version"`
}

type ClusterActionResponse struct {
	ProjectID string         `json:"projectID"`
	Action    *ActionPayload `json:"action"`
}

type ClusterEventResponse struct {
	EventID     string   `json:"eventID"`
	EventType   string   `json:"eventType"`
	EventName   string   `json:"eventName"`
	Description string   `json:"description"`
	Cluster     *Cluster `json:"cluster"`
}

type ClusterIdentity struct {
	ClusterID string `json:"clusterID"`
	AccessKey string `json:"accessKey"`
	Version   string `json:"version"`
}

type ConfirmClusterRegistrationResponse struct {
	IsClusterConfirmed bool    `json:"isClusterConfirmed"`
	NewAccessKey       *string `json:"newAccessKey"`
	ClusterID          *string `json:"clusterID"`
}

// Defines the details required for creating a chaos hub
type CreateChaosHubRequest struct {
	// Name of the chaos hub
	HubName string `json:"hubName"`
	// URL of the git repository
	RepoURL string `json:"repoURL"`
	// Branch of the git repository
	RepoBranch string `json:"repoBranch"`
	// Bool value indicating whether the hub is private or not.
	IsPrivate bool `json:"isPrivate"`
	// Type of authentication used: 	BASIC, SSH,	TOKEN
	AuthType AuthType `json:"authType"`
	// Token for authentication of private chaos hub
	Token *string `json:"token"`
	// Git username
	UserName *string `json:"userName"`
	// Git password
	Password *string `json:"password"`
	// Private SSH key for authenticating into private chaos hub
	SSHPrivateKey *string `json:"sshPrivateKey"`
	// Public SSH key for authenticating into private chaos hub
	SSHPublicKey *string `json:"sshPublicKey"`
	// Project ID associated with this chaos hub
	ProjectID string `json:"projectID"`
}

type CreateDBInput struct {
	DsID                      string                 `json:"dsID"`
	DbName                    string                 `json:"dbName"`
	DbTypeName                string                 `json:"dbTypeName"`
	DbTypeID                  string                 `json:"dbTypeID"`
	DbInformation             *string                `json:"dbInformation"`
	ChaosEventQueryTemplate   string                 `json:"chaosEventQueryTemplate"`
	ChaosVerdictQueryTemplate string                 `json:"chaosVerdictQueryTemplate"`
	ApplicationMetadataMap    []*ApplicationMetadata `json:"applicationMetadataMap"`
	PanelGroups               []*PanelGroup          `json:"panelGroups"`
	EndTime                   string                 `json:"endTime"`
	StartTime                 string                 `json:"startTime"`
	ProjectID                 string                 `json:"projectID"`
	ClusterID                 string                 `json:"clusterID"`
	RefreshRate               string                 `json:"refreshRate"`
}

type CreateRemoteMyHub struct {
	// Name of the chaos hub
	HubName string `json:"hubName"`
	// URL of the git repository
	RepoURL string `json:"repoURL"`
	// ProjectID of the ChaosHub
	ProjectID string `json:"projectID"`
}

type DSInput struct {
	DsID              *string `json:"dsID"`
	DsName            string  `json:"dsName"`
	DsType            string  `json:"dsType"`
	DsURL             string  `json:"dsURL"`
	AccessType        string  `json:"accessType"`
	AuthType          string  `json:"authType"`
	BasicAuthUsername *string `json:"basicAuthUsername"`
	BasicAuthPassword *string `json:"basicAuthPassword"`
	ScrapeInterval    int     `json:"scrapeInterval"`
	QueryTimeout      int     `json:"queryTimeout"`
	HTTPMethod        string  `json:"httpMethod"`
	ProjectID         *string `json:"projectID"`
}

type DSResponse struct {
	DsID              *string `json:"dsID"`
	DsName            *string `json:"dsName"`
	DsType            *string `json:"dsType"`
	DsURL             *string `json:"dsURL"`
	AccessType        *string `json:"accessType"`
	AuthType          *string `json:"authType"`
	BasicAuthUsername *string `json:"basicAuthUsername"`
	BasicAuthPassword *string `json:"basicAuthPassword"`
	ScrapeInterval    *int    `json:"scrapeInterval"`
	QueryTimeout      *int    `json:"queryTimeout"`
	HTTPMethod        *string `json:"httpMethod"`
	ProjectID         string  `json:"projectID"`
	HealthStatus      string  `json:"healthStatus"`
	CreatedAt         *string `json:"createdAt"`
	UpdatedAt         *string `json:"updatedAt"`
}

type DashboardPromResponse struct {
	DashboardMetricsResponse []*MetricDataForPanelGroup `json:"dashboardMetricsResponse"`
	AnnotationsResponse      []*AnnotationsPromResponse `json:"annotationsResponse"`
}

type DataVars struct {
	URL             string `json:"url"`
	Start           string `json:"start"`
	End             string `json:"end"`
	RelativeTime    int    `json:"relativeTime"`
	RefreshInterval int    `json:"refreshInterval"`
}

// Defines the start date and end date for the filtering the data
type DateRange struct {
	// Start date
	StartDate string `json:"startDate"`
	// End date
	EndDate *string `json:"endDate"`
}

type DeleteDSInput struct {
	ForceDelete bool   `json:"forceDelete"`
	DsID        string `json:"dsID"`
}

type DsDetails struct {
	URL   string `json:"url"`
	Start string `json:"start"`
	End   string `json:"end"`
}

type ExperimentDetails struct {
	// Engine Manifest
	EngineDetails string `json:"engineDetails"`
	// Experiment Manifest
	ExperimentDetails string `json:"experimentDetails"`
}

type ExperimentRequest struct {
	// ID of the project
	ProjectID string `json:"projectID"`
	// Name of the chart being used
	ChartName string `json:"chartName"`
	// Name of the experiment
	ExperimentName string `json:"experimentName"`
	// Name of the hub
	HubName string `json:"hubName"`
	// Type of thr file for workflow: chaosEngine/ experimentInput
	FileType *string `json:"fileType"`
}

type Experiments struct {
	Name string `json:"name"`
	Csv  string `json:"CSV"`
	Desc string `json:"desc"`
}

// Details of setting a Git repository
type GitConfig struct {
	// ID of the project where GitOps is configured
	ProjectID string `json:"projectID"`
	// Git branch where the chaos charts will be pushed and synced
	Branch string `json:"branch"`
	// URL of the Git repository
	RepoURL string `json:"repoURL"`
	// Type of authentication used: 	BASIC, SSH,	TOKEN
	AuthType AuthType `json:"authType"`
	// Token used for private repository
	Token *string `json:"token"`
	// Git username
	UserName *string `json:"userName"`
	// Git password
	Password *string `json:"password"`
	// Private SSH key authenticating into git repository
	SSHPrivateKey *string `json:"sshPrivateKey"`
}

// Response received after configuring GitOps
type GitConfigResponse struct {
	// Bool value indicating whether GitOps is enabled or not
	Enabled bool `json:"enabled"`
	// ID of the project where GitOps is configured
	ProjectID string `json:"projectID"`
	// Git branch where the chaos charts will be pushed and synced
	Branch *string `json:"branch"`
	// URL of the Git repository
	RepoURL *string `json:"repoURL"`
	// Type of authentication used: 	BASIC, SSH,	TOKEN
	AuthType *AuthType `json:"authType"`
	// Token used for private repository
	Token *string `json:"token"`
	// Git username
	UserName *string `json:"userName"`
	// Git password
	Password *string `json:"password"`
	// Private SSH key authenticating into git repository
	SSHPrivateKey *string `json:"sshPrivateKey"`
}

type HeatmapDataResponse struct {
	Bins []*WorkflowRunsData `json:"bins"`
}

// Defines details for image registry
type ImageRegistry struct {
	// Bool value indicating if the image registry is default or not; by default workflow uses LitmusChaos registry
	IsDefault *bool `json:"isDefault"`
	// Name of Image Registry
	ImageRegistryName string `json:"imageRegistryName"`
	// Name of image repository
	ImageRepoName string `json:"imageRepoName"`
	// Type of the image registry: public/private
	ImageRegistryType string `json:"imageRegistryType"`
	// Secret which is used for private registry
	SecretName *string `json:"secretName"`
	// Namespace where the secret is available
	SecretNamespace *string `json:"secretNamespace"`
	// Bool value indicating if image registry is enabled or not
	EnableRegistry *bool `json:"enableRegistry"`
}

// Defines input data for querying the details of an image registry
type ImageRegistryInput struct {
	// Bool value indicating if the image registry is default or not; by default workflow uses LitmusChaos registry
	IsDefault bool `json:"isDefault"`
	// Name of Image Registry
	ImageRegistryName string `json:"imageRegistryName"`
	// Name of image repository
	ImageRepoName string `json:"imageRepoName"`
	// Type of the image registry: public/private
	ImageRegistryType string `json:"imageRegistryType"`
	// Secret which is used for private registry
	SecretName *string `json:"secretName"`
	// Namespace where the secret is available
	SecretNamespace *string `json:"secretNamespace"`
	// Bool value indicating if image registry is enabled or not
	EnableRegistry *bool `json:"enableRegistry"`
}

// Defines response data for image registry
type ImageRegistryResponse struct {
	// Bool value indicating if the image registry is default or not; by default workflow uses LitmusChaos registry
	IsDefault bool `json:"isDefault"`
	// Information Image Registry
	ImageRegistryInfo *ImageRegistry `json:"imageRegistryInfo"`
	// ID of the image registry
	ImageRegistryID string `json:"imageRegistryID"`
	// ID of the project in which image registry is created
	ProjectID string `json:"projectID"`
	// Timestamp when the image registry was last updated
	UpdatedAt *string `json:"updatedAt"`
	// Timestamp when the image registry was created
	CreatedAt *string `json:"createdAt"`
	// Bool value indicating if the image registry has been removed
	IsRemoved *bool `json:"isRemoved"`
}

type KubeGVRRequest struct {
	Group    string `json:"group"`
	Version  string `json:"version"`
	Resource string `json:"resource"`
}

// Defines the details of Kubernetes object
type KubeObjectData struct {
	// Unique request ID for fetching Kubernetes object details
	RequestID string `json:"requestID"`
	// ID of the cluster in which the Kubernetes object is present
	ClusterID *ClusterIdentity `json:"clusterID"`
	// Type of the Kubernetes object
	KubeObj string `json:"kubeObj"`
}

// Defines details for fetching Kubernetes object data
type KubeObjectRequest struct {
	// ID of the cluster in which the Kubernetes object is present
	ClusterID string `json:"clusterID"`
	// Type of the Kubernetes object to be fetched
	ObjectType     string          `json:"objectType"`
	KubeObjRequest *KubeGVRRequest `json:"kubeObjRequest"`
}

// Response received for querying Kubernetes Object
type KubeObjectResponse struct {
	// ID of the cluster in which the Kubernetes object is present
	ClusterID string `json:"clusterID"`
	// Type of the Kubernetes object
	KubeObj string `json:"kubeObj"`
}

type LabelValue struct {
	Label  string    `json:"label"`
	Values []*Option `json:"values"`
}

type Link struct {
	Name string `json:"name"`
	URL  string `json:"url"`
}

type ListDashboardResponse struct {
	DsID                      string                         `json:"dsID"`
	DbID                      string                         `json:"dbID"`
	DbName                    string                         `json:"dbName"`
	DbTypeID                  string                         `json:"dbTypeID"`
	DbTypeName                string                         `json:"dbTypeName"`
	DbInformation             *string                        `json:"dbInformation"`
	ChaosEventQueryTemplate   string                         `json:"chaosEventQueryTemplate"`
	ChaosVerdictQueryTemplate string                         `json:"chaosVerdictQueryTemplate"`
	ApplicationMetadataMap    []*ApplicationMetadataResponse `json:"applicationMetadataMap"`
	ClusterName               *string                        `json:"clusterName"`
	DsName                    *string                        `json:"dsName"`
	DsType                    *string                        `json:"dsType"`
	DsURL                     *string                        `json:"dsURL"`
	DsHealthStatus            *string                        `json:"dsHealthStatus"`
	PanelGroups               []*PanelGroupResponse          `json:"panelGroups"`
	EndTime                   string                         `json:"endTime"`
	StartTime                 string                         `json:"startTime"`
	RefreshRate               string                         `json:"refreshRate"`
	ProjectID                 string                         `json:"projectID"`
	ClusterID                 string                         `json:"clusterID"`
	CreatedAt                 *string                        `json:"createdAt"`
	UpdatedAt                 *string                        `json:"updatedAt"`
	ViewedAt                  *string                        `json:"viewedAt"`
}

// Defines the details for workflow runs
type ListWorkflowRunsRequest struct {
	// ID of the project
	ProjectID string `json:"projectID"`
	// Array of workflow run IDs for which details will be fetched
	WorkflowRunIDs []*string `json:"workflowRunIDs"`
	// Array of workflow IDs for which details will be fetched
	WorkflowIDs []*string `json:"workflowIDs"`
	// Details for fetching paginated data
	Pagination *Pagination `json:"pagination"`
	// Details for fetching sorted data
	Sort *WorkflowRunSortInput `json:"sort"`
	// Details for fetching filtered data
	Filter *WorkflowRunFilterInput `json:"filter"`
}

// Defines the details of a workflow to sent as response
type ListWorkflowRunsResponse struct {
	// Total number of workflow runs
	TotalNoOfWorkflowRuns int `json:"totalNoOfWorkflowRuns"`
	// Defines details of workflow runs
	WorkflowRuns []*WorkflowRun `json:"workflowRuns"`
}

// Defines the details for a workflow
type ListWorkflowsRequest struct {
	// ID of the project
	ProjectID string `json:"projectID"`
	// Array of workflow IDs for which details will be fetched
	WorkflowIDs []*string `json:"workflowIDs"`
	// Details for fetching paginated data
	Pagination *Pagination `json:"pagination"`
	// Details for fetching sorted data
	Sort *WorkflowSortInput `json:"sort"`
	// Details for fetching filtered data
	Filter *WorkflowFilterInput `json:"filter"`
}

// Defines the details for a workflow with total workflow count
type ListWorkflowsResponse struct {
	// Total number of workflows
	TotalNoOfWorkflows int `json:"totalNoOfWorkflows"`
	// Details related to the workflows
	Workflows []*Workflow `json:"workflows"`
}

// Defines the details of the maintainer
type Maintainer struct {
	// Name of the maintainer
	Name string `json:"name"`
	// Email of the maintainer
	Email string `json:"email"`
}

type Metadata struct {
	Name        string      `json:"name"`
	Version     string      `json:"version"`
	Annotations *Annotation `json:"annotations"`
}

type MetricDataForPanel struct {
	PanelID              string                 `json:"panelID"`
	PanelMetricsResponse []*MetricsPromResponse `json:"panelMetricsResponse"`
}

type MetricDataForPanelGroup struct {
	PanelGroupID              string                `json:"panelGroupID"`
	PanelGroupMetricsResponse []*MetricDataForPanel `json:"panelGroupMetricsResponse"`
}

type MetricsPromResponse struct {
	QueryID string                     `json:"queryID"`
	Legends []*string                  `json:"legends"`
	Tsvs    [][]*MetricsTimeStampValue `json:"tsvs"`
}

type MetricsTimeStampValue struct {
	Date  *float64 `json:"date"`
	Value *float64 `json:"value"`
}

type NewClusterEventRequest struct {
	EventName   string `json:"eventName"`
	Description string `json:"description"`
	ClusterID   string `json:"clusterID"`
	AccessKey   string `json:"accessKey"`
}

type Option struct {
	Name string `json:"name"`
}

type PackageInformation struct {
	PackageName string         `json:"packageName"`
	Experiments []*Experiments `json:"experiments"`
}

// Defines data required to fetch paginated data
type Pagination struct {
	// Page number for which data will be fetched
	Page int `json:"page"`
	// Number of data to be fetched
	Limit int `json:"limit"`
}

type Panel struct {
	PanelID      *string      `json:"panelID"`
	DbID         *string      `json:"dbID"`
	YAxisLeft    *string      `json:"yAxisLeft"`
	YAxisRight   *string      `json:"yAxisRight"`
	XAxisDown    *string      `json:"xAxisDown"`
	Unit         *string      `json:"unit"`
	PanelGroupID *string      `json:"panelGroupID"`
	CreatedAt    *string      `json:"createdAt"`
	PromQueries  []*PromQuery `json:"promQueries"`
	PanelOptions *PanelOption `json:"panelOptions"`
	PanelName    string       `json:"panelName"`
}

type PanelGroup struct {
	Panels         []*Panel `json:"panels"`
	PanelGroupName string   `json:"panelGroupName"`
}

type PanelGroupResponse struct {
	Panels         []*PanelResponse `json:"panels"`
	PanelGroupName string           `json:"panelGroupName"`
	PanelGroupID   *string          `json:"panelGroupID"`
}

type PanelOption struct {
	Points   *bool `json:"points"`
	GrIDs    *bool `json:"grIDs"`
	LeftAxis *bool `json:"leftAxis"`
}

type PanelOptionResponse struct {
	Points   *bool `json:"points"`
	GrIDs    *bool `json:"grIDs"`
	LeftAxis *bool `json:"leftAxis"`
}

type PanelResponse struct {
	PanelID      string               `json:"panelID"`
	YAxisLeft    *string              `json:"yAxisLeft"`
	YAxisRight   *string              `json:"yAxisRight"`
	XAxisDown    *string              `json:"xAxisDown"`
	Unit         *string              `json:"unit"`
	PromQueries  []*PromQueryResponse `json:"promQueries"`
	PanelOptions *PanelOptionResponse `json:"panelOptions"`
	PanelName    *string              `json:"panelName"`
	CreatedAt    *string              `json:"createdAt"`
}

// Response received for querying pod logs
type PodLog struct {
	// ID of the cluster
	ClusterID *ClusterIdentity `json:"clusterID"`
	// Unique request ID of a particular node which is being queried
	RequestID string `json:"requestID"`
	// ID of a workflow run
	WorkflowRunID string `json:"workflowRunID"`
	// Name of the pod for which logs are required
	PodName string `json:"podName"`
	// Type of the pod: chaosengine
	PodType string `json:"podType"`
	// Logs for the pod
	Log string `json:"log"`
}

// Defines the details for fetching the pod logs
type PodLogRequest struct {
	// ID of the cluster
	ClusterID string `json:"clusterID"`
	// ID of a workflow run
	WorkflowRunID string `json:"workflowRunID"`
	// Name of the pod for which logs are required
	PodName string `json:"podName"`
	// Namespace where the pod is running
	PodNamespace string `json:"podNamespace"`
	// Type of the pod: chaosEngine or not pod
	PodType string `json:"podType"`
	// Name of the experiment pod fetched from execution data
	ExpPod *string `json:"expPod"`
	// Name of the runner pod fetched from execution data
	RunnerPod *string `json:"runnerPod"`
	// Namespace where the experiment is executing
	ChaosNamespace *string `json:"chaosNamespace"`
}

// Defines the response received for querying querying the pod logs
type PodLogResponse struct {
	// ID of the workflow run which is to be queried
	WorkflowRunID string `json:"workflowRunID"`
	// Name of the pod for which logs are queried
	PodName string `json:"podName"`
	// Type of the pod: chaosengine
	PodType string `json:"podType"`
	// Logs for the pod
	Log string `json:"log"`
}

type PortalDashboardDataResponse struct {
	Name          string `json:"name"`
	DashboardData string `json:"dashboardData"`
}

type PredefinedWorkflowList struct {
	// Name of the workflow
	WorkflowName string `json:"workflowName"`
	// Workflow CSV
	WorkflowCsv string `json:"workflowCSV"`
	// Workflow Manifest
	WorkflowManifest string `json:"workflowManifest"`
}

// Defines all the stats under a project
type ProjectData struct {
	// Workflow related statistics
	Workflows *WorkflowStat `json:"workflows"`
	// Agent related statistics
	Agents *AgentStat `json:"agents"`
	// ID of the project
	ProjectID string `json:"projectID"`
}

type PromQuery struct {
	QueryID       string  `json:"queryID"`
	PromQueryName *string `json:"promQueryName"`
	Legend        *string `json:"legend"`
	Resolution    *string `json:"resolution"`
	Minstep       *string `json:"minstep"`
	Line          *bool   `json:"line"`
	CloseArea     *bool   `json:"closeArea"`
}

type PromQueryInput struct {
	QueryID    string  `json:"queryID"`
	Query      string  `json:"query"`
	Legend     *string `json:"legend"`
	Resolution *string `json:"resolution"`
	Minstep    int     `json:"minstep"`
}

type PromQueryResponse struct {
	QueryID       string  `json:"queryID"`
	PromQueryName *string `json:"promQueryName"`
	Legend        *string `json:"legend"`
	Resolution    *string `json:"resolution"`
	Minstep       *string `json:"minstep"`
	Line          *bool   `json:"line"`
	CloseArea     *bool   `json:"closeArea"`
}

type PromSeriesInput struct {
	Series    string     `json:"series"`
	DsDetails *DsDetails `json:"dsDetails"`
}

type PromSeriesListResponse struct {
	SeriesList []*string `json:"seriesList"`
}

type PromSeriesResponse struct {
	Series      string        `json:"series"`
	LabelValues []*LabelValue `json:"labelValues"`
}

type PrometheusDataRequest struct {
	Queries   []*PromQueryInput `json:"queries"`
	DsDetails *DsDetails        `json:"dsDetails"`
}

type PrometheusDataResponse struct {
	MetricsResponse     []*MetricsPromResponse     `json:"metricsResponse"`
	AnnotationsResponse []*AnnotationsPromResponse `json:"annotationsResponse"`
}

type Provider struct {
	Name string `json:"name"`
}

type QueryMapForPanel struct {
	PanelID  string   `json:"panelID"`
	QueryIDs []string `json:"queryIDs"`
}

type QueryMapForPanelGroup struct {
	PanelGroupID  string              `json:"panelGroupID"`
	PanelQueryMap []*QueryMapForPanel `json:"panelQueryMap"`
}

// Defines the details for the new cluster being connected
type RegisterClusterRequest struct {
	// Name of the cluster
	ClusterName string `json:"clusterName"`
	// Description of the cluster
	Description *string `json:"description"`
	// Cluster Platform Name eg. GKE,AWS, Others
	PlatformName string `json:"platformName"`
	// Project ID the cluster is being connected to
	ProjectID string `json:"projectID"`
	// Cluster type : Internal or External
	ClusterType string `json:"clusterType"`
	// Namespace where the cluster agent is being installed
	AgentNamespace *string `json:"agentNamespace"`
	// Name of service account used by cluster agent
	ServiceAccount *string `json:"serviceAccount"`
	// Scope of the cluster agent : ns or cluster
	AgentScope string `json:"agentScope"`
	// Bool value indicating whether agent ns used already exists on cluster or not
	AgentNsExists *bool `json:"agentNsExists"`
	// Bool value indicating whether service account used already exists on cluster or not
	AgentSaExists *bool `json:"agentSaExists"`
	// Bool value indicating whether agent will skip ssl checks or not
	SkipSsl *bool `json:"skipSsl"`
	// Node selectors used by cluster agent
	NodeSelector *string `json:"nodeSelector"`
	// Node tolerations used by cluster agent
	Tolerations []*Toleration `json:"tolerations"`
}

// Response received for registering a new cluster
type RegisterClusterResponse struct {
	// Token used to verify and retrieve the cluster agent manifest
	Token string `json:"token"`
	// Unique ID for the newly registered cluster
	ClusterID string `json:"clusterID"`
	// Cluster name as sent in request
	ClusterName string `json:"clusterName"`
}

type Resource struct {
	Kind  string    `json:"kind"`
	Names []*string `json:"names"`
}

type ResourceResponse struct {
	Kind  string    `json:"kind"`
	Names []*string `json:"names"`
}

// Defines the SSHKey details
type SSHKey struct {
	// Public SSH key authenticating into git repository
	PublicKey string `json:"publicKey"`
	// Private SSH key authenticating into git repository
	PrivateKey string `json:"privateKey"`
}

type ServerVersionResponse struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type Spec struct {
	DisplayName         string        `json:"displayName"`
	CategoryDescription string        `json:"categoryDescription"`
	Keywords            []string      `json:"keywords"`
	Maturity            string        `json:"maturity"`
	Maintainers         []*Maintainer `json:"maintainers"`
	MinKubeVersion      string        `json:"minKubeVersion"`
	Provider            *Provider     `json:"provider"`
	Links               []*Link       `json:"links"`
	Experiments         []string      `json:"experiments"`
	ChaosExpCRDLink     string        `json:"chaosExpCRDLink"`
	Platforms           []string      `json:"platforms"`
	ChaosType           *string       `json:"chaosType"`
}

type SubData struct {
	Date        *float64 `json:"date"`
	Value       string   `json:"value"`
	SubDataName string   `json:"subDataName"`
}

// Details for saving the template
type TemplateInput struct {
	// Workflow manifest in JSON escaped format
	Manifest string `json:"manifest"`
	// Name of the template
	TemplateName string `json:"templateName"`
	// Description of the template
	TemplateDescription string `json:"templateDescription"`
	// Name of the project
	ProjectID string `json:"projectID"`
	// Bool value indicating whether the workflow is a custom workflow or not
	IsCustomWorkflow bool `json:"isCustomWorkflow"`
}

type Toleration struct {
	TolerationSeconds *int    `json:"tolerationSeconds"`
	Key               *string `json:"key"`
	Operator          *string `json:"operator"`
	Effect            *string `json:"effect"`
	Value             *string `json:"value"`
}

// Defines total number of projects, users, agents and workflows
type TotalCount struct {
	// Total number of projects
	Projects int `json:"projects"`
	// Total number of users
	Users int `json:"users"`
	// Total number of agents
	Agents *AgentStat `json:"agents"`
	// Total number of workflows
	Workflows *WorkflowStat `json:"workflows"`
}

type UpdateChaosHubRequest struct {
	// ID of the chaos hub
	ID string `json:"id"`
	// Name of the chaos hub
	HubName string `json:"hubName"`
	// URL of the git repository
	RepoURL string `json:"repoURL"`
	// Branch of the git repository
	RepoBranch string `json:"repoBranch"`
	// Bool value indicating whether the hub is private or not.
	IsPrivate bool `json:"isPrivate"`
	// Type of authentication used: 	BASIC, SSH,	TOKEN
	AuthType AuthType `json:"authType"`
	// Token for authentication of private chaos hub
	Token *string `json:"token"`
	// Git username
	UserName *string `json:"userName"`
	// Git password
	Password *string `json:"password"`
	// Private SSH key for authenticating into private chaos hub
	SSHPrivateKey *string `json:"sshPrivateKey"`
	// Public SSH key for authenticating into private chaos hub
	SSHPublicKey *string `json:"sshPublicKey"`
	// Project ID associated with this chaos hub
	ProjectID string `json:"projectID"`
}

type UpdateDBInput struct {
	DbID                      string                   `json:"dbID"`
	DsID                      *string                  `json:"dsID"`
	DbName                    *string                  `json:"dbName"`
	DbTypeName                *string                  `json:"dbTypeName"`
	DbTypeID                  *string                  `json:"dbTypeID"`
	DbInformation             *string                  `json:"dbInformation"`
	ChaosEventQueryTemplate   *string                  `json:"chaosEventQueryTemplate"`
	ChaosVerdictQueryTemplate *string                  `json:"chaosVerdictQueryTemplate"`
	ApplicationMetadataMap    []*ApplicationMetadata   `json:"applicationMetadataMap"`
	PanelGroups               []*UpdatePanelGroupInput `json:"panelGroups"`
	EndTime                   *string                  `json:"endTime"`
	StartTime                 *string                  `json:"startTime"`
	ClusterID                 *string                  `json:"clusterID"`
	RefreshRate               *string                  `json:"refreshRate"`
}

type UpdatePanelGroupInput struct {
	PanelGroupName string   `json:"panelGroupName"`
	PanelGroupID   string   `json:"panelGroupID"`
	Panels         []*Panel `json:"panels"`
}

// Defines input details for querying the total usage related details
type UsageDataRequest struct {
	// Pagination detail to fetch only a required number of data at a time
	Pagination *Pagination `json:"pagination"`
	// Rage of dates between which the data will be fetched
	DateRange *DateRange `json:"dateRange"`
	// Sorting details to fetch the data in a sorted manner
	Sort *UsageSortInput `json:"sort"`
	// Search field to search for a particular project and fetch it's data
	SearchProject *string `json:"searchProject"`
}

// Defines total usage data
type UsageDataResponse struct {
	// Project related data
	Projects []*ProjectData `json:"projects"`
	// Total number of entries
	TotalEntries int `json:"totalEntries"`
	// Total number of projects, users, agents and workflows
	TotalCount *TotalCount `json:"totalCount"`
}

// Defines details required for sorting the data for a particular field
type UsageSortInput struct {
	// Field for which sorting will be done
	Field UsageSort `json:"field"`
	// Bool value indicating if sorting will be done in descending order or not
	Descending bool `json:"descending"`
}

// Defines the details of the weightages of each chaos experiment in the workflow
type Weightages struct {
	// Name of the experiment
	ExperimentName string `json:"experimentName"`
	// Weightage of the experiment
	Weightage int `json:"weightage"`
}

// Defines the details of the weightages of each chaos experiment in the workflow
type WeightagesInput struct {
	// Name of the experiment
	ExperimentName string `json:"experimentName"`
	// Weightage of the experiment
	Weightage int `json:"weightage"`
}

// Defines the details for a workflow
type Workflow struct {
	// ID of the workflow
	WorkflowID string `json:"workflowID"`
	// Manifest of the workflow
	WorkflowManifest string `json:"workflowManifest"`
	// Cron syntax of the workflow schedule
	CronSyntax string `json:"cronSyntax"`
	// Name of the target cluster in which the workflow is running
	ClusterName string `json:"clusterName"`
	// Name of the workflow
	WorkflowName string `json:"workflowName"`
	// Description of the workflow
	WorkflowDescription string `json:"workflowDescription"`
	// Array containing weightage and name of each chaos experiment in the workflow
	Weightages []*Weightages `json:"weightages"`
	// Bool value indicating whether the workflow is a custom workflow or not
	IsCustomWorkflow bool `json:"isCustomWorkflow"`
	// Timestamp when the workflow was last updated
	UpdatedAt string `json:"updatedAt"`
	// Timestamp when the workflow was created
	CreatedAt string `json:"createdAt"`
	// ID of the project under which the workflow is scheduled
	ProjectID string `json:"projectID"`
	// ID of the target cluster in which the workflow will run
	ClusterID string `json:"clusterID"`
	// Cluster type : Internal or External
	ClusterType string `json:"clusterType"`
	// Bool value indicating if the workflow has removed
	IsRemoved bool `json:"isRemoved"`
	// Provides audit context to workflow i.e who ran the workflow
	LastUpdatedBy *string `json:"lastUpdatedBy"`
}

// Defines filter options for workflows
type WorkflowFilterInput struct {
	// Name of the workflow
	WorkflowName *string `json:"workflowName"`
	// Name of the cluster agent in which the workflow is running
	ClusterName *string `json:"clusterName"`
}

// Defines the details of a workflow run
type WorkflowRun struct {
	// ID of the workflow run which is to be queried
	WorkflowRunID string `json:"workflowRunID"`
	// ID of the workflow
	WorkflowID string `json:"workflowID"`
	// Name of the cluster agent in which the workflow is running
	ClusterName string `json:"clusterName"`
	// Array containing weightage and name of each chaos experiment in the workflow
	Weightages []*Weightages `json:"weightages"`
	// Timestamp at which workflow run was last updated
	LastUpdated string `json:"lastUpdated"`
	// ID of the project
	ProjectID string `json:"projectID"`
	// ID of the target cluster in which the workflow is running
	ClusterID string `json:"clusterID"`
	// Name of the workflow
	WorkflowName string `json:"workflowName"`
	// Cluster type : Internal or External
	ClusterType *string `json:"clusterType"`
	// Phase of the workflow run
	Phase string `json:"phase"`
	// Resiliency score of the workflow
	ResiliencyScore *float64 `json:"resiliencyScore"`
	// Number of experiments passed
	ExperimentsPassed *int `json:"experimentsPassed"`
	// Number of experiments failed
	ExperimentsFailed *int `json:"experimentsFailed"`
	// Number of experiments awaited
	ExperimentsAwaited *int `json:"experimentsAwaited"`
	// Number of experiments stopped
	ExperimentsStopped *int `json:"experimentsStopped"`
	// Number of experiments which are not available
	ExperimentsNa *int `json:"experimentsNa"`
	// Total number of experiments
	TotalExperiments *int `json:"totalExperiments"`
	// Stores all the workflow run details related to the nodes of DAG graph and chaos results of the experiments
	ExecutionData string `json:"executionData"`
	// Bool value indicating if the workflow run has removed
	IsRemoved *bool `json:"isRemoved"`
	// Provides audit context to workflow run i.e who ran the workflow
	ExecutedBy string `json:"executedBy"`
}

type WorkflowRunDetails struct {
	NoOfRuns  int     `json:"noOfRuns"`
	DateStamp float64 `json:"dateStamp"`
}

// Defines input type for workflow run filter
type WorkflowRunFilterInput struct {
	// Name of the workflow
	WorkflowName *string `json:"workflowName"`
	// Name of the cluster agent
	ClusterName *string `json:"clusterName"`
	// Status of the workflow run
	WorkflowStatus *WorkflowRunStatus `json:"workflowStatus"`
	// Date range for filtering purpose
	DateRange *DateRange `json:"dateRange"`
}

// Defines the details for a workflow run
type WorkflowRunRequest struct {
	// ID of the workflow
	WorkflowID string `json:"workflowID"`
	// ID of the workflow run which is to be queried
	WorkflowRunID string `json:"workflowRunID"`
	// Name of the workflow
	WorkflowName string `json:"workflowName"`
	// Provides audit context to workflow run i.e who ran the workflow
	ExecutedBy string `json:"executedBy"`
	// Stores all the workflow run details related to the nodes of DAG graph and chaos results of the experiments
	ExecutionData string `json:"executionData"`
	// ID of the cluster agent in which the workflow is running
	ClusterID *ClusterIdentity `json:"clusterID"`
	// Bool value indicating if the workflow run has completed
	Completed bool `json:"completed"`
	// Bool value indicating if the workflow run has removed
	IsRemoved *bool `json:"isRemoved"`
}

// Defines sorting options for workflow runs
type WorkflowRunSortInput struct {
	// Field in which sorting will be done
	Field WorkflowSortingField `json:"field"`
	// Bool value indicating whether the sorting will be done in descending order
	Descending *bool `json:"descending"`
}

type WorkflowRunStatsRequest struct {
	ProjectID   string    `json:"projectID"`
	WorkflowIDs []*string `json:"workflowIDs"`
}

type WorkflowRunStatsResponse struct {
	TotalWorkflowRuns              int     `json:"totalWorkflowRuns"`
	SucceededWorkflowRuns          int     `json:"succeededWorkflowRuns"`
	FailedWorkflowRuns             int     `json:"failedWorkflowRuns"`
	RunningWorkflowRuns            int     `json:"runningWorkflowRuns"`
	AverageResiliencyScore         float64 `json:"averageResiliencyScore"`
	TotalExperiments               int     `json:"totalExperiments"`
	ExperimentsPassed              int     `json:"experimentsPassed"`
	ExperimentsFailed              int     `json:"experimentsFailed"`
	ExperimentsAwaited             int     `json:"experimentsAwaited"`
	ExperimentsStopped             int     `json:"experimentsStopped"`
	ExperimentsNa                  int     `json:"experimentsNa"`
	PassedPercentage               float64 `json:"passedPercentage"`
	FailedPercentage               float64 `json:"failedPercentage"`
	WorkflowRunSucceededPercentage float64 `json:"workflowRunSucceededPercentage"`
	WorkflowRunFailedPercentage    float64 `json:"workflowRunFailedPercentage"`
}

type WorkflowRunsData struct {
	Value             *float64            `json:"value"`
	WorkflowRunDetail *WorkflowRunDetails `json:"workflowRunDetail"`
}

// Defines sorting options for workflow
type WorkflowSortInput struct {
	// Field in which sorting will be done
	Field WorkflowSortingField `json:"field"`
	// Bool value indicating whether the sorting will be done in descending order
	Descending *bool `json:"descending"`
}

// Defines details of workflow statistics
type WorkflowStat struct {
	// Number of schedules
	Schedules int `json:"schedules"`
	// Number of workflow runs
	Runs int `json:"runs"`
	// Number of experiment runs
	ExpRuns int `json:"expRuns"`
}

type WorkflowStatsResponse struct {
	Date  float64 `json:"date"`
	Value int     `json:"value"`
}

// Details for a workflow template
type WorkflowTemplate struct {
	// ID of the template
	TemplateID string `json:"templateID"`
	// Workflow manifest in JSON escaped string
	Manifest string `json:"manifest"`
	// Name of the template
	TemplateName string `json:"templateName"`
	// Description of the template
	TemplateDescription string `json:"templateDescription"`
	// ID of the project
	ProjectID string `json:"projectID"`
	// Name of the project
	ProjectName string `json:"projectName"`
	// Time at which the manifest template was created
	CreatedAt string `json:"createdAt"`
	// Bool value indicating if the workflow template has removed
	IsRemoved bool `json:"isRemoved"`
	// Bool value indicating whether the workflow template is a custom or not
	IsCustomWorkflow bool `json:"isCustomWorkflow"`
}

type AuthType string

const (
	AuthTypeBasic AuthType = "BASIC"
	AuthTypeNone  AuthType = "NONE"
	AuthTypeSSH   AuthType = "SSH"
	AuthTypeToken AuthType = "TOKEN"
)

var AllAuthType = []AuthType{
	AuthTypeBasic,
	AuthTypeNone,
	AuthTypeSSH,
	AuthTypeToken,
}

func (e AuthType) IsValid() bool {
	switch e {
	case AuthTypeBasic, AuthTypeNone, AuthTypeSSH, AuthTypeToken:
		return true
	}
	return false
}

func (e AuthType) String() string {
	return string(e)
}

func (e *AuthType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuthType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuthType", str)
	}
	return nil
}

func (e AuthType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FileType string

const (
	FileTypeExperiment FileType = "EXPERIMENT"
	FileTypeEngine     FileType = "ENGINE"
	FileTypeWorkflow   FileType = "WORKFLOW"
	FileTypeCsv        FileType = "CSV"
)

var AllFileType = []FileType{
	FileTypeExperiment,
	FileTypeEngine,
	FileTypeWorkflow,
	FileTypeCsv,
}

func (e FileType) IsValid() bool {
	switch e {
	case FileTypeExperiment, FileTypeEngine, FileTypeWorkflow, FileTypeCsv:
		return true
	}
	return false
}

func (e FileType) String() string {
	return string(e)
}

func (e *FileType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FileType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FileType", str)
	}
	return nil
}

func (e FileType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HubType string

const (
	HubTypeGit    HubType = "GIT"
	HubTypeRemote HubType = "REMOTE"
)

var AllHubType = []HubType{
	HubTypeGit,
	HubTypeRemote,
}

func (e HubType) IsValid() bool {
	switch e {
	case HubTypeGit, HubTypeRemote:
		return true
	}
	return false
}

func (e HubType) String() string {
	return string(e)
}

func (e *HubType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HubType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HubType", str)
	}
	return nil
}

func (e HubType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Invitation string

const (
	InvitationAccepted Invitation = "Accepted"
	InvitationPending  Invitation = "Pending"
)

var AllInvitation = []Invitation{
	InvitationAccepted,
	InvitationPending,
}

func (e Invitation) IsValid() bool {
	switch e {
	case InvitationAccepted, InvitationPending:
		return true
	}
	return false
}

func (e Invitation) String() string {
	return string(e)
}

func (e *Invitation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Invitation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Invitation", str)
	}
	return nil
}

func (e Invitation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MemberRole string

const (
	MemberRoleOwner  MemberRole = "Owner"
	MemberRoleEditor MemberRole = "Editor"
	MemberRoleViewer MemberRole = "Viewer"
)

var AllMemberRole = []MemberRole{
	MemberRoleOwner,
	MemberRoleEditor,
	MemberRoleViewer,
}

func (e MemberRole) IsValid() bool {
	switch e {
	case MemberRoleOwner, MemberRoleEditor, MemberRoleViewer:
		return true
	}
	return false
}

func (e MemberRole) String() string {
	return string(e)
}

func (e *MemberRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MemberRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MemberRole", str)
	}
	return nil
}

func (e MemberRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TimeFrequency string

const (
	TimeFrequencyDaily   TimeFrequency = "DAILY"
	TimeFrequencyHourly  TimeFrequency = "HOURLY"
	TimeFrequencyMonthly TimeFrequency = "MONTHLY"
)

var AllTimeFrequency = []TimeFrequency{
	TimeFrequencyDaily,
	TimeFrequencyHourly,
	TimeFrequencyMonthly,
}

func (e TimeFrequency) IsValid() bool {
	switch e {
	case TimeFrequencyDaily, TimeFrequencyHourly, TimeFrequencyMonthly:
		return true
	}
	return false
}

func (e TimeFrequency) String() string {
	return string(e)
}

func (e *TimeFrequency) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimeFrequency(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimeFrequency", str)
	}
	return nil
}

func (e TimeFrequency) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UsageSort string

const (
	UsageSortAgents         UsageSort = "AGENTS"
	UsageSortExperimentRuns UsageSort = "EXPERIMENT_RUNS"
	UsageSortOwner          UsageSort = "OWNER"
	UsageSortProject        UsageSort = "PROJECT"
	UsageSortSchedules      UsageSort = "SCHEDULES"
	UsageSortTeamMembers    UsageSort = "TEAM_MEMBERS"
	UsageSortWorkflowRuns   UsageSort = "WORKFLOW_RUNS"
)

var AllUsageSort = []UsageSort{
	UsageSortAgents,
	UsageSortExperimentRuns,
	UsageSortOwner,
	UsageSortProject,
	UsageSortSchedules,
	UsageSortTeamMembers,
	UsageSortWorkflowRuns,
}

func (e UsageSort) IsValid() bool {
	switch e {
	case UsageSortAgents, UsageSortExperimentRuns, UsageSortOwner, UsageSortProject, UsageSortSchedules, UsageSortTeamMembers, UsageSortWorkflowRuns:
		return true
	}
	return false
}

func (e UsageSort) String() string {
	return string(e)
}

func (e *UsageSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsageSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UsageSort", str)
	}
	return nil
}

func (e UsageSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WorkflowRunStatus string

const (
	WorkflowRunStatusAll        WorkflowRunStatus = "All"
	WorkflowRunStatusFailed     WorkflowRunStatus = "Failed"
	WorkflowRunStatusRunning    WorkflowRunStatus = "Running"
	WorkflowRunStatusSucceeded  WorkflowRunStatus = "Succeeded"
	WorkflowRunStatusTerminated WorkflowRunStatus = "Terminated"
)

var AllWorkflowRunStatus = []WorkflowRunStatus{
	WorkflowRunStatusAll,
	WorkflowRunStatusFailed,
	WorkflowRunStatusRunning,
	WorkflowRunStatusSucceeded,
	WorkflowRunStatusTerminated,
}

func (e WorkflowRunStatus) IsValid() bool {
	switch e {
	case WorkflowRunStatusAll, WorkflowRunStatusFailed, WorkflowRunStatusRunning, WorkflowRunStatusSucceeded, WorkflowRunStatusTerminated:
		return true
	}
	return false
}

func (e WorkflowRunStatus) String() string {
	return string(e)
}

func (e *WorkflowRunStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowRunStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowRunStatus", str)
	}
	return nil
}

func (e WorkflowRunStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WorkflowSortingField string

const (
	WorkflowSortingFieldName WorkflowSortingField = "NAME"
	WorkflowSortingFieldTime WorkflowSortingField = "TIME"
)

var AllWorkflowSortingField = []WorkflowSortingField{
	WorkflowSortingFieldName,
	WorkflowSortingFieldTime,
}

func (e WorkflowSortingField) IsValid() bool {
	switch e {
	case WorkflowSortingFieldName, WorkflowSortingFieldTime:
		return true
	}
	return false
}

func (e WorkflowSortingField) String() string {
	return string(e)
}

func (e *WorkflowSortingField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowSortingField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowSortingField", str)
	}
	return nil
}

func (e WorkflowSortingField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
